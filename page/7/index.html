<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lessisbetter.site","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="云原生、Go语言、区块链">
<meta property="og:type" content="website">
<meta property="og:title" content="Go语言充电站">
<meta property="og:url" content="http://lessisbetter.site/page/7/index.html">
<meta property="og:site_name" content="Go语言充电站">
<meta property="og:description" content="云原生、Go语言、区块链">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="大彬">
<meta property="article:tag" content="云原生 k8s kubernetes 区块链 Go语言 后端 技术 人生 编程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lessisbetter.site/page/7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Go语言充电站</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Go语言充电站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大彬 less is better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li>
        <li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-专题"><a href="/subject/" rel="section"><i class="fa fa-calendar fa-fw"></i>专题</a></li>
        <li class="menu-item menu-item-大牛博客"><a href="/blogs/" rel="section"><i class="fa fa-calendar fa-fw"></i>大牛博客</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="大彬"
      src="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
  <p class="site-author-name" itemprop="name">大彬</p>
  <div class="site-description" itemprop="description">云原生、Go语言、区块链</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">138</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://xargin.com/" title="Xargin曹大博客 → https:&#x2F;&#x2F;xargin.com&#x2F;" rel="noopener" target="_blank">Xargin曹大博客</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://qcrao.github.io/" title="码农桃花源博客 → https:&#x2F;&#x2F;qcrao.github.io&#x2F;" rel="noopener" target="_blank">码农桃花源博客</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://book.eddycjy.com/golang/" title="煎鱼博客 → https:&#x2F;&#x2F;book.eddycjy.com&#x2F;golang&#x2F;" rel="noopener" target="_blank">煎鱼博客</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/05/18/go-goroutine-leak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/18/go-goroutine-leak/" class="post-title-link" itemprop="url">实战Go内存泄露</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-18 10:30:47" itemprop="dateCreated datePublished" datetime="2019-05-18T10:30:47+08:00">2019-05-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近解决了我们项目中的一个内存泄露问题，事实再次证明pprof是一个好工具，但掌握好工具的正确用法，才能发挥好工具的威力，不然就算你手里有屠龙刀，也成不了天下第一，本文就是带你用pprof定位内存泄露问题。</p>
<p>关于Go的内存泄露有这么一句话不知道你听过没有：</p>
<blockquote>
<p>10次内存泄露，有9次是goroutine泄露。</p>
</blockquote>
<p>我所解决的问题，也是goroutine泄露导致的内存泄露，所以<strong>这篇文章主要介绍Go程序的goroutine泄露，掌握了如何定位和解决goroutine泄露，就掌握了内存泄露的大部分场景</strong>。</p>
<blockquote>
<p>本文草稿最初数据都是生产坏境数据，为了防止敏感内容泄露，全部替换成了demo数据，demo的数据比生产环境数据简单多了，更适合入门理解，有助于掌握pprof。</p>
</blockquote>
<hr>
<h1 id="go-pprof基本知识"><a href="#go-pprof基本知识" class="headerlink" title="go pprof基本知识"></a>go pprof基本知识</h1><p>定位goroutine泄露会使用到pprof，pprof是Go的性能工具，在开始介绍内存泄露前，先简单介绍下pprof的基本使用，更详细的使用给大家推荐了资料。</p>
<h2 id="什么是pprof"><a href="#什么是pprof" class="headerlink" title="什么是pprof"></a>什么是pprof</h2><p>pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等，当需要性能调优或者定位Bug时候，这些记录的信息是相当重要。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用pprof有多种方式，Go已经现成封装好了1个：<code>net/http/pprof</code>，使用简单的几行命令，就可以开启pprof，记录运行信息，并且提供了Web服务，能够通过浏览器和命令行2种方式获取运行数据。</p>
<p>看个最简单的pprof的例子：</p>
<p><em>文件：<a target="_blank" rel="noopener" href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/pprof/demo.go">golang_step_by_step/pprof/pprof/demo.go</a></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof，监听请求</span></span><br><span class="line">	ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>提醒：本文所有代码部分可左右滑动</em></p>
<h3 id="浏览器方式"><a href="#浏览器方式" class="headerlink" title="浏览器方式"></a>浏览器方式</h3><p><img src="https://lessisbetter.site/images/2019-05-image-20190516173924325-7999564.png" alt="image-20190516173924325"></p>
<p>输入网址<code>ip:port/debug/pprof/</code>打开pprof主页，从上到下依次是<strong>5类profile信息</strong>：</p>
<ol>
<li><strong>block</strong>：goroutine的阻塞信息，本例就截取自一个goroutine阻塞的demo，但block为0，没掌握block的用法</li>
<li><strong>goroutine</strong>：所有goroutine的信息，下面的<code>full goroutine stack dump</code>是输出所有goroutine的调用栈，是goroutine的debug=2，后面会详细介绍。</li>
<li><strong>heap</strong>：堆内存的信息</li>
<li><strong>mutex</strong>：锁的信息</li>
<li><strong>threadcreate</strong>：线程信息</li>
</ol>
<p>这篇文章我们主要关注goroutine和heap，这两个都会打印调用栈信息，goroutine里面还会包含goroutine的数量信息，heap则是内存分配信息，本文用不到的地方就不展示了，最后推荐几篇文章大家去看。</p>
<h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><p>当连接在服务器终端上的时候，是没有浏览器可以使用的，Go提供了命令行的方式，能够获取以上5类信息，这种方式用起来更方便。</p>
<p>使用命令<code>go tool pprof url</code>可以获取指定的profile文件，此命令会发起http请求，然后下载数据到本地，之后进入交互式模式，就像gdb一样，可以使用命令查看运行信息，以下是5类请求的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载cpu profile，默认从当前开始收集30s的cpu使用情况，需要等待30s</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/profile   <span class="comment"># 30-second CPU profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/profile?seconds=120     <span class="comment"># wait 120s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载heap profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/heap      <span class="comment"># heap profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载goroutine profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/goroutine <span class="comment"># goroutine profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载block profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/block     <span class="comment"># goroutine blocking profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载mutex profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/mutex</span><br></pre></td></tr></table></figure>

<p>上面的<code>pprof/demo.go</code>太简单了，如果去获取内存profile，几乎获取不到什么，换一个Demo进行内存profile的展示：</p>
<p><em>文件：<a target="_blank" rel="noopener" href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/heap/demo2.go">golang_step_by_step/pprof/heap/demo2.go</a></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示内存增长和pprof，并不是泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行一段时间：fatal error: runtime: out of memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">		buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个demo会不断的申请内存，把它编译运行起来，然后执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:6060/debug/pprof/heap</span></span><br><span class="line"></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6060/debug/pprof/heap</span></span><br><span class="line">Saved profile in /home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz       <span class="comment">//&lt;--- 下载到的内存profile文件</span></span><br><span class="line">File: demo <span class="comment">// 程序名称</span></span><br><span class="line">Build ID: a9069a125ee9c0df3713b2149ca859e8d4d11d5a</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">8</span>:<span class="number">55</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) help  <span class="comment">// 使用help打印所有可用命令</span></span><br><span class="line">  Commands:</span><br><span class="line">    callgrind        Outputs a graph in callgrind format</span><br><span class="line">    comments         Output all profile comments</span><br><span class="line">    disasm           Output assembly listings annotated with samples</span><br><span class="line">    dot              Outputs a graph in DOT format</span><br><span class="line">    eog              Visualize graph through eog</span><br><span class="line">    evince           Visualize graph through evince</span><br><span class="line">    gif              Outputs a graph image in GIF format</span><br><span class="line">    gv               Visualize graph through gv</span><br><span class="line">    kcachegrind      Visualize report in KCachegrind</span><br><span class="line">    list             Output annotated source <span class="keyword">for</span> functions matching regexp</span><br><span class="line">    pdf              Outputs a graph in PDF format</span><br><span class="line">    peek             Output callers/callees of functions matching regexp</span><br><span class="line">    png              Outputs a graph image in PNG format</span><br><span class="line">    proto            Outputs the profile in compressed protobuf format</span><br><span class="line">    ps               Outputs a graph in PS format</span><br><span class="line">    raw              Outputs a text representation of the raw profile</span><br><span class="line">    svg              Outputs a graph in SVG format</span><br><span class="line">    tags             Outputs all tags in the profile</span><br><span class="line">    text             Outputs top entries in text form</span><br><span class="line">    top              Outputs top entries in text form</span><br><span class="line">    topproto         Outputs top entries in compressed protobuf format</span><br><span class="line">    traces           Outputs all profile samples in text form</span><br><span class="line">    tree             Outputs a text rendering of call graph</span><br><span class="line">    web              Visualize graph through web browser</span><br><span class="line">    weblist          Display annotated source in a web browser</span><br><span class="line">    o/options        List options and their current values</span><br><span class="line">    quit/exit/^D     Exit pprof</span><br><span class="line">    </span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>

<p>以上信息我们只关注2个地方：</p>
<ol>
<li>下载得到的文件：<code>/home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz</code>，这其中包含了程序名<code>demo</code>，profile类型<code>alloc</code>已分配的内存，<code>inuse</code>代表使用中的内存。</li>
<li><code>help</code>可以获取帮助，最先会列出支持的命令，想掌握pprof，要多看看，多尝试。</li>
</ol>
<p>关于命令，本文只会用到3个，我认为也是最常用的：<code>top</code>、<code>list</code>、<code>traces</code>，分别介绍一下。</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>按指标大小列出前10个函数，比如内存是按内存占用多少，CPU是按执行时间多少。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">814.62</span>MB, <span class="number">100</span>% of <span class="number">814.62</span>MB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">100</span>%   <span class="number">100</span>%   <span class="number">814.62</span>MB   <span class="number">100</span>%  main.main</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%   <span class="number">814.62</span>MB   <span class="number">100</span>%  runtime.main</span><br></pre></td></tr></table></figure>

<p>top会列出5个统计数据：</p>
<ul>
<li>flat: 本函数占用的内存量。</li>
<li>flat%: 本函数内存占使用中内存总量的百分比。</li>
<li>sum%: 前面每一行flat百分比的和，比如第2行虽然的100% 是 100% + 0%。</li>
<li>cum: 是累计量，加入main函数调用了函数f，函数f占用的内存量，也会记进来。</li>
<li>cum%: 是累计量占总量的百分比。</li>
</ul>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>查看某个函数的代码，以及该函数每行代码的指标信息，如果函数名不明确，会进行模糊匹配，比如<code>list main</code>会列出<code>main.main</code>和<code>runtime.main</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list main.main  <span class="comment">// 精确列出函数</span></span><br><span class="line">Total: <span class="number">814.62</span>MB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:	&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">         .          .     <span class="number">22</span>:	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">         .          .     <span class="number">23</span>:	<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">         .          .     <span class="number">24</span>:	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB     <span class="number">25</span>:		buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">         .          .     <span class="number">26</span>:	&#125;</span><br><span class="line">         .          .     <span class="number">27</span>:&#125;</span><br><span class="line">         .          .     <span class="number">28</span>:</span><br><span class="line">(pprof) list main  <span class="comment">// 匹配所有函数名带main的函数</span></span><br><span class="line">Total: <span class="number">814.62</span>MB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:	&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">..... <span class="comment">// 省略几行</span></span><br><span class="line">         .          .     <span class="number">28</span>:</span><br><span class="line">ROUTINE ======================== runtime.main in /usr/lib/<span class="keyword">go</span><span class="number">-1.10</span>/src/runtime/proc.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .    <span class="number">193</span>:		<span class="comment">// A program compiled with -buildmode=c-archive or c-shared</span></span><br><span class="line">..... <span class="comment">// 省略几行</span></span><br></pre></td></tr></table></figure>

<p>可以看到在<code>main.main</code>中的第25行占用了814.62MB内存，左右2个数据分别是flat和cum，含义和top中解释的一样。</p>
<h4 id="traces"><a href="#traces" class="headerlink" title="traces"></a>traces</h4><p>打印所有调用栈，以及调用栈的指标信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(pprof) traces</span><br><span class="line">File: demo2</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">7</span>:<span class="number">08</span>pm (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">813.46</span>MB</span><br><span class="line">  <span class="number">813.46</span>MB   main.main</span><br><span class="line">             runtime.main</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">650.77</span>MB</span><br><span class="line">         <span class="number">0</span>   main.main</span><br><span class="line">             runtime.main</span><br><span class="line">....... <span class="comment">// 省略几十行</span></span><br></pre></td></tr></table></figure>

<p>每个<code>- - - - -</code> 隔开的是一个调用栈，能看到<code>runtime.main</code>调用了<code>main.main</code>，并且<code>main.main</code>中占用了813.46MB内存。</p>
<p>其他的profile操作和内存是类似的，这里就不展示了。</p>
<p>这里只是简单介绍本文用到的pprof的功能，pprof功能很强大，也经常和benchmark结合起来，但这不是本文的重点，所以就不多介绍了，为大家推荐几篇文章，一定要好好研读、实践：</p>
<ol>
<li>Go官方博客关于pprof的介绍，很详细，也包含样例，可以实操：<a target="_blank" rel="noopener" href="https://blog.golang.org/profiling-go-programs">Profiling Go Programs</a>。</li>
<li>跟煎鱼也讨论过pprof，煎鱼的这篇文章也很适合入门： <a target="_blank" rel="noopener" href="https://github.com/EDDYCJY/blog/blob/master/golang/2018-09-15-Golang%20%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%20PProf.md">Golang 大杀器之性能剖析 PProf</a>。</li>
</ol>
<hr>
<h1 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h1><p>内存泄露指的是程序运行过程中已不再使用的内存，没有被释放掉，导致这些内存无法被使用，直到程序结束这些内存才被释放的问题。</p>
<p>Go虽然有GC来回收不再使用的堆内存，减轻了开发人员对内存的管理负担，但这并不意味着Go程序不再有内存泄露问题。在Go程序中，如果没有Go语言的编程思维，也不遵守良好的编程实践，就可能埋下隐患，造成内存泄露问题。</p>
<h1 id="怎么发现内存泄露"><a href="#怎么发现内存泄露" class="headerlink" title="怎么发现内存泄露"></a>怎么发现内存泄露</h1><p>在Go中发现内存泄露有2种方法，一个是通用的监控工具，另一个是go pprof：</p>
<ol>
<li><strong>监控工具</strong>：固定周期对进程的内存占用情况进行采样，数据可视化后，根据内存占用走势（持续上升），很容易发现是否发生内存泄露。</li>
<li><strong>go pprof</strong>：适合没有监控工具的情况，使用Go提供的pprof工具判断是否发生内存泄露。</li>
</ol>
<p>这2种方式分别介绍一下。</p>
<h2 id="监控工具查看进程内在占用情况"><a href="#监控工具查看进程内在占用情况" class="headerlink" title="监控工具查看进程内在占用情况"></a>监控工具查看进程内在占用情况</h2><p><strong>如果使用云平台部署Go程序</strong>，云平台都提供了内存查看的工具，可以查看OS的内存占用情况和某个进程的内存占用情况，比如阿里云，我们在1个云主机上只部署了1个Go服务，所以OS的内存占用情况，基本是也反映了进程内存占用情况，OS内存占用情况如下，可以看到<strong>随着时间的推进，内存的占用率在不断的提高，这是内存泄露的最明显现象</strong>：</p>
<p><img src="https://lessisbetter.site/images/2019-05-image-20190512111200988-7630721.png" alt="image-20190512111200988"></p>
<p><strong>如果没有云平台这种内存监控工具，可以制作一个简单的内存记录工具。</strong></p>
<p>1、建立一个脚本<code>prog_mem.sh</code>，获取进程占用的物理内存情况，脚本内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">prog_name=<span class="string">&quot;your_programe_name&quot;</span></span><br><span class="line">prog_mem=$(pidstat  -r -u -h -C <span class="variable">$prog_name</span> |awk <span class="string">&#x27;NR==4&#123;print $12&#125;&#x27;</span>)</span><br><span class="line">time=$(date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$time</span><span class="string">&quot;\tmemory(Byte)\t&quot;</span><span class="variable">$prog_mem</span> &gt;&gt;~/record/prog_mem.log</span><br></pre></td></tr></table></figure>

<p>2、然后使用<code>crontab</code>建立定时任务，每分钟记录1次。使用<code>crontab -e</code>编辑crontab配置，在最后增加1行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * ~/record/prog_mem.sh</span><br></pre></td></tr></table></figure>

<p>脚本输出的内容保存在<code>prog_mem.log</code>，只要大体浏览一下就可以发现内存的增长情况，判断是否存在内存泄露。如果需要可视化，可以直接黏贴<code>prog_mem.log</code>内容到Excel等表格工具，绘制内存占用图。</p>
<p><img src="https://lessisbetter.site/images/2019-05-image-20190512172935195-7653375.png" alt="image-20190512172935195"></p>
<h2 id="go-pprof发现存在内存问题"><a href="#go-pprof发现存在内存问题" class="headerlink" title="go pprof发现存在内存问题"></a>go pprof发现存在内存问题</h2><blockquote>
<p>有情提醒：如果对pprof不了解，可以先看[go pprof基本知识](#go pprof基本知识)，这是下一节，看完再倒回来看。</p>
</blockquote>
<p>如果你Google或者百度，Go程序内存泄露的文章，它总会告诉你使用<strong>pprof heap</strong>，能够生成漂亮的调用路径图，火焰图等等，然后你根据调用路径就能定位内存泄露问题，我最初也是对此深信不疑，尝试了若干天后，只是发现内存泄露跟某种场景有关，根本找不到内存泄露的根源，<strong>如果哪位朋友用heap就能定位内存泄露的线上问题，麻烦介绍下</strong>。</p>
<p>后来读了Dave的<a target="_blank" rel="noopener" href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu">《High Performance Go Workshop》</a>，刷新了对heap的认识，内存pprof的简要内容如下：</p>
<p><img src="https://lessisbetter.site/images/2019-05-image-20190512114048868-7632448.png" alt="image-20190512114048868"></p>
<p>Dave讲了以下几点：</p>
<ol>
<li><strong>内存profiling记录的是堆内存分配的情况，以及调用栈信息</strong>，并不是进程完整的内存情况，猜测这也是在go pprof中称为heap而不是memory的原因。</li>
<li><strong>栈内存的分配是在调用栈结束后会被释放的内存，所以并不在内存profile中</strong>。</li>
<li>内存profiling是基于抽样的，默认是每1000次堆内存分配，执行1次profile记录。</li>
<li>因为内存profiling是基于抽样和它跟踪的是已分配的内存，而不是使用中的内存，（比如有些内存已经分配，看似使用，但实际以及不使用的内存，比如内存泄露的那部分），所以<strong>不能使用内存profiling衡量程序总体的内存使用情况</strong>。</li>
<li><strong>Dave个人观点：使用内存profiling不能够发现内存泄露</strong>。</li>
</ol>
<p>基于目前对heap的认知，我有2个观点：</p>
<ol>
<li><strong>heap能帮助我们发现内存问题，但不一定能发现内存泄露问题</strong>，这个看法与Dave是类似的。heap记录了内存分配的情况，我们能通过heap观察内存的变化，增长与减少，内存主要被哪些代码占用了，程序存在内存问题，这只能说明内存有使用不合理的地方，但并不能说明这是内存泄露。</li>
<li><strong>heap在帮助定位内存泄露原因上贡献的力量微乎其微</strong>。如第一条所言，能通过heap找到占用内存多的位置，但这个位置通常不一定是内存泄露，就算是内存泄露，也只是内存泄露的结果，并不是真正导致内存泄露的根源。</li>
</ol>
<p>接下来，我介绍怎么用heap发现问题，然后再解释为什么heap几乎不能定位内存泄露的根因。</p>
<h3 id="怎么用heap发现内存问题"><a href="#怎么用heap发现内存问题" class="headerlink" title="怎么用heap发现内存问题"></a>怎么用heap发现内存问题</h3><p>使用pprof的heap能够获取程序运行时的内存信息，在程序平稳运行的情况下，每个一段时间使用heap获取内存的profile，<strong>然后使用<code>base</code>能够对比两个profile文件的差别，就像<code>diff</code>命令一样显示出增加和减少的变化</strong>，使用一个简单的demo来说明heap和base的使用，依然使用demo2进行展示。</p>
<p><em>文件：<a target="_blank" rel="noopener" href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/heap/demo2.go">golang_step_by_step/pprof/heap/demo2.go</a></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示内存增长和pprof，并不是泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行一段时间：fatal error: runtime: out of memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">		buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面代码运行起来，执行以下命令获取profile文件，Ctrl-D退出，1分钟后再获取1次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://localhost:6060/debug/pprof/heap</span><br></pre></td></tr></table></figure>

<p>我已经获取到了两个profile文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz</span><br><span class="line">pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gz</span><br></pre></td></tr></table></figure>

<p>使用<code>base</code>把001文件作为基准，然后用002和001对比，先执行<code>top</code>看<code>top</code>的对比，然后执行<code>list main</code>列出<code>main</code>函数的内存对比，结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -base pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.002</span>.pb.gz</span><br><span class="line"></span><br><span class="line">File: demo2</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">14</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">33</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">970.34</span>MB, <span class="number">32.30</span>% of <span class="number">3003.99</span>MB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  <span class="number">970.34</span>MB <span class="number">32.30</span>% <span class="number">32.30</span>%   <span class="number">970.34</span>MB <span class="number">32.30</span>%  main.main   <span class="comment">// 看这</span></span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>% <span class="number">32.30</span>%   <span class="number">970.34</span>MB <span class="number">32.30</span>%  runtime.main</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) list main.main</span><br><span class="line">Total: <span class="number">2.93</span>GB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">970.34</span>MB   <span class="number">970.34</span>MB (flat, cum) <span class="number">32.30</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:	&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">         .          .     <span class="number">22</span>:	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">         .          .     <span class="number">23</span>:	<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">         .          .     <span class="number">24</span>:	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">  <span class="number">970.34</span>MB   <span class="number">970.34</span>MB     <span class="number">25</span>:		buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...) <span class="comment">// 看这</span></span><br><span class="line">         .          .     <span class="number">26</span>:	&#125;</span><br><span class="line">         .          .     <span class="number">27</span>:&#125;</span><br><span class="line">         .          .     <span class="number">28</span>:</span><br></pre></td></tr></table></figure>

<p><code>top</code>列出了<code>main.main</code>和<code>runtime.main</code>，<code>main.main</code>就是我们编写的main函数，<code>runtime.main</code>是runtime包中的main函数，也就是所有main函数的入口，这里不多介绍了，有兴趣可以看之前的调度器文章<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">《Go调度器系列（2）宏观看调度器》</a>。</p>
<p><code>top</code>显示<code>main.main</code> 第2次内存占用，比第1次内存占用多了970.34MB。</p>
<p><code>list main.main</code>告诉了我们增长的内存都在这一行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br></pre></td></tr></table></figure>

<p>001和002 profile的文件不进去看了，你本地测试下计算差值，绝对是刚才对比出的970.34MB。</p>
<h3 id="heap“不能”定位内存泄露"><a href="#heap“不能”定位内存泄露" class="headerlink" title="heap“不能”定位内存泄露"></a>heap“不能”定位内存泄露</h3><p>heap能显示内存的分配情况，以及哪行代码占用了多少内存，我们能轻易的找到占用内存最多的地方，如果这个地方的数值还在不断怎大，基本可以认定这里就是内存泄露的位置。</p>
<p>曾想按图索骥，从内存泄露的位置，根据调用栈向上查找，总能找到内存泄露的原因，这种方案看起来是不错的，但实施起来却找不到内存泄露的原因，结果是事半功倍。</p>
<p>原因在于一个Go程序，其中有大量的goroutine，这其中的调用关系也许有点复杂，也许内存泄露是在某个三方包里。举个栗子，比如下面这幅图，每个椭圆代表1个goroutine，其中的数字为编号，箭头代表调用关系。heap profile显示g111（最下方标红节点）这个协程的代码出现了泄露，任何一个从g101到g111的调用路径都可能造成了g111的内存泄露，有2类可能：</p>
<ol>
<li>该goroutine只调用了少数几次，但消耗了大量的内存，说明每个goroutine调用都消耗了不少内存，<strong>内存泄露的原因基本就在该协程内部</strong>。</li>
<li>该goroutine的调用次数非常多，虽然每个协程调用过程中消耗的内存不多，但该调用路径上，协程数量巨大，造成消耗大量的内存，并且这些goroutine由于某种原因无法退出，占用的内存不会释放，<strong>内存泄露的原因在到g111调用路径上某段代码实现有问题，造成创建了大量的g111</strong>。</li>
</ol>
<p><strong>第2种情况，就是goroutine泄露，这是通过heap无法发现的，所以heap在定位内存泄露这件事上，发挥的作用不大</strong>。</p>
<p><img src="https://lessisbetter.site/images/2019-05-image-20190512144150064-7643310.png" alt="image-20190512144150064"></p>
<hr>
<h1 id="goroutine泄露怎么导致内存泄露"><a href="#goroutine泄露怎么导致内存泄露" class="headerlink" title="goroutine泄露怎么导致内存泄露"></a>goroutine泄露怎么导致内存泄露</h1><h2 id="什么是goroutine泄露"><a href="#什么是goroutine泄露" class="headerlink" title="什么是goroutine泄露"></a>什么是goroutine泄露</h2><p>如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。</p>
<blockquote>
<p>提前思考：什么会导致goroutine无法退出/阻塞？</p>
</blockquote>
<h2 id="goroutine泄露怎么导致内存泄露-1"><a href="#goroutine泄露怎么导致内存泄露-1" class="headerlink" title="goroutine泄露怎么导致内存泄露"></a>goroutine泄露怎么导致内存泄露</h2><p>每个goroutine占用2KB内存，泄露1百万goroutine至少泄露<code>2KB * 1000000 = 2GB</code>内存，为什么说至少呢？</p>
<p>goroutine执行过程中还存在一些变量，如果这些变量指向堆内存中的内存，GC会认为这些内存仍在使用，不会对其进行回收，这些内存谁都无法使用，造成了内存泄露。</p>
<p>所以goroutine泄露有2种方式造成内存泄露：</p>
<ol>
<li>goroutine本身的栈所占用的空间造成内存泄露。</li>
<li>goroutine中的变量所占用的堆内存导致堆内存泄露，这一部分是能通过heap profile体现出来的。</li>
</ol>
<p>Dave在文章中也提到了，如果不知道何时停止一个goroutine，这个goroutine就是潜在的内存泄露：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#know_when_to_stop_a_goroutine">7.1.1 Know when to stop a goroutine</a></p>
<p>If you don’t know the answer, that’s a potential memory leak as the goroutine will pin its stack’s memory on the heap, as well as any heap allocated variables reachable from the stack.</p>
</blockquote>
<h2 id="怎么确定是goroutine泄露引发的内存泄露"><a href="#怎么确定是goroutine泄露引发的内存泄露" class="headerlink" title="怎么确定是goroutine泄露引发的内存泄露"></a>怎么确定是goroutine泄露引发的内存泄露</h2><p>掌握了前面的pprof命令行的基本用法，很快就可以确认是否是goroutine泄露导致内存泄露，如果你不记得了，马上回去看一下[go pprof基本知识](#go pprof基本知识)。</p>
<p><strong>判断依据：在节点正常运行的情况下，隔一段时间获取goroutine的数量，如果后面获取的那次，某些goroutine比前一次多，如果多获取几次，是持续增长的，就极有可能是goroutine泄露</strong>。</p>
<p>goroutine导致内存泄露的demo：</p>
<p><em>文件：<a target="_blank" rel="noopener" href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/goroutine/leak_demo1.go">golang_step_by_step/pprof/goroutine/leak_demo1.go</a></em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutine泄露导致内存泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 开启pprof</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">			os.Exit(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">// 死代码，永不读取</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">			&lt;-outCh</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每s起100个goroutine，goroutine会阻塞，不释放内存</span></span><br><span class="line">	tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">		i++</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		alloc1(outCh)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc1</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> alloc2(outCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc2</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;alloc-fm exit&quot;</span>)</span><br><span class="line">		<span class="comment">// 分配内存，假用一下</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">		_ = <span class="built_in">len</span>(buf)</span><br><span class="line">		fmt.Println(<span class="string">&quot;alloc done&quot;</span>)</span><br><span class="line"></span><br><span class="line">		outCh &lt;- <span class="number">0</span> <span class="comment">// 53行</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译并运行以上代码，然后使用<code>go tool pprof</code>获取gorourine的profile文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http:&#x2F;&#x2F;localhost:6060&#x2F;debug&#x2F;pprof&#x2F;goroutine</span><br></pre></td></tr></table></figure>

<p>已经通过pprof命令获取了2个goroutine的profile文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">/home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz</span><br><span class="line">/home/ubuntu/pprof/pprof.leak_demo.goroutine.002.pb.gz</span><br></pre></td></tr></table></figure>

<p>同heap一样，我们可以使用<code>base</code>对比2个goroutine profile文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> tool pprof -base pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line"></span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">20312</span>, <span class="number">100</span>% of <span class="number">20312</span> total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">20312</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>

<p>可以看到运行到<code>runtime.gopark</code>的goroutine数量增加了20312个。再通过002文件，看一眼执行到<code>gopark</code>的goroutine数量，即挂起的goroutine数量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">47</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">24330</span>, <span class="number">100</span>% of <span class="number">24331</span> total</span><br><span class="line">Dropped <span class="number">32</span> nodes (cum &lt;= <span class="number">121</span>)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">24330</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">24330</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24327</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br></pre></td></tr></table></figure>

<p>显示有24330个goroutine被挂起，这不是goroutine泄露这是啥？已经能确定八九成goroutine泄露了。</p>
<p>是什么导致如此多的goroutine被挂起而无法退出？接下来就看怎么定位goroutine泄露。</p>
<hr>
<h1 id="定位goroutine泄露的2种方法"><a href="#定位goroutine泄露的2种方法" class="headerlink" title="定位goroutine泄露的2种方法"></a>定位goroutine泄露的2种方法</h1><p>使用pprof有2种方式，一种是web网页，一种是<code>go tool pprof</code>命令行交互，这两种方法查看goroutine都支持，但有轻微不同，也有各自的优缺点。</p>
<p>我们先看Web的方式，再看命令行交互的方式，这两种都很好使用，结合起来用也不错。</p>
<h2 id="Web可视化查看"><a href="#Web可视化查看" class="headerlink" title="Web可视化查看"></a>Web可视化查看</h2><p>Web方式适合web服务器的端口能访问的情况，使用起来方便，有2种方式：</p>
<ol>
<li><strong>查看某条调用路径上，当前阻塞在此goroutine的数量</strong></li>
<li>查看所有goroutine的运行栈（调用路径），可以<strong>显示阻塞在此的时间</strong></li>
</ol>
<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>url请求中设置debug=1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:port&#x2F;debug&#x2F;pprof&#x2F;goroutine?debug&#x3D;1</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://lessisbetter.site/images/2019-05-image-20190516143740567-7988660.png"></p>
<p>看起来密密麻麻的，其实简单又十分有用，看上图标出来的部分，手机上图看起来可能不方便，那就放大图片，或直接看下面各字段的含义：</p>
<ol>
<li><code>goroutine profile: total 32023</code>：32023是<strong>goroutine的总数量</strong>，</li>
<li><code>32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 ...</code>：32015代表当前有32015个goroutine运行这个调用栈，并且停在相同位置，@后面的十六进制，现在用不到这个数据，所以暂不深究了。</li>
<li>下面是当前goroutine的<strong>调用栈</strong>，列出了<strong>函数和所在文件的行数，这个行数对定位很有帮助</strong>，如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 0x6d8559 0x6d831b 0x45abe1</span><br><span class="line">#	0x6d8558	main.alloc2.func1+0xf8	&#x2F;home&#x2F;ubuntu&#x2F;heap&#x2F;leak_demo.go:53</span><br><span class="line">#	0x6d831a	main.alloc2+0x2a	&#x2F;home&#x2F;ubuntu&#x2F;heap&#x2F;leak_demo.go:54</span><br></pre></td></tr></table></figure>

<p>根据上面的提示，就能判断32015个goroutine运行到<code>leak_demo.go</code>的53行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc2</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;alloc-fm exit&quot;</span>)</span><br><span class="line">		<span class="comment">// 分配内存，假用一下</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">		_ = <span class="built_in">len</span>(buf)</span><br><span class="line">		fmt.Println(<span class="string">&quot;alloc done&quot;</span>)</span><br><span class="line"></span><br><span class="line">		outCh &lt;- <span class="number">0</span> <span class="comment">// 53行</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阻塞的原因是outCh这个写操作无法完成，outCh是无缓冲的通道，并且由于以下代码是死代码，所以goroutine始终没有从outCh读数据，造成outCh阻塞，进而造成无数个alloc2的goroutine阻塞，形成内存泄露：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">    &lt;-outCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>url请求中设置debug=2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:port&#x2F;debug&#x2F;pprof&#x2F;goroutine?debug&#x3D;2</span><br></pre></td></tr></table></figure>

<p><img src="https://lessisbetter.site/images/2019-05-image-20190516143537339-7988537.png"></p>
<p>第2种方式和第1种方式是互补的，它可以看到每个goroutine的信息：</p>
<ol>
<li><code>goroutine 20 [chan send, 2 minutes]</code>：20是goroutine id，<code>[]</code>中是当前goroutine的状态，阻塞在写channel，并且阻塞了2分钟，长时间运行的系统，你能看到阻塞时间更长的情况。</li>
<li>同时，也可以看到调用栈，看当前执行停到哪了：<code>leak_demo.go</code>的53行，</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goroutine <span class="number">20</span> [<span class="keyword">chan</span> send, <span class="number">2</span> minutes]:</span><br><span class="line">main.alloc2.func1(<span class="number">0xc42015e060</span>)</span><br><span class="line">	/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">53</span> +<span class="number">0xf9</span>  <span class="comment">// 这</span></span><br><span class="line">main.alloc2(<span class="number">0xc42015e060</span>)</span><br><span class="line">	/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">54</span> +<span class="number">0x2b</span></span><br><span class="line">created by main.alloc1</span><br><span class="line">	/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">42</span> +<span class="number">0x3f</span></span><br></pre></td></tr></table></figure>



<h2 id="命令行交互式方法"><a href="#命令行交互式方法" class="headerlink" title="命令行交互式方法"></a>命令行交互式方法</h2><p>Web的方法是简单粗暴，无需登录服务器，浏览器打开看看就行了。但就像前面提的，没有浏览器可访问时，命令行交互式才是最佳的方式，并且也是手到擒来，感觉比Web一样方便。</p>
<p>命令行交互式只有1种获取goroutine profile的方法，不像Web网页分<code>debug=1</code>和<code>debug=2</code>2中方式，并将profile文件保存到本地：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意命令没有`debug=1`，debug=1，加debug有些版本的go不支持</span></span><br><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//0.0.0.0:6060/debug/pprof/goroutine</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6061/debug/pprof/goroutine</span></span><br><span class="line">Saved profile in /home/ubuntu/pprof/pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz  <span class="comment">// profile文件保存位置</span></span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure>
<p>命令行只需要掌握3个命令就好了，上面介绍过了，详细的倒回去看<a href="#top">top</a>, <a href="#list">list</a>, <a href="#traces">traces</a>：</p>
<ol>
<li><strong>top</strong>：显示正运行到某个函数goroutine的数量</li>
<li><strong>traces</strong>：显示所有goroutine的调用栈</li>
<li><strong>list</strong>：列出代码详细的信息。</li>
</ol>
<p>我们依然使用<code>leak_demo.go</code>这个demo，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="keyword">go</span> tool pprof -base pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">20312</span>, <span class="number">100</span>% of <span class="number">20312</span> total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">20312</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) traces</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     <span class="number">20312</span>   runtime.gopark</span><br><span class="line">             runtime.goparkunlock</span><br><span class="line">             runtime.chansend</span><br><span class="line">             runtime.chansend1 <span class="comment">// channel发送</span></span><br><span class="line">             main.alloc2.func1 <span class="comment">// alloc2中的匿名函数</span></span><br><span class="line">             main.alloc2</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>top命令在<a href="#%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E6%98%AFgoroutine%E6%B3%84%E9%9C%B2%E5%BC%95%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">怎么确定是goroutine泄露引发的内存泄露</a>介绍过了，直接看traces命令，traces能列出002中比001中多的那些goroutine的调用栈，这里只有1个调用栈，有20312个goroutine都执行这个调用路径，可以看到alloc2中的匿名函数<code>alloc2.func1</code>调用了写channel的操作，然后阻塞挂起了goroutine，使用list列出<code>alloc2.func1</code>的代码，显示有20312个goroutine阻塞在53行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list main.alloc2.func1</span><br><span class="line">Total: <span class="number">20312</span></span><br><span class="line">ROUTINE ======================== main.alloc2.func1 in /home/ubuntu/heap/leak_demo.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>      <span class="number">20312</span> (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">48</span>:		<span class="comment">// 分配内存，假用一下</span></span><br><span class="line">         .          .     <span class="number">49</span>:		buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">         .          .     <span class="number">50</span>:		_ = <span class="built_in">len</span>(buf)</span><br><span class="line">         .          .     <span class="number">51</span>:		fmt.Println(<span class="string">&quot;alloc done&quot;</span>)</span><br><span class="line">         .          .     <span class="number">52</span>:</span><br><span class="line">         .      <span class="number">20312</span>     <span class="number">53</span>:		outCh &lt;- <span class="number">0</span>  <span class="comment">// 看这</span></span><br><span class="line">         .          .     <span class="number">54</span>:	&#125;()</span><br><span class="line">         .          .     <span class="number">55</span>:&#125;</span><br><span class="line">         .          .     <span class="number">56</span>:</span><br></pre></td></tr></table></figure>

<p><strong>友情提醒：使用list命令的前提是程序的源码在当前机器，不然可没法列出源码。</strong>服务器上，通常没有源码，那我们咋办呢？刚才介绍了Web查看的方式，那里会列出代码行数，我们可以使用<code>wget</code>下载网页：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://localhost:6060/debug/pprof/goroutine?debug=1</span><br></pre></td></tr></table></figure>

<p>下载网页后，使用编辑器打开文件，使用关键字<code>main.alloc2.func1</code>进行搜索，找到与当前相同的调用栈，就可以看到该goroutine阻塞在哪一行了，不要忘记使用<code>debug=2</code>还可以看到阻塞了多久和原因，Web方式中已经介绍了，此处省略代码几十行。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文章略长，但全是干货，感谢阅读到这。然读到着了，跟定很想掌握pprof，建议实践一把，现在和大家温习一把本文的主要内容。</p>
<h2 id="goroutine泄露的本质"><a href="#goroutine泄露的本质" class="headerlink" title="goroutine泄露的本质"></a>goroutine泄露的本质</h2><p>goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p>
<h2 id="goroutine泄露的发现和定位"><a href="#goroutine泄露的发现和定位" class="headerlink" title="goroutine泄露的发现和定位"></a>goroutine泄露的发现和定位</h2><p>利用好go pprof获取goroutine profile文件，然后利用3个命令top、traces、list定位内存泄露的原因。</p>
<h2 id="goroutine泄露的场景"><a href="#goroutine泄露的场景" class="headerlink" title="goroutine泄露的场景"></a>goroutine泄露的场景</h2><p>泄露的场景不仅限于以下两类，但因channel相关的泄露是最多的。</p>
<ol>
<li>channel的读或者写：<ol>
<li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li>
<li>有缓冲的channel因为缓冲区满了，写操作阻塞</li>
<li>期待从channel读数据，结果没有goroutine写</li>
</ol>
</li>
<li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。</li>
</ol>
<h2 id="编码goroutine泄露的建议"><a href="#编码goroutine泄露的建议" class="headerlink" title="编码goroutine泄露的建议"></a>编码goroutine泄露的建议</h2><p>为避免goroutine泄露造成内存泄露，启动goroutine前要思考清楚：</p>
<ol>
<li>goroutine如何退出？</li>
<li>是否会有阻塞造成无法退出？如果有，那么这个路径是否会创建大量的goroutine？</li>
</ol>
<h1 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h1><p><strong>本文所有示例源码，及历史文章、代码都存储在Github，阅读原文可直接跳转</strong>，Github：<a target="_blank" rel="noopener" href="https://github.com/Shitaibin/golang_step_by_step/tree/master/pprof">https://github.com/Shitaibin/golang_step_by_step/tree/master/pprof</a> 。</p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>这些既是参考资料也是推荐阅读的文章，不容错过。</p>
<p>【Go Blog关于pprof详细介绍和Demo】 <a target="_blank" rel="noopener" href="https://blog.golang.org/profiling-go-programs">https://blog.golang.org/profiling-go-programs</a></p>
<p>【Dave关于高性能Go程序的workshop】 <a target="_blank" rel="noopener" href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu">https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu</a></p>
<p>【煎鱼pprof文章，很适合入门 Golang大杀器之性能剖析PProf】 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016412013">https://segmentfault.com/a/1190000016412013</a></p>
<p>【SO上goroutine调用栈各字段的介绍】<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/38414527/4296218">https://stackoverflow.com/a/38414527/4296218</a></p>
<p>【我的老文，有runtime.main的介绍，想学习调度器，可以看下系列文章 Go调度器系列（2）宏观看调度器】<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a></p>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/05/18/go-goroutine-leak/">http://lessisbetter.site/2019/05/18/go-goroutine-leak/</a></li>
</ol>
</blockquote>
<div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div>
<img src="https://lessisbetter.site/images/2019-01-article_qrcode.jpg" style="border:0"  align=center />
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/05/03/go-concurrent-problems1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/03/go-concurrent-problems1/" class="post-title-link" itemprop="url">Go面试题：并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-03 09:23:17" itemprop="dateCreated datePublished" datetime="2019-05-03T09:23:17+08:00">2019-05-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>这个once的实现有没有什么问题？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">	m    sync.Mutex</span><br><span class="line">	done <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		o.done = <span class="number">1</span></span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有。讨论见这里：<a target="_blank" rel="noopener" href="https://github.com/smallnest/gitalk/issues/101#issuecomment-490738912">https://github.com/smallnest/gitalk/issues/101#issuecomment-490738912</a></p>
<p>正确的姿势是使用原子操作，原子操作在修改变量的值后，会也让其他核立马看到数据的变动。Once.Do的官方实现就使用的原子操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.LoadUint32(&amp;o.done) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow-path.</span></span><br><span class="line">	o.m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> o.m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> o.done == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> atomic.StoreUint32(&amp;o.done, <span class="number">1</span>)</span><br><span class="line">		f()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于缓存，可以看鸟窝的<a target="_blank" rel="noopener" href="https://colobu.com/2019/01/24/cacheline-affects-performance-in-go/">《cacheline 对 Go 程序的影响》</a>和知乎<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31875174">《细说Cache-L1/L2/L3/TLB》</a>。</p>
<h3 id="Wait-Group"><a href="#Wait-Group" class="headerlink" title="Wait Group"></a>Wait Group</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Millisecond)</span><br><span class="line">		wg.Done()</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会panic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: sync: WaitGroup is reused before previous Wait has returned</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">sync.(*WaitGroup).Wait(0xc000018090)</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;src&#x2F;sync&#x2F;waitgroup.go:132 +0xae</span><br><span class="line">main.main()</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;problems&#x2F;concurrent&#x2F;waitgroup0.go:16 +0x79</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>原因：第13行执行<code>wg.Done()</code>后，wg的计数已经变成了0，<code>wg.Wait()</code>实际以及完成并返回，14行再次使用此<code>wg.Add()</code>报错。</p>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	count <span class="keyword">int</span></span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mu MyMutex</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">var</span> mu2 = mu</span><br><span class="line">	mu.count++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	mu2.Lock()</span><br><span class="line">	mu2.count++</span><br><span class="line">	mu2.Unlock()</span><br><span class="line">	fmt.Println(mu.count, mu2.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果panic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [semacquire]:</span><br><span class="line">sync.runtime_SemacquireMutex(0xc0000180ac, 0x100ae00)</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;src&#x2F;runtime&#x2F;sema.go:71 +0x3d</span><br><span class="line">sync.(*Mutex).Lock(0xc0000180a8)</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;go&#x2F;src&#x2F;github.com&#x2F;golang&#x2F;go&#x2F;src&#x2F;sync&#x2F;mutex.go:134 +0x109</span><br><span class="line">main.main()</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;problems&#x2F;concurrent&#x2F;mutex0.go:19 +0xb4</span><br></pre></td></tr></table></figure>

<p>原因：<code>MyMutex</code>和<code>sync.Mutex</code>都是结构体，不包含指针，第16行根据mu新建了mu2对象，2者占用不同的内存区域，但2者的“内容”是相同的，所以mu2新建后就已经是Lock状态。第19行<code>mu2.Lock()</code>所以会死锁。</p>
<p>修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">gopackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	count <span class="keyword">int</span></span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mu MyMutex</span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">var</span> mu2 = mu</span><br><span class="line">	mu.count++</span><br><span class="line">	mu.Unlock()</span><br><span class="line">	mu2.Unlock() <span class="comment">// 先解锁，或新建mu2时移动到mu.Lock之前</span></span><br><span class="line">	mu2.Lock()</span><br><span class="line">	mu2.count++</span><br><span class="line">	mu2.Unlock()</span><br><span class="line">	fmt.Println(mu.count, mu2.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool = sync.Pool&#123;New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			processRequest(<span class="number">1</span> &lt;&lt; <span class="number">28</span>) <span class="comment">// 256MiB</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				processRequest(<span class="number">1</span> &lt;&lt; <span class="number">10</span>) <span class="comment">// 1KiB</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> stats runtime.MemStats</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">		runtime.ReadMemStats(&amp;stats)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Cycle %d: %d MB\n&quot;</span>, i, stats.Alloc/<span class="number">1024</span>/<span class="number">1024</span>)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		runtime.GC()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processRequest</span><span class="params">(size <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	b := pool.Get().(*bytes.Buffer)</span><br><span class="line">	time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">	b.Grow(size)</span><br><span class="line">	pool.Put(b)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以编译，运行时内存先暴涨，但是过一会会回收掉。结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Cycle 0: 0 MB</span><br><span class="line">Cycle 1: 256 MB</span><br><span class="line">Cycle 2: 513 MB</span><br><span class="line">Cycle 3: 769 MB</span><br><span class="line">Cycle 4: 1281 MB</span><br><span class="line">Cycle 5: 1281 MB</span><br><span class="line">Cycle 6: 1281 MB</span><br><span class="line">Cycle 7: 1537 MB</span><br><span class="line">Cycle 8: 1793 MB</span><br><span class="line">Cycle 9: 2049 MB</span><br><span class="line">Cycle 10: 2049 MB</span><br><span class="line">......</span><br><span class="line">Cycle 107: 14593 MB</span><br><span class="line">Cycle 108: 15105 MB</span><br><span class="line">Cycle 109: 2304 MB</span><br><span class="line">Cycle 110: 0 MB</span><br><span class="line">Cycle 111: 256 MB</span><br><span class="line">Cycle 112: 513 MB</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>sync.Pool</code>用来存放经常使用的临时对象，如果每次这些内存被GC回收，会加大GC的压力，Pool的出现就是为<strong>减缓</strong>GC的压力，而不是完全不让GC回收Pool的内存。</p>
<p>关于Pool不可错过Dave在<a target="_blank" rel="noopener" href="https://dave.cheney.net/high-performance-go-workshop/gopherchina-2019.html#using_sync_pool">高性能Go程序的这段介绍</a>。</p>
<h3 id="channel-1"><a href="#channel-1" class="headerlink" title="channel 1"></a>channel 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// g1</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">//g2</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		&lt;-ch</span><br><span class="line">	&#125;(ch)</span><br><span class="line">	c := time.Tick(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;#goroutines: %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是持续打印<code>#goroutines: 2</code>。<code>ch</code>声明后为<code>nil</code>，在g1中被初始化为缓冲区大小为1的通道，g1向ch写数据后退出；通过参数把ch传递给g2时，ch还是<code>nil</code>，所以在g2内部ch为nil，从nil的通道读数据会阻塞，所以g2无法退出；另外Main协程不会退出，会持续遍历通道<code>c</code>，感谢<a target="_blank" rel="noopener" href="https://github.com/Bububuger">Bububuger</a>提醒，定时器的通道并不统计在<code>NumGoroutine</code>中，所以会打印存在2个goroutine。</p>
<h3 id="channel-2"><a href="#channel-2" class="headerlink" title="channel 2"></a>channel 2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-ch</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ch只声明，未进行初始化，所以panic：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: close of nil channel</span><br><span class="line"></span><br><span class="line">goroutine 34 [running]:</span><br><span class="line">main.main.func2(0xc000096000, 0x0)</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;problems&#x2F;concurrent&#x2F;channel1.go:13 +0x33</span><br><span class="line">created by main.main</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;problems&#x2F;concurrent&#x2F;channel1.go:11 +0x87</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>修改为下面这样，还有问题吗？：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// var ch chan int</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-ch</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样会panic，典型的channel由非发送者关闭，造成在关闭的channel上写数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">panic: send on closed channel</span><br><span class="line"></span><br><span class="line">goroutine 4 [running]:</span><br><span class="line">main.main.func1(0xc000070060)</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;problems&#x2F;concurrent&#x2F;channel1.go:10 +0x37</span><br><span class="line">created by main.main</span><br><span class="line">	&#x2F;Users&#x2F;shitaibin&#x2F;Workspace&#x2F;golang_step_by_step&#x2F;problems&#x2F;concurrent&#x2F;channel1.go:9 +0x80</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map 1"></a>Map 1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Map</span><br><span class="line">	m.LoadOrStore(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	m.Delete(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	fmt.Println(m.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无法编译，因为Map没有Len()方法。</p>
<h3 id="Map-2"><a href="#Map-2" class="headerlink" title="Map 2"></a>Map 2</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line">	sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.Unlock()</span><br><span class="line">	i, ok := m.m[key]</span><br><span class="line">	<span class="keyword">return</span> i, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Put</span><span class="params">(key, value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.Unlock()</span><br><span class="line">	m.m[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(m.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	m := Map&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++ &#123;</span><br><span class="line">			m.Put(i, i)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++ &#123;</span><br><span class="line">			m.Len()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能正常编译和运行。map不是协程安全的，需要锁的保护，但Len()的实现并没有加锁，当map写数据时，并且调用Len读长度，则存在map的并发读写问题，因为不是同时读写map所存的内容，所以可以编译和运行，但存在读取的map内存长度不准确问题。map定义和len的声明如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">	count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="keyword">uint8</span></span><br><span class="line">	B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The len built-in function returns the length of v, according to its type:</span></span><br><span class="line"><span class="comment">//	Array: the number of elements in v.</span></span><br><span class="line"><span class="comment">//	Pointer to array: the number of elements in *v (even if v is nil).</span></span><br><span class="line"><span class="comment">//	Slice, or map: the number of elements in v; if v is nil, len(v) is zero.</span></span><br><span class="line"><span class="comment">//	String: the number of bytes in v.</span></span><br><span class="line"><span class="comment">//	Channel: the number of elements queued (unread) in the channel buffer;</span></span><br><span class="line"><span class="comment">//	if v is nil, len(v) is zero.</span></span><br><span class="line"><span class="comment">// For some arguments, such as a string literal or a simple array expression, the</span></span><br><span class="line"><span class="comment">// result can be a constant. See the Go language specification&#x27;s &quot;Length and</span></span><br><span class="line"><span class="comment">// capacity&quot; section for details.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">len</span><span class="params">(v Type)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">var</span> ints = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1000</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">			ints = <span class="built_in">append</span>(ints, i)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">			ints = <span class="built_in">append</span>(ints, i)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(ints))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，slice不是协程安全的，自身也又没锁的保护，多协程访问存在并发问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，append中有可能还会分配新的内存空间，切片可能指向了新的内存区域：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The append built-in function appends elements to the end of a slice. If</span></span><br><span class="line"><span class="comment">// it has sufficient capacity, the destination is resliced to accommodate the</span></span><br><span class="line"><span class="comment">// new elements. If it does not, a new underlying array will be allocated.</span></span><br><span class="line"><span class="comment">// Append returns the updated slice. It is therefore necessary to store the</span></span><br><span class="line"><span class="comment">// result of append, often in the variable holding the slice itself:</span></span><br><span class="line"><span class="comment">//	slice = append(slice, elem1, elem2)</span></span><br><span class="line"><span class="comment">//	slice = append(slice, anotherSlice...)</span></span><br><span class="line"><span class="comment">// As a special case, it is legal to append a string to a byte slice, like this:</span></span><br><span class="line"><span class="comment">//	slice = append([]byte(&quot;hello &quot;), &quot;world&quot;...)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(slice []Type, elems ...Type)</span> []<span class="title">Type</span></span></span><br></pre></td></tr></table></figure>

<p>所以，两个协程同时写，是不安全的，并且大概率可能存在数据丢失，所以结果可能不是2000。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a target="_blank" rel="noopener" href="https://github.com/Shitaibin/golang_step_by_step/tree/master/problems">golang_step_by_step</a></p>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/05/03/go-concurrent-problems1/">http://lessisbetter.site/2019/05/03/go-concurrent-problems1/</a></li>
</ol>
</blockquote>
<div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div>
<img src="https://lessisbetter.site/images/2019-01-article_qrcode.jpg" style="border:0"  align=center />
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/04/26/ethereum-keys-transform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/26/ethereum-keys-transform/" class="post-title-link" itemprop="url">以太坊密钥转换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-26 10:04:00" itemprop="dateCreated datePublished" datetime="2019-04-26T10:04:00+08:00">2019-04-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>以太坊的每一个账号私钥都通过密码加密存放到一个keystore文件中，如果创建一个账户涉及：</p>
<ol>
<li>生成ECDSA密钥</li>
<li>使用密码</li>
<li>将加密信息生成json格式，等待写入到keystore文件</li>
<li>创建keystore文件</li>
<li>将信息写入到keystore文件</li>
</ol>
<p>经过测试，这一个过程需要耗时大约5s，也就是每创建一个账户都要耗时5s，如果要创建1万个测试账号，需要5万秒，需要将近14小时，需要进行并发，才能尽量减少时间浪费，但是，使用5s才生成1个账号，还是太浪费了。</p>
<p>读取1个keystore文件涉及：</p>
<ol>
<li>读keystore文件</li>
<li>对数据进行解密，将账号保存到内存</li>
</ol>
<p>经过测试，这个过程需要耗时大约3s，1万个账号顺序读取需要大约8小时。</p>
<p><strong>能不能并发读取？</strong><br>不能。读取keystore时，指定的是keystore文件所在的目录，它会读取所有的keystore文件，在内存中保存到1个<code>Keystore</code>对象中。</p>
<p>如果我们写一个测试程序，以太坊账号的管理，简直是一个噩梦。</p>
<p><strong>有没有其他办法，能够加快账号的读取，交易的签名等？</strong></p>
<p><strong>交易的签名本质</strong>是使用go的<code>ecdsa.PrivateKey</code>，没有以太坊这些账户加密和解密操作，这些操作是上述测试耗时的原因，直接使用<code>ecdsa.PrivateKey</code>，使用后保存到文件，使用时从文件读取，可以从若干小时，降低到不到1s。</p>
<p>我们使用<code>ecdsa.PrivateKey</code>的思路：</p>
<ol>
<li>使用<code>ecdsa.GenerateKey()</code>生成私钥</li>
<li>私钥能转为16进制字符串，把字符串保存到文本文件，每一行都是1个私钥的16进制</li>
<li>使用时从文件读取每一个账号的16进制字符串，然后转换成所有的私钥</li>
</ol>
<p><strong>16进制字符串和<code>ecdsa.PrivateKey</code>相互转换是非常简单的</strong>，<code>ecdsa.Private</code>和以太坊的账号转换，则是非常乱的，整理出来了一幅图，没这幅图，每次看都要梳理一段时间，浪费生命。</p>
<p><img src="https://lessisbetter.site/images/2019-04-eth-keys-transform.png"></p>
<p>图注：</p>
<ol>
<li><code>keystore</code>代表包名，<code>Keystore</code>代表类型</li>
<li>以<code>()</code>为函数，否则为类型</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/04/14/golang-scheduler-4-explore-source-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/14/golang-scheduler-4-explore-source-code/" class="post-title-link" itemprop="url">Go调度器系列（4）源码阅读与探索</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-14 15:38:59" itemprop="dateCreated datePublished" datetime="2019-04-14T15:38:59+08:00">2019-04-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>各位朋友，这次想跟大家分享一下Go调度器源码阅读相关的知识和经验，网络上已经有很多剖析源码的好文章，所以这篇文章<strong>不是又一篇源码剖析文章，注重的不是源码分析分享，而是带给大家一些学习经验，希望大家能更好的阅读和掌握Go调度器的实现</strong>。</p>
<p>本文主要分2个部分：</p>
<ol>
<li><strong>解决如何阅读源码的问题</strong>。阅读源码本质是把脑海里已经有的调度设计，看看到底是不是这么实现的，是怎么实现的。</li>
<li><strong>带给你一个探索Go调度器实现的办法</strong>。源码都到手了，你可以修改、<strong>窥探</strong>，通过这种方式解决阅读源码过程中的疑问，验证一些想法。比如：负责调度的是g0，怎么才能<code>schedule()</code>在执行时，当前是g0呢？</li>
</ol>
<h2 id="如何阅读源码"><a href="#如何阅读源码" class="headerlink" title="如何阅读源码"></a>如何阅读源码</h2><h3 id="阅读前提"><a href="#阅读前提" class="headerlink" title="阅读前提"></a>阅读前提</h3><p>阅读Go源码前，最好已经掌握Go调度器的设计和原理，如果你还无法回答以下问题：</p>
<ol>
<li>为什么需要Go调度器？</li>
<li>Go调度器与系统调度器有什么区别和关系/联系？</li>
<li>G、P、M是什么，三者的关系是什么？</li>
<li>P有默认几个？</li>
<li>M同时能绑定几个P？</li>
<li>M怎么获得G？</li>
<li>M没有G怎么办？</li>
<li>为什么需要全局G队列？</li>
<li>Go调度器中的负载均衡的2种方式是什么？</li>
<li>work stealing是什么？什么原理？</li>
<li>系统调用对G、P、M有什么影响？</li>
<li>Go调度器抢占是什么样的？一定能抢占成功吗？</li>
</ol>
<p>建议阅读Go调度器系列文章，以及文章中的参考资料：</p>
<ol>
<li><a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">Go调度器系列（1）起源</a></li>
<li><a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">Go调度器系列（2）宏观看调度器</a></li>
<li><a href="http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/">Go调度器系列（3）图解调度原理</a></li>
</ol>
<h3 id="优秀源码资料推荐"><a href="#优秀源码资料推荐" class="headerlink" title="优秀源码资料推荐"></a>优秀源码资料推荐</h3><p>既然你已经能回答以上问题，说明你对Go调度器的设计已经有了一定的掌握，关于Go调度器源码的优秀资料已经有很多，我这里推荐2个：</p>
<ol>
<li><strong>雨痕的Go源码剖析</strong>六章并发调度，不止是源码，是以源码为基础进行了详细的Go调度器介绍：<a target="_blank" rel="noopener" href="https://github.com/qyuhen/book">https://github.com/qyuhen/book</a></li>
<li><strong>Go夜读</strong>第12期，golang中goroutine的调度，M、P、G各自的一生状态，以及转换关系：<a target="_blank" rel="noopener" href="https://reading.developerlearning.cn/reading/12-2018-08-02-goroutine-gpm/">https://reading.developerlearning.cn/reading/12-2018-08-02-goroutine-gpm/</a></li>
</ol>
<p>Go调度器的源码还涉及GC等，阅读源码时，可以暂时先跳过，主抓调度的逻辑。</p>
<p>另外，Go调度器涉及汇编，也许你不懂汇编，不用担心，雨痕的文章对汇编部分有进行解释。</p>
<p>最后，送大家一幅流程图，画出了主要的调度流程，大家也可边阅读边画，增加理解，<strong>高清版可到博客下载（原图原文跳转）</strong>。</p>
<p><img src="https://lessisbetter.site/images/2019-04-shcedule-flow.png"></p>
<h2 id="如何探索调度器"><a href="#如何探索调度器" class="headerlink" title="如何探索调度器"></a>如何探索调度器</h2><p>这部分教你探索Go调度器的源码，验证想法，主要思想就是，下载Go的源码，添加调试打印，编译修改的源文件，生成修改的go，然后使用修改go运行测试代码，观察结果。</p>
<h3 id="下载和编译Go"><a href="#下载和编译Go" class="headerlink" title="下载和编译Go"></a>下载和编译Go</h3><ol>
<li><p>Github下载，并且换到go1.11.2分支，本文所有代码修改都基于go1.11.2版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ GODIR=<span class="variable">$GOPATH</span>/src/github.com/golang/go</span><br><span class="line">$ mkdir -p <span class="variable">$GODIR</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GODIR</span>/..</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/golang/go.git</span><br><span class="line">$ <span class="built_in">cd</span> go</span><br><span class="line">$ git fetch origin go1.11.2</span><br><span class="line">$ git checkout origin/go1.11.2</span><br><span class="line">$ git checkout -b go1.11.2</span><br><span class="line">$ git checkout go1.11.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>初次编译，会跑测试，耗时长一点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GODIR</span>/src</span><br><span class="line">$ ./all.bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>以后每次修改go源码后可以这样，4分钟左右可以编译完成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span>  <span class="variable">$GODIR</span>/src</span><br><span class="line">$ time ./make.bash</span><br><span class="line">Building Go cmd/dist using /usr/<span class="built_in">local</span>/go.</span><br><span class="line">Building Go toolchain1 using /usr/<span class="built_in">local</span>/go.</span><br><span class="line">Building Go bootstrap cmd/go (go_bootstrap) using Go toolchain1.</span><br><span class="line">Building Go toolchain2 using go_bootstrap and Go toolchain1.</span><br><span class="line">Building Go toolchain3 using go_bootstrap and Go toolchain2.</span><br><span class="line">Building packages and commands <span class="keyword">for</span> linux/amd64.</span><br><span class="line">---</span><br><span class="line">Installed Go <span class="keyword">for</span> linux/amd64 <span class="keyword">in</span> /home/xxx/go/src/github.com/golang/go</span><br><span class="line">Installed commands <span class="keyword">in</span> /home/xxx/go/src/github.com/golang/go/bin</span><br><span class="line"></span><br><span class="line">real	1m11.675s</span><br><span class="line">user	4m4.464s</span><br><span class="line">sys	0m18.312s</span><br></pre></td></tr></table></figure>
<p>编译好的go和gofmt在<code>$GODIR/bin</code>目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ll <span class="variable">$GODIR</span>/bin</span><br><span class="line">total 16044</span><br><span class="line">-rwxrwxr-x 1 vnt vnt 13049123 Apr 14 10:53 go</span><br><span class="line">-rwxrwxr-x 1 vnt vnt  3377614 Apr 14 10:53 gofmt</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了防止我们修改的go和过去安装的go冲突，创建igo软连接，指向修改的go。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/testgo/bin</span><br><span class="line">$ <span class="built_in">cd</span> ~/testgo/bin</span><br><span class="line">$ ln -sf <span class="variable">$GODIR</span>/bin/go igo</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，把<code>~/testgo/bin</code>加入到<code>PATH</code>，就能使用<code>igo</code>来编译代码了，运行下igo，应当获得go1.11.2的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ igo version</span><br><span class="line">go version go1.11.2 linux/amd64</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>当前，已经掌握编译和使用修改的go的办法，接下来就以1个简单的例子，教大家如何验证想法。</p>
<h3 id="验证schedule-由g0执行"><a href="#验证schedule-由g0执行" class="headerlink" title="验证schedule()由g0执行"></a>验证schedule()由g0执行</h3><p>阅读源码的文章，你已经知道了g0是负责调度的，并且g0是全局变量，可在runtime包的任何地方直接使用，看到<code>schedule()</code>代码如下（所在文件：<code>$GODIR/src/runtime/proc.go</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前g，调度时这个g应当是g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;schedule: holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// m已经被某个g锁定，先停止当前m，等待g可运行时，再执行g，并且还得到了g所在的p</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">		stoplockedm()</span><br><span class="line">		execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>问题</strong>：既然g0是负责调度的，为何<code>schedule()</code>每次还都执行<code>_g_ := getg()</code>，直接使用g0不行吗？<code>schedule()</code>真的是g0执行的吗？</p>
<p>在<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">《Go调度器系列（2）宏观看调度器》</a>这篇文章中我曾介绍了trace的用法，阅读代码时发现<strong>使用<code>debug.schedtrace</code>和<code>print()</code>函数可以用作打印调试信息</strong>，那我们是不是可以使用这种方法打印我们想获取的信息呢？当然可以。</p>
<p>另外，注意<code>print()</code>并不是<code>fmt.Print()</code>，也不是C语言的<code>printf</code>，所以不是格式化输出，它是汇编实现的，我们不深入去了解它的实现了，现在要掌握它的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The print built-in function formats its arguments in an</span></span><br><span class="line"><span class="comment">// implementation-specific way and writes the result to standard error.</span></span><br><span class="line"><span class="comment">// Print is useful for bootstrapping and debugging; it is not guaranteed</span></span><br><span class="line"><span class="comment">// to stay in the language.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(args ...Type)</span></span></span><br></pre></td></tr></table></figure>

<p>从上面可以看到，它接受可变长参数，我们使用的时候只需要传进去即可，但要手动控制格式。</p>
<p>我们修改<code>schedule()</code>函数，使用<code>debug.schedtrace &gt; 0</code>控制打印，加入3行代码，把goid给打印出来，如果始终打印goid为0，则代表调度确实是由g0执行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;schedule(): goid = &quot;</span>, _g_.goid, <span class="string">&quot;\n&quot;</span>) <span class="comment">// 会是0吗？是的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>schedule()</code>如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前g，调度时这个g应当是g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;schedule(): goid = &quot;</span>, _g_.goid, <span class="string">&quot;\n&quot;</span>) <span class="comment">// 会是0吗？是的</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;schedule: holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译igo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd  $GODIR&#x2F;src</span><br><span class="line">$ .&#x2F;make.bash</span><br></pre></td></tr></table></figure>

<p>编写一个简单的demo（不能更简单）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下，你会发现所有的<code>schedule()</code>函数调用都打印<code>goid = 0</code>，足以证明Go调度器的调度由g0完成（如果你认为还是缺乏说服力，可以写复杂一些的demo）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 igo run demo1.go</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">SCHED 0ms: gomaxprocs=8 idleprocs=6 threads=4 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0 0 0 0 0]</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">schedule(): goid = 0</span><br><span class="line">// 省略几百行</span><br></pre></td></tr></table></figure>

<p><strong>启发比结论更重要，希望各位朋友在学习Go调度器的时候，能多一些自己的探索和研究，而不仅仅停留在看看别人文章之上</strong>。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://golang.org/doc/install/source">Installing Go from source</a></li>
</ol>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/04/14/golang-scheduler-4-explore-source-code/">http://lessisbetter.site/2019/04/14/golang-scheduler-4-explore-source-code/</a></li>
</ol>
</blockquote>
<div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div>
<img src="https://lessisbetter.site/images/2019-01-article_qrcode.jpg" style="border:0"  align=center />


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/04/golang-scheduler-3-principle-with-graph/" class="post-title-link" itemprop="url">Go调度器系列（3）图解调度原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-04 13:02:19" itemprop="dateCreated datePublished" datetime="2019-04-04T13:02:19+08:00">2019-04-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如果你已经阅读了前2篇文章：<a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">《调度起源》</a>和<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">《宏观看调度器》</a>，你对G、P、M肯定已经不再陌生，我们这篇文章就介绍Go调度器的基本原理，本文总结了12个主要的场景，覆盖了以下内容：</p>
<ol>
<li>G的创建和分配。</li>
<li>P的本地队列和全局队列的负载均衡。</li>
<li>M如何寻找G。</li>
<li>M如何从G1切换到G2。</li>
<li>work stealing，M如何去偷G。</li>
<li>为何需要自旋线程。</li>
<li>G进行系统调用，如何保证P的其他G’可以被执行，而不是饿死。</li>
<li>Go调度器的抢占。</li>
</ol>
<h3 id="12场景"><a href="#12场景" class="headerlink" title="12场景"></a>12场景</h3><blockquote>
<p>提示：图在前，场景描述在后。</p>
</blockquote>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331190809649-4030489.png"></p>
<blockquote>
<p>上图中三角形、正方形、圆形分别代表了M、P、G，正方形连接的绿色长方形代表了P的本地队列。</p>
</blockquote>
<p><strong>场景1</strong>：p1拥有g1，m1获取p1后开始运行g1，g1使用<code>go func()</code>创建了g2，为了局部性g2优先加入到p1的本地队列。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331190826838-4030506.png"></p>
<p><strong>场景2</strong>：<strong>g1运行完成后(函数：<code>goexit</code>)，m上运行的goroutine切换为g0，g0负责调度时协程的切换（函数：<code>schedule</code>）</strong>。从p1的本地队列取g2，从g0切换到g2，并开始运行g2(函数：<code>execute</code>)。实现了<strong>线程m1的复用</strong>。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331160718646-4019638.png"></p>
<p><strong>场景3</strong>：假设每个p的本地队列只能存4个g。g2要创建了6个g，前4个g（g3, g4, g5, g6）已经加入p1的本地队列，p1本地队列满了。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331160728024-4019648.png"></p>
<blockquote>
<p>蓝色长方形代表全局队列。</p>
</blockquote>
<p><strong>场景4</strong>：g2在创建g7的时候，发现p1的本地队列已满，需要执行<strong>负载均衡</strong>，把p1中本地队列中前一半的g，还有新创建的g<strong>转移</strong>到全局队列（实现中并不一定是新的g，如果g是g2之后就执行的，会被保存在本地队列，利用某个老的g替换新g加入全局队列），这些g被转移到全局队列时，会被打乱顺序。所以g3,g4,g7被转移到全局队列。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331161138353-4019898.png"></p>
<p><strong>场景5</strong>：g2创建g8时，p1的本地队列未满，所以g8会被加入到p1的本地队列。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331162734830-4020854.png"></p>
<p><strong>场景6</strong>：<strong>在创建g时，运行的g会尝试唤醒其他空闲的p和m执行</strong>。假定g2唤醒了m2，m2绑定了p2，并运行g0，但p2本地队列没有g，m2此时为自旋线程（没有G但为运行状态的线程，不断寻找g，后续场景会有介绍）。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331162717486-4020837.png"></p>
<p><strong>场景7</strong>：m2尝试从全局队列(GQ)取一批g放到p2的本地队列（函数：<code>findrunnable</code>）。m2从全局队列取的g数量符合下面的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n &#x3D; min(len(GQ)&#x2F;GOMAXPROCS + 1, len(GQ&#x2F;2))</span><br></pre></td></tr></table></figure>

<p>公式的含义是，至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。</p>
<p>假定我们场景中一共有4个P，所以m2只从能从全局队列取1个g（即g3）移动p2本地队列，然后完成从g0到g3的切换，运行g3。</p>
<p><img src="https://lessisbetter.site/images/2020-09-go-scheduler-p8.png"></p>
<p><strong>场景8</strong>：假设g2一直在m1上运行，经过2轮后，m2已经把g7、g4也挪到了p2的本地队列并完成运行，全局队列和p2的本地队列都空了，如上图左边。</p>
<p><strong>全局队列已经没有g，那m就要执行work stealing：从其他有g的p哪里偷取一半g过来，放到自己的P本地队列</strong>。p2从p1的本地队列尾部取一半的g，本例中一半则只有1个g8，放到p2的本地队列，情况如上图右边。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331170113457-4022873.png"></p>
<p><strong>场景9</strong>：p1本地队列g5、g6已经被其他m偷走并运行完成，当前m1和m2分别在运行g2和g8，m3和m4没有goroutine可以运行，m3和m4处于<strong>自旋状态</strong>，它们不断寻找goroutine。为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行g，就变成了浪费CPU？销毁线程不是更好吗？可以节约CPU资源。创建和销毁CPU都是浪费时间的，我们<strong>希望当有新goroutine创建时，立刻能有m运行它</strong>，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程，多余的没事做线程会让他们休眠（见函数：<code>notesleep()</code>）。</p>
<p><img src="https://lessisbetter.site/images/2019-04-image-20190331182939318-4028179.png"></p>
<p><strong>场景10</strong>：假定当前除了m3和m4为自旋线程，还有m5和m6为自旋线程，g8创建了g9，g8进行了<strong>阻塞的系统调用</strong>，m2和p2立即解绑，p2会执行以下判断：如果p2本地队列有g、全局队列有g或有空闲的m，p2都会立马唤醒1个m和它绑定，否则p2则会加入到空闲P列表，等待m来获取可用的p。本场景中，p2本地队列有g，可以和其他自旋线程m5绑定。</p>
<p><strong>场景11</strong>：（无图场景）g8创建了g9，假如g8进行了<strong>非阻塞系统调用</strong>（CGO会是这种方式，见<code>cgocall()</code>），m2和p2会解绑，但m2会记住p，然后g8和m2进入系统调用状态。当g8和m2退出系统调用时，会尝试获取p2，如果无法获取，则获取空闲的p，如果依然没有，g8会被记为可运行状态，并加入到全局队列。</p>
<p><strong>场景12</strong>：（无图场景）Go调度在go1.12实现了抢占，应该更精确的称为<strong>请求式抢占</strong>，那是因为go调度器的抢占和OS的线程抢占比起来很柔和，不暴力，不会说线程时间片到了，或者更高优先级的任务到了，执行抢占调度。<strong>go的抢占调度柔和到只给goroutine发送1个抢占请求，至于goroutine何时停下来，那就管不到了</strong>。抢占请求需要满足2个条件中的1个：1）G进行系统调用超过20us，2）G运行超过10ms。调度器在启动的时候会启动一个单独的线程sysmon，它负责所有的监控工作，其中1项就是抢占，发现满足抢占条件的G时，就发出抢占请求。</p>
<h3 id="场景融合"><a href="#场景融合" class="headerlink" title="场景融合"></a>场景融合</h3><p>如果把上面所有的场景都融合起来，就能构成下面这幅图了，它从整体的角度描述了Go调度器各部分的关系。图的上半部分是G的创建、负债均衡和work stealing，下半部分是M不停寻找和执行G的迭代过程。</p>
<p>如果你看这幅图还有些似懂非懂，建议赶紧开始看<a href="github.com/qyuhen/book">雨痕大神的Golang源码剖析</a>，章节：并发调度。</p>
<p><img src="https://lessisbetter.site/images/2019-04-arch.png"></p>
<p>总结，Go调度器和OS调度器相比，是相当的轻量与简单了，但它已经足以撑起goroutine的调度工作了，并且让Go具有了原生（强大）并发的能力，这是伟大的。如果你记住的不多，你一定要记住这一点：<strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</strong></p>
<h3 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h3><p>下篇会是源码层面的内容了，关于源码分析的书籍、文章可以先看起来了，先剧透一篇图，希望阅读下篇文章赶紧关注本公众号。</p>
<p><img src="https://lessisbetter.site/images/2019-04-flow.png"></p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">Go调度器系列（1）起源</a><br><a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">Go调度器系列（2）宏观看调度器</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>在学习调度器的时候，看了很多文章，这里列一些重要的：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://morsmachine.dk/go-scheduler">The Go scheduler</a></li>
<li><a target="_blank" rel="noopener" href="https://rakyll.org/scheduler/">Go’s work-stealing scheduler</a>，<a target="_blank" rel="noopener" href="https://lingchao.xin/post/gos-work-stealing-scheduler.html">中文翻译版</a></li>
<li><a target="_blank" rel="noopener" href="https://reading.developerlearning.cn/reading/12-2018-08-02-goroutine-gpm/">Go夜读：golang 中 goroutine 的调度</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part I、II、III </a>，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb6881a2661d">中文翻译版</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/qyuhen/book">雨痕大神的golang源码剖析</a></li>
<li><a target="_blank" rel="noopener" href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">也谈goroutine调度器</a></li>
<li><a target="_blank" rel="noopener" href="https://speakerdeck.com/kavya719/the-scheduler-saga">kavya的调度PPT</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md">抢占的设计提案，Proposal: Non-cooperative goroutine preemption</a></li>
</ol>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/">http://lessisbetter.site/2019/04/04/golang-scheduler-3-principle-with-graph/</a></li>
</ol>
</blockquote>
<div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div>
<img src="https://lessisbetter.site/images/2019-01-article_qrcode.jpg" style="border:0"  align=center />
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/26/golang-scheduler-2-macro-view/" class="post-title-link" itemprop="url">Go调度器系列（2）宏观看调度器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-26 17:29:29" itemprop="dateCreated datePublished" datetime="2019-03-26T17:29:29+08:00">2019-03-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>上一篇文章<a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">《Go语言高阶：调度器系列（1）起源》</a>，学goroutine调度器之前的一些背景知识，<strong>这篇文章则是为了对调度器有个宏观的认识，从宏观的3个角度，去看待和理解调度器是什么样子的，但仍然不涉及具体的调度原理</strong>。</p>
<p>三个角度分别是：</p>
<ol>
<li>调度器的宏观组成</li>
<li>调度器的生命周期</li>
<li>GMP的可视化感受</li>
</ol>
<p>在开始前，先回忆下调度器相关的3个缩写：</p>
<ul>
<li><strong>G</strong>: goroutine，每个G都代表1个goroutine </li>
<li><strong>M</strong>: 工作线程，是Go语言定义出来在用户层面描述系统线程的对象 ，每个M代表一个系统线程</li>
<li><strong>P</strong>: 处理器，它包含了运行Go代码的资源。</li>
</ul>
<p>3者的简要关系是P拥有G，M必须和一个P关联才能运行P拥有的G。 </p>
<h3 id="调度器的功能"><a href="#调度器的功能" class="headerlink" title="调度器的功能"></a>调度器的功能</h3><p><a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">《Go语言高阶：调度器系列（1）起源》</a>中介绍了协程和线程的关系，协程需要运行在线程之上，线程由CPU进行调度。</p>
<p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。</p>
<p>Go的调度器也是经过了多个版本的开发才是现在这个样子的，</p>
<ul>
<li>1.0版本发布了最初的、最简单的调度器，是G-M模型，存在4类问题</li>
<li>1.1版本重新设计，修改为G-P-M模型，奠定当前调度器基本模样</li>
<li><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.2#preemption">1.2版本</a>加入了抢占式调度，防止协程不让出CPU导致其他G饿死</li>
</ul>
<blockquote>
<p>在<code>$GOROOT/src/runtime/proc.go</code>的开头注释中包含了对Scheduler的重要注释，介绍Scheduler的设计曾拒绝过3种方案以及原因，本文不再介绍了，希望你不要忽略为数不多的官方介绍。</p>
</blockquote>
<h3 id="Scheduler的宏观组成"><a href="#Scheduler的宏观组成" class="headerlink" title="Scheduler的宏观组成"></a>Scheduler的宏观组成</h3><p><a target="_blank" rel="noopener" href="https://tonybai.com/">Tony Bai</a>在<a target="_blank" rel="noopener" href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">《也谈goroutine调度器》</a>中的这幅图，展示了goroutine调度器和系统调度器的关系，而不是把二者割裂开来，并且从宏观的角度展示了调度器的重要组成。</p>
<p><img src="https://lessisbetter.site/images/2019-03-goroutine-scheduler-model.png"></p>
<p>自顶向下是调度器的4个部分：</p>
<ol>
<li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li>
<li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个。</li>
<li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
</ol>
<p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。</p>
<h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p>接下来我们从另外一个宏观角度——生命周期，认识调度器。</p>
<p>所有的Go程序运行都会经过一个完整的调度器生命周期：从创建到结束。</p>
<p><img src="https://lessisbetter.site/images/2019-03-scheduler-lifetime.png"></p>
<p>即使下面这段简单的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.main</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello scheduler&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也会经历如上图所示的过程：</p>
<ol>
<li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li>
<li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li>
<li>示例代码中的main函数是<code>main.main</code>，<code>runtime</code>中也有1个main函数——<code>runtime.main</code>，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li>
<li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li>
<li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li>
<li>M运行G</li>
<li>G退出，再次回到M获取可运行的G，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个Go程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</p>
<h3 id="GMP的可视化感受"><a href="#GMP的可视化感受" class="headerlink" title="GMP的可视化感受"></a>GMP的可视化感受</h3><p>上面的两个宏观角度，都是根据文档、代码整理出来，最后我们从可视化角度感受下调度器，有2种方式。</p>
<p><strong>方式1：go tool trace</strong></p>
<p>trace记录了运行时的信息，能提供可视化的Web页面。</p>
<p>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello trace”退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建trace文件</span></span><br><span class="line">	f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动trace goroutine</span></span><br><span class="line">	err = trace.Start(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// main</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello trace&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序和运行trace：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  trace git:(master) ✗ go run trace1.go</span><br><span class="line">Hello trace</span><br><span class="line">➜  trace git:(master) ✗ ls</span><br><span class="line">trace.out trace1.go</span><br><span class="line">➜  trace git:(master) ✗</span><br><span class="line">➜  trace git:(master) ✗ go tool trace trace.out</span><br><span class="line">2019/03/24 20:48:22 Parsing trace...</span><br><span class="line">2019/03/24 20:48:22 Splitting trace...</span><br><span class="line">2019/03/24 20:48:22 Opening browser. Trace viewer is listening on http://127.0.0.1:55984</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://lessisbetter.site/images/2019-03-go-tool-trace.png" alt="trace1"></p>
<p>从上至下分别是goroutine（G）、堆、线程（M）、Proc（P）的信息，从左到右是时间线。用鼠标点击颜色块，最下面会列出详细的信息。</p>
<p>我们可以发现：</p>
<ul>
<li><code>runtime.main</code>的goroutine是<code>g1</code>，这个编号应该永远都不变的，<code>runtime.main</code>是在<code>g0</code>之后创建的第一个goroutine。</li>
<li>g1中调用了<code>main.main</code>，创建了<code>trace goroutine g18</code>。g1运行在P2上，g18运行在P0上。</li>
<li>P1上实际上也有goroutine运行，可以看到短暂的竖线。</li>
</ul>
<p>go tool trace的资料并不多，如果感兴趣可阅读：<a target="_blank" rel="noopener" href="https://making.pusher.com/go-tool-trace/">https://making.pusher.com/go-tool-trace/</a> ，中文翻译是：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nf_-AH_LeBN3913Pt6CzQQ">https://mp.weixin.qq.com/s/nf_-AH_LeBN3913Pt6CzQQ</a> 。</p>
<p><strong>方式2：Debug trace</strong></p>
<p>示例代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.main</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;Hello scheduler&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译和运行，运行过程会打印trace：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  one_routine2 git:(master) ✗ go build .</span><br><span class="line">➜  one_routine2 git:(master) ✗ GODEBUG=schedtrace=1000 ./one_routine2</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SCHED 0ms: gomaxprocs&#x3D;8 idleprocs&#x3D;5 threads&#x3D;5 spinningthreads&#x3D;1 idlethreads&#x3D;0 runqueue&#x3D;0 [0 0 0 0 0 0 0 0]</span><br><span class="line">SCHED 1001ms: gomaxprocs&#x3D;8 idleprocs&#x3D;8 threads&#x3D;5 spinningthreads&#x3D;0 idlethreads&#x3D;3 runqueue&#x3D;0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello scheduler</span><br><span class="line">SCHED 2002ms: gomaxprocs&#x3D;8 idleprocs&#x3D;8 threads&#x3D;5 spinningthreads&#x3D;0 idlethreads&#x3D;3 runqueue&#x3D;0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello scheduler</span><br><span class="line">SCHED 3004ms: gomaxprocs&#x3D;8 idleprocs&#x3D;8 threads&#x3D;5 spinningthreads&#x3D;0 idlethreads&#x3D;3 runqueue&#x3D;0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello scheduler</span><br><span class="line">SCHED 4005ms: gomaxprocs&#x3D;8 idleprocs&#x3D;8 threads&#x3D;5 spinningthreads&#x3D;0 idlethreads&#x3D;3 runqueue&#x3D;0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello scheduler</span><br><span class="line">SCHED 5013ms: gomaxprocs&#x3D;8 idleprocs&#x3D;8 threads&#x3D;5 spinningthreads&#x3D;0 idlethreads&#x3D;3 runqueue&#x3D;0 [0 0 0 0 0 0 0 0]</span><br><span class="line">Hello scheduler</span><br></pre></td></tr></table></figure>

<p>看到这密密麻麻的文字就有点担心，不要愁！因为每行字段都是一样的，各字段含义如下：</p>
<ul>
<li>SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；</li>
<li>0ms：即从程序启动到输出这行日志的时间；</li>
<li>gomaxprocs: P的数量，本例有8个P；</li>
<li>idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</li>
<li>threads: os threads/M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</li>
<li>spinningthreads: 处于自旋状态的os thread数量；</li>
<li>idlethread: 处于idle状态的os thread的数量；</li>
<li>runqueue=0： Scheduler全局队列中G的数量；</li>
<li><code>[0 0 0 0 0 0 0 0]</code>: 分别为8个P的local queue中的G的数量。</li>
</ul>
<p>看第一行，含义是：刚启动时创建了8个P，其中5个空闲的P，共创建5个M，其中1个M处于自旋，没有M处于空闲，8个P的本地队列都没有G。</p>
<p>再看个复杂版本的，加上<code>scheddetail=1</code>可以打印更详细的trace信息。</p>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  one_routine2 git:(master) ✗ GODEBUG=schedtrace=1000,scheddetail=1 ./one_routine2</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://lessisbetter.site/images/2019-03-for-print-syscall.png"><br><em>截图可能更代码匹配不起来，最初代码是for死循环，后面为了减少打印加了限制循环5次</em></p>
<p>每次分别打印了每个P、M、G的信息，P的数量等于<code>gomaxprocs</code>，M的数量等于<code>threads</code>，主要看圈黄的地方：</p>
<ul>
<li>第1处：P1和M2进行了绑定。</li>
<li>第2处：M2和P1进行了绑定，但M2上没有运行的G。</li>
<li>第3处：代码中使用fmt进行打印，会进行系统调用，P1系统调用的次数很多，说明我们的用例函数基本在P1上运行。</li>
<li>第4处和第5处：M0上运行了G1，G1的状态为3（系统调用），G进行系统调用时，M会和P解绑，但M会记住之前的P，所以M0仍然记绑定了P1，而P1称未绑定M。</li>
</ul>
<h3 id="总结时刻"><a href="#总结时刻" class="headerlink" title="总结时刻"></a>总结时刻</h3><p>这篇文章，从3个宏观的角度介绍了调度器，也许你依然不知道调度器的原理，心里感觉模模糊糊，没关系，一步一步走，通过这篇文章希望你了解了：</p>
<ol>
<li>Go调度器和OS调度器的关系</li>
<li>Go调度器的生命周期/总体流程</li>
<li>P的数量等于GOMAXPROCS</li>
<li>M需要通过绑定的P获取G，然后执行G，不断重复这个过程</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有示例代码都在Github，可通过阅读原文访问：<a target="_blank" rel="noopener" href="https://github.com/Shitaibin/golang_step_by_step/tree/master/scheduler">golang_step_by_step/tree/master/scheduler</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28058856">Go程序的“一生”</a></li>
<li><a target="_blank" rel="noopener" href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">也谈goroutine调度器</a></li>
<li><a target="_blank" rel="noopener" href="https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs">Debug trace, 当前调度器设计人Dmitry Vyukov的文章</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nf_-AH_LeBN3913Pt6CzQQ">Go tool trace中文翻译</a></li>
<li><a target="_blank" rel="noopener" href="https://dave.cheney.net/tag/godebug">Dave关于GODEBUG的介绍</a></li>
</ul>
<blockquote>
<p>最近的感受是：自己懂是一个层次，能写出来需要抬升一个层次，给他人讲懂又需要抬升一个层次。希望朋友们有所收获。</p>
</blockquote>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a></li>
</ol>
</blockquote>
<div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div>
<img src="https://lessisbetter.site/images/2019-01-article_qrcode.jpg" style="border:0"  align=center />
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/03/15/ethereum-broadcast-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/15/ethereum-broadcast-transaction/" class="post-title-link" itemprop="url">以太坊交易广播：从宏观到微观</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-15 21:01:43" itemprop="dateCreated datePublished" datetime="2019-03-15T21:01:43+08:00">2019-03-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>从宏观看，交易在区块链网络中的传播，像广度搜索算法，也像湖面上的水纹，一圈圈向外扩散。但实际场景由于网络通信环境，可能效果上并非一圈一圈向外的，但总体上是向外扩散。</p>
<p><img src="https://lessisbetter.site/images/2019-03-tx-macro.png"></p>
<p>从微观上讲，两个节点间交易的传播如下图。从钱包到节点，节点把可打包的交易发送给相连的节点。主要流程如下：</p>
<ol>
<li>钱包（浏览器、APP）发送交易到节点。</li>
<li>节点把收到的交易插入<code>txpool</code>。</li>
<li>可打包（<code>nonce</code>值连续）的交易加入<code>txpool.pending</code>，不可打包的交易(<code>nonce</code>值存在断开)插入到<code>txpool.queued</code>。</li>
<li>交易进入<code>txpool.pending</code>后，<code>txpool</code>发布<code>NewTxsEvent</code>。</li>
<li><code>Protocol Manager</code>收到事件后，<code>txBroadcastLoop</code>将交易加入到连接的peer的交易队列（得缓冲一下，不一定能很快发，毕竟连接上有很多类型的数据需要传送）。</li>
<li>各peer协程从各自的交易队列取交易合成消息，发送给peer。</li>
<li>peer收到交易消息后，加入<code>txpool</code>，回到步骤2。</li>
</ol>
<p><img src="https://lessisbetter.site/images/2019-03-tx-micro.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/03/12/distribute-system-network-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/12/distribute-system-network-model/" class="post-title-link" itemprop="url">分布式系统基础：网络模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-12 14:43:41" itemprop="dateCreated datePublished" datetime="2019-03-12T14:43:41+08:00">2019-03-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 14:18:43" itemprop="dateModified" datetime="2020-12-13T14:18:43+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>狭义上的分布式系统是指通过网络连接的计算机系统, 每个计算节点承担独立的计算和存储, 节点之间通过网络协同工作, 因此整个系统中的事件可以同时发生. 广义上的分布式系统是一个非常相对的概念, 比如多核CPU的计算也包含在内。</p>
<p>了解分布式系统不得不提网络模型，<a target="_blank" rel="noopener" href="https://danielw.cn/network-failure-models">《分布式系统中的网络模型和故障模型》</a>这篇文章给了很好的解释:</p>
<ol>
<li><p><strong>同步网络(synchronous network)</strong>: 这里的同步网络和编程中的同步阻塞io和异步非阻塞io是两回事, 不要弄混了. 同步网络是指:</p>
<ol>
<li><p>所有节点的时钟漂移有上限, </p>
</li>
<li><p>网络的传输时间有上限, </p>
</li>
<li><p>所有节点的计算速度一样. </p>
<p>这意味着整个网络按照round运行, 每个round中任何节点都要执行完本地计算并且可以完成一个任意大小消息的传输. <strong>一个发出的消息如果在一个round内（或者说超时时间内）没有到达, 那么一定是网络中断造成的, 这个消息会丢失, 不会延迟到第二个round到达</strong>. 在现实生活中这种网络比较少, 尽管很少, 同步网络仍然是在计算机科学中是不可缺少的一个模型, 在这种模型下可以解决一些问题, 比如拜占庭式故障. 但我们每天打交道的网络大多都是异步网络.</p>
</li>
</ol>
</li>
<li><p><strong>异步网络(asynchornous network)</strong>: <strong>和同步网络相反, 节点的时钟漂移无上限, 消息的传输延迟无上限（无法区分消息丢失还是延迟）, 节点计算的速度不可预料</strong>. 这就是和我们每天打交道的网络类型. 在异步网络中, 有些故障非常难解决, 比如当你发给一个节点一个消息之后几秒钟都没有收到他的应答, 有可能这个节点计算非常慢, 但是也可能是节点crash或者网络延迟造成的, 你很难判断到底是发生了什么样的故障.</p>
</li>
</ol>
<p>现实世界中99%场景都是异步网络，同步网络是比较理想的场景，经常拿来做研究，如果在同步网络下都无法解决的问题，更不可能在异步网络中解决。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/03/12/distribute-system-network-partition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/12/distribute-system-network-partition/" class="post-title-link" itemprop="url">分布式系统基础：网络分区</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-12 14:42:01" itemprop="dateCreated datePublished" datetime="2019-03-12T14:42:01+08:00">2019-03-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>分布式系统永远离不开对网络分区的考虑，大名鼎鼎的CAP定理更是指出有P的情况下，只能A和C二选一，虽然CAP的提出人Brewer在2012年又写文章说大家对CAP是有误解的，尤其是三选二，但这不在讨论范围，我们只探究下网络分区。</p>
<p>下图来自Wiki。</p>
<p><img src="https://lessisbetter.site/images/2019-03-Network_Partition_for_Optimization-2.png"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>WIKI给的定义是：<strong>网络分区指由于网络设备的failure，造成网络分裂为多个独立的组</strong>。</p>
<p>Gilbert和Lynch在论文中定义分区容忍性的：<strong>网络允许丢失一个节点发给另一个节点的任意多的消息</strong>。</p>
<p>我认为Gilbert和Lynch给的更有通用意义，因为造成网络分区的不仅仅是网络设备的failure，两个节点无法再交互的时候就形成分区了，分区原因有：</p>
<ul>
<li>网络设备failure：比如网线断了，交换机故障了。</li>
<li>节点failure：节点的软件或者硬件坏了，节点成为故障节点。当故障的节点非常多，故障节点和正常节点就不在1个分区，如果正常的节点数量达不到quorum，分布式系统无法正常运作。</li>
</ul>
<p>所以我认为网络分区的原因即有Network failure又有Node failure。</p>
<h3 id="网络分区和网络模型"><a href="#网络分区和网络模型" class="headerlink" title="网络分区和网络模型"></a>网络分区和网络模型</h3><p><img src="https://lessisbetter.site/images/2019-03-network-partion-1.jpg"></p>
<p>我们考虑下网络分区的检测。</p>
<ul>
<li>同步网络下，橘黄色节点和青色节点间的通信中断，就当网线断裂好了，节点向对方发送的消息如果在超时时间内没有收到响应，就可以认为消息丢失，形成了网络分区。</li>
<li>异步网络下，通信差是一种常态，消息的传递是非常不可靠的，消息无限延时，也可能丢失，根本无法确认消息是否到达对方节点，所以也无法确认/检测是否形成分区。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/10/golang-scheduler-1-history/" class="post-title-link" itemprop="url">Go调度器系列（1）起源</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-10 17:25:57" itemprop="dateCreated datePublished" datetime="2019-03-10T17:25:57+08:00">2019-03-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如果把语言比喻为武侠小说中的武功，如果只是会用，也就是达到四五层，如果用的熟练也就六七层，如果能见招拆招也得八九层，如果你出神入化，立于不败之地十层。</p>
<p>如果你想真正掌握一门语言的，怎么也得八层以上，需要你深入了解这门语言方方面面的细节。</p>
<p>希望以后对Go语言的掌握能有八九层，怎么能不懂调度器！？</p>
<p>Google、百度、微信搜索了许多Go语言调度的文章，这些文章上来就讲调度器是什么样的，它由哪些组成，它的运作原理，搞的我只能从这些零散的文章中形成调度器的“概貌”，这是我想要的结果，但这还不够。</p>
<p>学习不仅要知其然，还要知其所以然。</p>
<p>学习之前，先学知识点的历史，再学知识，这样你就明白，为什么它是当下这个样子。</p>
<p>所以，我打算写一个goroutine调度器的系列文章，从历史背景讲起，循序渐进，希望大家能对goroutine调度器有一个全面的认识。</p>
<p>这篇文章介绍调度器相关的历史背景，请慢慢翻阅。</p>
<h3 id="远古时代"><a href="#远古时代" class="headerlink" title="远古时代"></a>远古时代</h3><p><img src="https://lessisbetter.site/images/2019-03-Eniac.jpg"></p>
<p>上面这个大家伙是ENIAC，它诞生在宾夕法尼亚大学，是世界第一台真正的通用计算机，和现代的计算机相比，它是相当的“笨重”，它的计算能力，跟现代人手普及的智能手机相比，简直是一个天上一个地下，ENIAC在地下，智能手机在天上。</p>
<p>它上面没有操作系统，更别提进程、线程和协程了。</p>
<h3 id="进程时代"><a href="#进程时代" class="headerlink" title="进程时代"></a>进程时代</h3><p><img src="https://lessisbetter.site/images/2019-03-apple-II.jpeg"></p>
<p>后来，现代化的计算机有了操作系统，每个程序都是一个进程，但是操作系统在一段时间只能运行一个进程，直到这个进程运行完，才能运行下一个进程，这个时期可以成为<strong>单进程时代——串行时代</strong>。</p>
<p>和ENIAC相比，单进程是有了几万倍的提度，但依然是太慢了，比如进程要读数据阻塞了，CPU就在哪浪费着，伟大的程序员们就想了，不能浪费啊，<strong>怎么才能充分的利用CPU呢？</strong></p>
<p>后来操作系统就具有了<strong>最早的并发能力：多进程并发</strong>，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p>
<h3 id="线程时代"><a href="#线程时代" class="headerlink" title="线程时代"></a>线程时代</h3><p><img src="https://lessisbetter.site/images/2019-03-Macintosh.jpeg"></p>
<p>多进程真实个好东西，有了对进程的调度能力之后，伟大的程序员又发现，进程拥有太多资源，在创建、切换和销毁的时候，都会占用很长的时间，CPU虽然利用起来了，但CPU有很大的一部分都被用来进行进程调度了，<strong>怎么才能提高CPU的利用率呢？</strong></p>
<p>大家希望能有一种轻量级的进程，调度不怎么花时间，这样CPU就有更多的时间用在执行任务上。</p>
<p>后来，操作系统支持了线程，线程在进程里面，线程运行所需要资源比进程少多了，跟进程比起来，切换简直是“不算事”。</p>
<p>一个进程可以有多个线程，CPU在执行调度的时候切换的是线程，如果下一个线程也是当前进程的，就只有线程切换，“很快”就能完成，如果下一个线程不是当前的进程，就需要切换进程，这就得费点时间了。</p>
<p>这个时代，<strong>CPU的调度切换的是进程和线程</strong>。多线程看起来很美好，但实际多线程编程却像一坨屎，一是由于线程的设计本身有点复杂，而是由于需要考虑很多底层细节，比如锁和冲突检测。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><img src="https://lessisbetter.site/images/2019-macbook-steve.jpeg"></p>
<p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存（每个线程的内存占用级别为MB），线程多了之后调度也会消耗大量的CPU。伟大的程序员们有开始想了，<strong>如何才能充分利用CPU、内存等资源的情况下，实现更高的并发</strong>？</p>
<p>既然线程的资源占用、调度在高并发的情况下，依然是比较大的，是否有一种东西，更加轻量？</p>
<p>你可能知道：线程分为内核态线程和用户态线程，用户态线程需要绑定内核态线程，CPU并不能感知用户态线程的存在，它只知道它在运行1个线程，这个线程实际是内核态线程。</p>
<p><strong>用户态线程实际有个名字叫协程（co-routine）</strong>，为了容易区分，我们使用协程指用户态线程，使用线程指内核态线程。</p>
<blockquote>
<p>User-level threads, Application-level threads, Green threads都指一样的东西，就是不受OS感知的线程，如果你Google coroutine相关的资料，会看到它指的就是用户态线程，在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Green_threads">Green threads的维基百科</a>里，看Green threads的实现列表，你会看到好很多coroutine实现，比如Java、Lua、Go、Erlang、Common Lisp、Haskell、Rust、PHP、Stackless Python，所以，我认为用户态线程就是协程。</p>
</blockquote>
<p>协程跟线程是有区别的，线程由CPU调度是抢占式的，<strong>协程由用户态调度是协作式的</strong>，一个协程让出CPU后，才执行下一个协程。</p>
<p>协程和线程有3种映射关系：</p>
<ul>
<li>N:1，N个协程绑定1个线程，优点就是<strong>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</strong>。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上，一是某个程序用不了硬件的多核加速能力，二是一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
<li>1:1，1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，但有一个缺点是协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li>
<li>M:N，M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</li>
</ul>
<p>协程是个好东西，不少语言支持了协程，比如：Lua、Erlang、Java（C++即将支持），就算语言不支持，也有库支持协程，比如C语言的<a target="_blank" rel="noopener" href="https://github.com/cloudwu/coroutine/">coroutine</a>（云风大牛作品）、Kotlin的kotlinx.coroutines、Python的gevent。</p>
<h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p><strong>Go语言的诞生就是为了支持高并发</strong>，有2个支持高并发的模型：CSP和Actor。<a target="_blank" rel="noopener" href="https://golang.org/doc/faq">鉴于Occam和Erlang都选用了CSP</a>(来自Go FAQ)，并且效果不错，Go也选了CSP，但与前两者不同的是，Go把channel作为头等公民。</p>
<p>就像前面说的多线程编程太不友好了，<strong>Go为了提供更容易使用的并发方法，使用了goroutine和channel</strong>。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p>
<p>Go中，协程被称为goroutine（Rob Pike说goroutine不是协程，因为他们并不完全相同），它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。</p>
<h3 id="Go语言的老调度器"><a href="#Go语言的老调度器" class="headerlink" title="Go语言的老调度器"></a>Go语言的老调度器</h3><p>终于来到了Go语言的调度器环节。</p>
<p><strong>调度器的任务是在用户态完成goroutine的调度，而调度器的实现好坏，对并发实际有很大的影响，并且Go的调度器就是M:N类型的，实现起来也是最复杂</strong>。</p>
<p>现在的Go语言调度器是2012年重新设计的（<a target="_blank" rel="noopener" href="https://golang.org/s/go11sched">设计方案</a>），在这之前的调度器称为老调度器，老调度器的实现不太好，存在性能问题，所以用了4年左右就被替换掉了，老调度器大概是下面这个样子：</p>
<p><img src="https://lessisbetter.site/images/2019-03-old-scheduler.png"></p>
<p>最下面是操作系统，中间是runtime，runtime在Go中很重要，许多程序运行时的工作都由runtime完成，调度器就是runtime的一部分，虚线圈出来的为调度器，它有两个重要组成：</p>
<ul>
<li><strong>M，代表线程</strong>，它要运行goroutine。</li>
<li>Global G Queue，是全局goroutine队列，所有的goroutine都保存在这个队列中，<strong>goroutine用G进行代表</strong>。</li>
</ul>
<p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥/同步，所以全局G队列是有互斥锁进行保护的。</p>
<p>老调度器有4个缺点：</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li>
<li>M转移G会造成<strong>延迟和额外的系统负载</strong>。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了<strong>很差的局部性</strong>，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li>
<li>M中的mcache是用来存放小对象的，mcache和栈都和M关联造成了大量的内存开销和差的局部性。</li>
<li>系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<h3 id="Go语言的新调度器"><a href="#Go语言的新调度器" class="headerlink" title="Go语言的新调度器"></a>Go语言的新调度器</h3><p>面对以上老调度的问题，Go设计了新的调度器，设计文稿：<a target="_blank" rel="noopener" href="https://golang.org/s/go11sched">https://golang.org/s/go11sched</a></p>
<p>新调度器引入了：</p>
<ul>
<li><strong>P</strong>：<strong>Processor，它包含了运行goroutine的资源</strong>，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</li>
<li>work stealing：当M绑定的P没有可运行的G时，它可以从其他运行的M’那里偷取G。</li>
</ul>
<p>现在，<strong>调度器中3个重要的缩写你都接触到了，所有文章都用这几个缩写，请牢记</strong>：</p>
<ul>
<li><strong>G</strong>: goroutine </li>
<li><strong>M</strong>: 工作线程 </li>
<li><strong>P</strong>: 处理器，它包含了运行Go代码的资源，M必须和一个P关联才能运行G。 </li>
</ul>
<p>这篇文章的目的不是介绍调度器的实现，而是调度器的一些理念，帮助你后面更好理解调度器的实现，所以我们回归到调度器设计思想上。</p>
<p><img src="https://lessisbetter.site/images/2019-03-thoughts-of-scheduler.png" alt="thoughts-of-scheduler"></p>
<p>调度器的有<strong>两大思想</strong>：</p>
<p><strong>复用线程</strong>：协程本身就是运行在一组线程之上，不需要频繁的创建、销毁线程，而是对线程的复用。在调度器中复用线程还有2个体现：1）work stealing，当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。2）hand off，当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p>
<p><strong>利用并行</strong>：GOMAXPROCS设置P的数量，当GOMAXPROCS大于1时，就最多有GOMAXPROCS个线程处于运行状态，这些线程可能分布在多个CPU核上同时运行，使得并发利用并行。另外，GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。</p>
<p>调度器的<strong>两小策略</strong>：</p>
<p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p>
<p><strong>全局G队列</strong>：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p>
<p>上面提到并行了，关于并发和并行再说一下：Go创始人Rob Pike一直在强调go是并发，不是并行，因为Go做的是在一段时间内完成几十万、甚至几百万的工作，而不是同一时间同时在做大量的工作。<strong>并发可以利用并行提高效率，调度器是有并行设计的</strong>。</p>
<p>并行依赖多核技术，每个核上在某个时间只能执行一个线程，当我们的CPU有8个核时，我们能同时执行8个线程，这就是并行。</p>
<p><img src="https://lessisbetter.site/images/2019-03-concurrency-parallelism.png"></p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>这篇文章的主要目的是为后面介绍Go语言调度器做铺垫，由远及近的方式简要介绍了多进程、多线程、协程、并发和并行有关的“史料”，希望你了解为什么Go采用了goroutine，又为何调度器如此重要。</p>
<p>如果你等不急了，想了解Go调度器相关的原理，看下这些文章：</p>
<ul>
<li>设计方案：<a target="_blank" rel="noopener" href="https://golang.org/s/go11sched">https://golang.org/s/go11sched</a></li>
<li>代码中关于调度器的描述：<a target="_blank" rel="noopener" href="https://golang.org/src/runtime/proc.go">https://golang.org/src/runtime/proc.go</a></li>
<li>引用最多的调度器文章：<a target="_blank" rel="noopener" href="https://morsmachine.dk/go-scheduler">https://morsmachine.dk/go-scheduler</a></li>
<li>kavya的PPT，目前看到的讲调度最好的PPT：<a target="_blank" rel="noopener" href="https://speakerdeck.com/kavya719/the-scheduler-saga">https://speakerdeck.com/kavya719/the-scheduler-saga</a></li>
<li>work stealing论文：<a target="_blank" rel="noopener" href="http://supertech.csail.mit.edu/papers/steal.pdf">http://supertech.csail.mit.edu/papers/steal.pdf</a></li>
<li>分析调度器的论文（就问你6不6，还有论文研究）：<a target="_blank" rel="noopener" href="http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf">http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf</a></li>
</ul>
<p><strong>声明</strong>：关于老调度器的资料已经完全搜不到，根据新版调度器设计方案的描述，想象着写了老调度器这一章，可能存在错误。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer#History">https://en.wikipedia.org/wiki/Computer#History</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Process_(computing)#History">https://en.wikipedia.org/wiki/Process_(computing)#History</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_(computing)#History">https://en.wikipedia.org/wiki/Thread_(computing)#History</a></li>
<li><a target="_blank" rel="noopener" href="https://golang.org/doc/faq#goroutines">https://golang.org/doc/faq#goroutines</a></li>
<li><a target="_blank" rel="noopener" href="https://golang.org/s/go11sched">https://golang.org/s/go11sched</a></li>
<li><a target="_blank" rel="noopener" href="https://golang.org/src/runtime/proc.go">https://golang.org/src/runtime/proc.go</a></li>
</ol>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/03/10/golang-scheduler-1-history">http://lessisbetter.site/2019/03/10/golang-scheduler-1-history</a></li>
</ol>
</blockquote>
<div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div>
<img src="https://lessisbetter.site/images/2019-01-article_qrcode.jpg" style="border:0"  align=center />
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18051706号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大彬</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  

<script src="//cdn.jsdelivr.net/npm/algoliasearch@4.8.2/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4.8.7/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>







</body>
</html>
