<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lessisbetter.site","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="前言一份Peer节点启动的INFO级别日志如下，可以发现：  先注册了scc目录下的lscc, cscc, qscc，未注册chaincode目录下的lifecycle 然后又依次部署了上述scc。  本文的目的就是梳理出，系统链码的部署流程，这是peer节点提供背书、链码管理、配置、查询等功能的基础。 12345678910111213142019-09-09 07:52:09.409 UTC">
<meta property="og:type" content="article">
<meta property="og:title" content="Fabric 1.4源码解读 2：系统链码SCC是如何部署的">
<meta property="og:url" content="http://lessisbetter.site/2019/09/11/fabric-deploy-scc/index.html">
<meta property="og:site_name" content="Go语言充电站">
<meta property="og:description" content="前言一份Peer节点启动的INFO级别日志如下，可以发现：  先注册了scc目录下的lscc, cscc, qscc，未注册chaincode目录下的lifecycle 然后又依次部署了上述scc。  本文的目的就是梳理出，系统链码的部署流程，这是peer节点提供背书、链码管理、配置、查询等功能的基础。 12345678910111213142019-09-09 07:52:09.409 UTC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lessisbetter.site/images/2019-09-deploy-scc-flow.png">
<meta property="og:image" content="https://lessisbetter.site/images/2019-09-peer-cc-communication.png">
<meta property="og:image" content="https://lessisbetter.site/images/2019-09-deploycc-msg.png">
<meta property="article:published_time" content="2019-09-11T03:37:27.000Z">
<meta property="article:modified_time" content="2020-12-13T08:44:06.387Z">
<meta property="article:author" content="大彬">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="Fabric">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lessisbetter.site/images/2019-09-deploy-scc-flow.png">


<link rel="canonical" href="http://lessisbetter.site/2019/09/11/fabric-deploy-scc/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Fabric 1.4源码解读 2：系统链码SCC是如何部署的 | Go语言充电站</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Go语言充电站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大彬 less is better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li>
        <li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-专题"><a href="/subject/" rel="section"><i class="fa fa-calendar fa-fw"></i>专题</a></li>
        <li class="menu-item menu-item-大牛博客"><a href="/blogs/" rel="section"><i class="fa fa-calendar fa-fw"></i>大牛博客</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F%E8%A7%82%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">宏观流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">总流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8CSCC"><span class="nav-number">4.</span> <span class="nav-text">注册SCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#peer-node"><span class="nav-number">4.1.</span> <span class="nav-text">peer.node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#core-scc"><span class="nav-number">4.2.</span> <span class="nav-text">core.scc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#core-container"><span class="nav-number">4.3.</span> <span class="nav-text">core.container</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2SCC"><span class="nav-number">5.</span> <span class="nav-text">部署SCC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#peer-node-1"><span class="nav-number">5.1.</span> <span class="nav-text">peer.node</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#core-scc-1"><span class="nav-number">5.2.</span> <span class="nav-text">core.scc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#core-chaincode"><span class="nav-number">5.3.</span> <span class="nav-text">core.chaincode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#core-container-1"><span class="nav-number">5.4.</span> <span class="nav-text">core.container</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA"><span class="nav-number">5.4.1.</span> <span class="nav-text">虚拟机创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VM%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="nav-number">5.4.2.</span> <span class="nav-text">VM处理操作虚拟机的请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8shim%E5%90%AF%E5%8A%A8Inproc%E9%93%BE%E7%A0%81%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.4.3.</span> <span class="nav-text">利用shim启动Inproc链码容器中的程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SCC%E5%92%8CPeer%E7%9A%84%E9%80%9A%E4%BF%A1%E9%80%9A%E9%81%93"><span class="nav-number">5.4.4.</span> <span class="nav-text">SCC和Peer的通信通道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Peer%E5%92%8C%E9%93%BE%E7%A0%81%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%8C%E5%AE%8C%E6%88%90%E9%93%BE%E7%A0%81%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8"><span class="nav-number">5.5.</span> <span class="nav-text">Peer和链码容器的交互，完成链码容器启动</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="大彬"
      src="https://github.com/Shitaibin/shitaibin.github.io/blob/hexo_resource/images/gzh-qrcode-logo-small.png">
  <p class="site-author-name" itemprop="name">大彬</p>
  <div class="site-description" itemprop="description">云原生、Go语言、区块链</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">137</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://xargin.com/" title="Xargin曹大博客 → https:&#x2F;&#x2F;xargin.com&#x2F;" rel="noopener" target="_blank">Xargin曹大博客</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://qcrao.github.io/" title="码农桃花源博客 → https:&#x2F;&#x2F;qcrao.github.io&#x2F;" rel="noopener" target="_blank">码农桃花源博客</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://book.eddycjy.com/golang/" title="煎鱼博客 → https:&#x2F;&#x2F;book.eddycjy.com&#x2F;golang&#x2F;" rel="noopener" target="_blank">煎鱼博客</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/11/fabric-deploy-scc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://github.com/Shitaibin/shitaibin.github.io/blob/hexo_resource/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Fabric 1.4源码解读 2：系统链码SCC是如何部署的
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-11 11:37:27" itemprop="dateCreated datePublished" datetime="2019-09-11T11:37:27+08:00">2019-09-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一份Peer节点启动的INFO级别日志如下，可以发现：</p>
<ol>
<li>先注册了scc目录下的lscc, cscc, qscc，未注册chaincode目录下的lifecycle</li>
<li>然后又依次部署了上述scc。</li>
</ol>
<p>本文的目的就是梳理出，系统链码的部署流程，这是peer节点提供背书、链码管理、配置、查询等功能的基础。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.409 UTC [gossip.gossip] start -&gt; INFO 013 Gossip instance peer1.org1.example.com:8051 started</span><br><span class="line">2019-09-09 07:52:09.418 UTC [sccapi] deploySysCC -&gt; INFO 014 system chaincode lscc&#x2F;(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;lscc) deployed</span><br><span class="line">2019-09-09 07:52:09.420 UTC [cscc] Init -&gt; INFO 015 Init CSCC</span><br><span class="line">2019-09-09 07:52:09.422 UTC [sccapi] deploySysCC -&gt; INFO 016 system chaincode cscc&#x2F;(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;cscc) deployed</span><br><span class="line">2019-09-09 07:52:09.424 UTC [qscc] Init -&gt; INFO 017 Init QSCC</span><br><span class="line">2019-09-09 07:52:09.424 UTC [sccapi] deploySysCC -&gt; INFO 018 system chaincode qscc&#x2F;(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;qscc) deployed</span><br><span class="line">2019-09-09 07:52:09.425 UTC [sccapi] deploySysCC -&gt; INFO 019 system chaincode (+lifecycle,github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;chaincode&#x2F;lifecycle) disabled</span><br><span class="line">...</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 031 system chaincode lscc&#x2F;mychannel(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;lscc) deployed</span><br><span class="line">2019-09-09 07:52:14.386 UTC [cscc] Init -&gt; INFO 032 Init CSCC</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 033 system chaincode cscc&#x2F;mychannel(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;cscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [qscc] Init -&gt; INFO 034 Init QSCC</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 035 system chaincode qscc&#x2F;mychannel(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;qscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 036 system chaincode (+lifecycle,github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;chaincode&#x2F;lifecycle) disabled</span><br></pre></td></tr></table></figure>

<h2 id="宏观流程"><a href="#宏观流程" class="headerlink" title="宏观流程"></a>宏观流程</h2><blockquote>
<p>提醒，本文使用<strong>SCC代指系统链码</strong>，使用scc代指core.scc模块。</p>
</blockquote>
<p>在介绍源码之前，先给出总体流程，以便看源码的时候不会迷失。</p>
<p>部署SCC会涉及到4个模块：</p>
<ol>
<li>peer.node，它是peer的主程序，可以调用core.scc进行注册和部署SCC</li>
<li>core.scc，它包含了lscc、qscc、cscc这3个scc，以及SCC的注册和部署</li>
<li>core.chaincode，它是链码管理，普通链码和SCC都会走该模块，去部署和调用链码，和链码容器交互，并且它还提供了1个链码容器的工具shim</li>
<li>core.container，它是实现链码容器，有2种链码容器，SCC使用的InprocVM，和普通链码使用的DockerVM</li>
</ol>
<p>注册和部署的简要流程如下：</p>
<p><img src="https://lessisbetter.site/images/2019-09-deploy-scc-flow.png"></p>
<ol>
<li>peer运行启动程序</li>
<li>注册scc<ol>
<li>peer.node创建好lscc、cscc、qscc等scc实例，以及从配置文件读取的scc</li>
<li>peer.node调用core.scc依次注册每一个scc实例</li>
<li>core.scc调用core.container把scc实例信息注册到container</li>
</ol>
</li>
<li>部署scc<ol>
<li>peer.node调用core.scc依次部署每一个注册的scc</li>
<li>core.scc部署scc的流程复用普通链码部署流程，调用core.chaincode</li>
<li>core.chaincode执行启动链码容器，scc也有链码容器是Inproc类型，不是Docker类型</li>
<li>core.chaincode会调用core.container建立scc的Inproc容器实例</li>
<li>core.container调用core.chaincode.shim启动容器内的程序，并负责和peer通信</li>
<li>启动完成后，core.chaincode向容器发送Init消息，让容器初始化，容器初始化完成会发送响应消息给core.chaincode，core.chaincode部署scc完成</li>
</ol>
</li>
</ol>
<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><blockquote>
<p>列出源码的过程，会省略大量不相关代码，用<code>...</code>代替。</p>
</blockquote>
<p>peer启动过程中，会调用<code>node.serve</code>，其中包含了为系统链码注册SCC和部署SCC。之后，还会为应用通道部署SCC，说明每个通道有各自的SCC，这里省略掉这部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取support，会注册SCC</span></span><br><span class="line">    <span class="comment">// Initialize chaincode service</span></span><br><span class="line">    chaincodeSupport, ccp, sccp, packageProvider := startChaincodeServer(peerHost, aclProvider, pr, opsSystem)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">    <span class="comment">// deploy system chaincodes</span></span><br><span class="line">	sccp.DeploySysCCs(<span class="string">&quot;&quot;</span>, ccp)</span><br><span class="line">	logger.Infof(<span class="string">&quot;Deployed system chaincodes&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册SCC"><a href="#注册SCC" class="headerlink" title="注册SCC"></a>注册SCC</h2><p>注册SCC的流程：</p>
<p>peer.node -&gt; core.scc -&gt; core.container</p>
<h3 id="peer-node"><a href="#peer-node" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startChaincodeServer will finish chaincode related initialization, including:</span></span><br><span class="line"><span class="comment">// 1) setup local chaincode install path</span></span><br><span class="line"><span class="comment">// 2) create chaincode specific tls CA</span></span><br><span class="line"><span class="comment">// 3) start the chaincode specific gRPC listening service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startChaincodeServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	peerHost <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider, *persistence.PackageProvider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 会注册SCC</span></span><br><span class="line">	chaincodeSupport, ccp, sccp := registerChaincodeSupport(</span><br><span class="line">		ccSrv,</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		ca,</span><br><span class="line">		packageProvider,</span><br><span class="line">		aclProvider,</span><br><span class="line">		pr,</span><br><span class="line">		lifecycleSCC,</span><br><span class="line">		ops,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">go</span> ccSrv.Start()</span><br><span class="line">	<span class="keyword">return</span> chaincodeSupport, ccp, sccp, packageProvider</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">	packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// SCC的VM provider</span></span><br><span class="line">	ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建SCC provider</span></span><br><span class="line">	sccp := scc.NewProvider(peer.Default, peer.DefaultSupport, ipRegistry)</span><br><span class="line">	<span class="comment">// 创建lscc实例</span></span><br><span class="line">    lsccInst := lscc.New(sccp, aclProvider, pr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">	dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">		viper.GetString(<span class="string">&quot;peer.id&quot;</span>),</span><br><span class="line">		viper.GetString(<span class="string">&quot;peer.networkId&quot;</span>),</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">	dockerVM := dockercontroller.NewDockerVM(</span><br><span class="line">		dockerProvider.PeerID,</span><br><span class="line">		dockerProvider.NetworkID,</span><br><span class="line">		dockerProvider.BuildMetrics,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">		chaincode.GlobalConfig(),</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		userRunsCC,</span><br><span class="line">		ca.CertBytes(),</span><br><span class="line">		authenticator,</span><br><span class="line">		packageProvider,</span><br><span class="line">		lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">		aclProvider,</span><br><span class="line">		container.NewVMController(</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">				dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">				inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">		sccp,</span><br><span class="line">		pr,</span><br><span class="line">		peer.DefaultSupport,</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">	ipRegistry.ChaincodeSupport = chaincodeSupport</span><br><span class="line">	<span class="comment">// chaincode provider，可以用来创建cscc</span></span><br><span class="line">	ccp := chaincode.NewProvider(chaincodeSupport)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建cscc、qscc</span></span><br><span class="line">	csccInst := cscc.New(ccp, sccp, aclProvider)</span><br><span class="line">	qsccInst := qscc.New(aclProvider)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Now that chaincode is initialized, register all system chaincodes.</span></span><br><span class="line">	sccs := scc.CreatePluginSysCCs(sccp)</span><br><span class="line">	<span class="comment">// 加入lscc、cscc、qscc</span></span><br><span class="line">	<span class="comment">// lifecycleSCC在1.4中disable了</span></span><br><span class="line">	<span class="comment">// sccs是用户自定义的系统链码</span></span><br><span class="line">	<span class="keyword">for</span> _, cc := <span class="keyword">range</span> <span class="built_in">append</span>([]scc.SelfDescribingSysCC&#123;lsccInst, csccInst, qsccInst, lifecycleSCC&#125;, sccs...) &#123;</span><br><span class="line">		<span class="comment">// 注册每一个SCC</span></span><br><span class="line">		sccp.RegisterSysCC(cc)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> chaincodeSupport, ccp, sccp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-scc"><a href="#core-scc" class="headerlink" title="core.scc"></a>core.scc</h3><p>注册某1个系统合约。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provider implements sysccprovider.SystemChaincodeProvider</span></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">	Peer        peer.Operations</span><br><span class="line">	PeerSupport peer.Support</span><br><span class="line">	Registrar   Registrar             <span class="comment">// 注册</span></span><br><span class="line">	SysCCs      []SelfDescribingSysCC <span class="comment">// 注册的scc，包含失败的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterSysCC registers a system chaincode with the syscc provider.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">RegisterSysCC</span><span class="params">(scc SelfDescribingSysCC)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 收集/注册scc到scc provider</span></span><br><span class="line">	p.SysCCs = <span class="built_in">append</span>(p.SysCCs, scc)</span><br><span class="line">	_, err := p.registerSysCC(scc)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		sysccLogger.Panicf(<span class="string">&quot;Could not register system chaincode: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// registerSysCC registers the given system chaincode with the peer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">registerSysCC</span><span class="params">(syscc SelfDescribingSysCC)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检测该scc是否开启或不在白名单</span></span><br><span class="line">	<span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">		sysccLogger.Info(fmt.Sprintf(<span class="string">&quot;system chaincode (%s,%s,%t) disabled&quot;</span>, syscc.Name(), syscc.Path(), syscc.Enabled()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">	version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cc的描述信息</span></span><br><span class="line">	ccid := &amp;ccintf.CCID&#123;</span><br><span class="line">		Name:    syscc.Name(),</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册scc的chaincode</span></span><br><span class="line">	err := p.Registrar.Register(ccid, syscc.Chaincode())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//if the type is registered, the instance may not be... keep going</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(inproccontroller.SysCCRegisteredErr); !ok &#123;</span><br><span class="line">			errStr := fmt.Sprintf(<span class="string">&quot;could not register (%s,%v): %s&quot;</span>, syscc.Path(), syscc, err)</span><br><span class="line">			sysccLogger.Error(errStr)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(errStr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sysccLogger.Infof(<span class="string">&quot;system chaincode %s(%s) registered&quot;</span>, syscc.Name(), syscc.Path())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Registrar provides a way for system chaincodes to be registered</span></span><br><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Register registers a system chaincode</span></span><br><span class="line">	Register(ccid *ccintf.CCID, cc shim.Chaincode) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-container"><a href="#core-container" class="headerlink" title="core.container"></a>core.container</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register registers system chaincode with given path. The deploy should be called to initialize</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">Register</span><span class="params">(ccid *ccintf.CCID, cc shim.Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	r.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册系统链码</span></span><br><span class="line">	name := ccid.GetName()</span><br><span class="line">	inprocLogger.Debugf(<span class="string">&quot;Registering chaincode instance: %s&quot;</span>, name)</span><br><span class="line">	tmp := r.typeRegistry[name]</span><br><span class="line">	<span class="keyword">if</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SysCCRegisteredErr(name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.typeRegistry[name] = &amp;inprocContainer&#123;chaincode: cc&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Registry stores registered system chaincodes.</span></span><br><span class="line"><span class="comment">// It implements container.VMProvider and scc.Registrar</span></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">	mutex        sync.Mutex</span><br><span class="line">	typeRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 已注册链码映射</span></span><br><span class="line">	instRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 链码示例映射</span></span><br><span class="line"></span><br><span class="line">	ChaincodeSupport ccintf.CCSupport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="部署SCC"><a href="#部署SCC" class="headerlink" title="部署SCC"></a>部署SCC</h2><p>部署SCC的流程：</p>
<p>peer.node -&gt; core.scc -&gt; core.chaincode -&gt; core.container</p>
<h3 id="peer-node-1"><a href="#peer-node-1" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">	<span class="comment">// deploy system chaincodes</span></span><br><span class="line">	sccp.DeploySysCCs(<span class="string">&quot;&quot;</span>, ccp)</span><br><span class="line">    logger.Infof(<span class="string">&quot;Deployed system chaincodes&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-scc-1"><a href="#core-scc-1" class="headerlink" title="core.scc"></a>core.scc</h3><p><code>DeploySysCCs</code>会为chainID对应的channel，部署注册过程中收集的每一个SCC，它们在<code>p.SysCCs</code>中。</p>
<p>部署链码实际是一笔交易，为了复用普通链码的部署流程，core.scc使用<code>deploySysCC</code>封装部署链码需要的参数，链码是实际部署，走core.chaincode流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DeploySysCCs is the hook for system chaincodes where system chaincodes are registered with the fabric</span></span><br><span class="line"><span class="comment">//note the chaincode must still be deployed and launched like a user chaincode will be</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">DeploySysCCs</span><span class="params">(chainID <span class="keyword">string</span>, ccp ccprovider.ChaincodeProvider)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 部署每一个scc</span></span><br><span class="line">	<span class="keyword">for</span> _, sysCC := <span class="keyword">range</span> p.SysCCs &#123;</span><br><span class="line">		deploySysCC(chainID, ccp, sysCC)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deploySysCC deploys the given system chaincode on a chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deploySysCC</span><span class="params">(chainID <span class="keyword">string</span>, ccprov ccprovider.ChaincodeProvider, syscc SelfDescribingSysCC)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// disable或不在白名单的scc不执行部署</span></span><br><span class="line">	<span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">		sysccLogger.Info(fmt.Sprintf(<span class="string">&quot;system chaincode (%s,%s) disabled&quot;</span>, syscc.Name(), syscc.Path()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为scc生成txid，因为部署链码的过程需要txParams，与普通链码的流程相同</span></span><br><span class="line">	txid := util.GenerateUUID()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note, this structure is barely initialized,</span></span><br><span class="line">	<span class="comment">// we omit the history query executor, the proposal</span></span><br><span class="line">	<span class="comment">// and the signed proposal</span></span><br><span class="line">	txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">		TxID:      txid,</span><br><span class="line">		ChannelID: chainID,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置交易执行模拟器，系统通道chainID为&quot;&quot;，所以系统通道的scc没有模拟器</span></span><br><span class="line">	<span class="keyword">if</span> chainID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 获取链/通道的账本</span></span><br><span class="line">		lgr := peer.GetLedger(chainID)</span><br><span class="line">		<span class="keyword">if</span> lgr == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;syschain %s start up failure - unexpected nil ledger for channel %s&quot;</span>, syscc.Name(), chainID))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据交易id创建链码模拟器</span></span><br><span class="line">		txsim, err := lgr.NewTxSimulator(txid)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指定链码执行模拟器</span></span><br><span class="line">		txParams.TXSimulator = txsim</span><br><span class="line">		<span class="keyword">defer</span> txsim.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Path: syscc.Path(), Name: syscc.Name()&#125;</span><br><span class="line">	spec := &amp;pb.ChaincodeSpec&#123;Type: pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[<span class="string">&quot;GOLANG&quot;</span>]), ChaincodeId: chaincodeID, Input: &amp;pb.ChaincodeInput&#123;Args: syscc.InitArgs()&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ChaincodeDeploymentSpec_SYSTEM标明：部署SCC</span></span><br><span class="line">	chaincodeDeploymentSpec := &amp;pb.ChaincodeDeploymentSpec&#123;ExecEnv: pb.ChaincodeDeploymentSpec_SYSTEM, ChaincodeSpec: spec&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">	version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">	cccid := &amp;ccprovider.CCContext&#123;</span><br><span class="line">		Name:    chaincodeDeploymentSpec.ChaincodeSpec.ChaincodeId.Name,</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 部署SCC</span></span><br><span class="line">	resp, _, err := ccprov.ExecuteLegacyInit(txParams, cccid, chaincodeDeploymentSpec)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; resp.Status != shim.OK &#123;</span><br><span class="line">		err = errors.New(resp.Message)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sysccLogger.Infof(<span class="string">&quot;system chaincode %s/%s(%s) deployed&quot;</span>, syscc.Name(), chainID, syscc.Path())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeProvider provides an abstraction layer that is</span></span><br><span class="line"><span class="comment">// used for different packages to interact with code in the</span></span><br><span class="line"><span class="comment">// chaincode package without importing it; more methods</span></span><br><span class="line"><span class="comment">// should be added below if necessary</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeProvider <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Execute executes a standard chaincode invocation for a chaincode and an input</span></span><br><span class="line">	Execute(txParams *TransactionParams, cccid *CCContext, input *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line">	<span class="comment">// ExecuteLegacyInit is a special case for executing chaincode deployment specs,</span></span><br><span class="line">	<span class="comment">// which are not already in the LSCC, needed for old lifecycle</span></span><br><span class="line">	ExecuteLegacyInit(txParams *TransactionParams, cccid *CCContext, spec *pb.ChaincodeDeploymentSpec) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line">	<span class="comment">// Stop stops the chaincode give</span></span><br><span class="line">	Stop(ccci *ChaincodeContainerInfo) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-chaincode"><a href="#core-chaincode" class="headerlink" title="core.chaincode"></a>core.chaincode</h3><p><code>CCProviderImpl</code>实现了<code>ChaincodeProvider</code>接口，可以用来部署链码，<code>ExecuteLegacyInit</code>会执行2项：</p>
<ol>
<li>启动链码容器</li>
<li>执行链码Init函数，链码容器启动后，peer和链码容器通过消息通信，<code>ChaincodeMessage_INIT</code>是执行链码容器的Init函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecuteLegacyInit executes a chaincode which is not in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CCProviderImpl)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.cs.ExecuteLegacyInit(txParams, cccid, spec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecuteLegacyInit is a temporary method which should be removed once the old style lifecycle</span></span><br><span class="line"><span class="comment">// is entirely deprecated.  Ideally one release after the introduction of the new lifecycle.</span></span><br><span class="line"><span class="comment">// It does not attempt to start the chaincode based on the information from lifecycle, but instead</span></span><br><span class="line"><span class="comment">// accepts the container information directly in the form of a ChaincodeDeploymentSpec.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 部署链码需要的信息</span></span><br><span class="line">    ccci := ccprovider.DeploymentSpecToChaincodeContainerInfo(spec)</span><br><span class="line">	ccci.Version = cccid.Version</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动容器</span></span><br><span class="line">	err := cs.LaunchInit(ccci)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cname := ccci.Name + <span class="string">&quot;:&quot;</span> + ccci.Version</span><br><span class="line">	h := cs.HandlerRegistry.Handler(cname)</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;[channel %s] claimed to start chaincode container for %s but could not find handler&quot;</span>, txParams.ChannelID, cname)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用链码Init</span></span><br><span class="line">	resp, err := cs.execute(pb.ChaincodeMessage_INIT, txParams, cccid, spec.GetChaincodeSpec().Input, h)</span><br><span class="line">	<span class="keyword">return</span> processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LaunchInit</code>是启动容器的一层检查，实际启动由<code>Launcher.Launch</code>完成。启动链码容器是异步的，会创建单独的goroutine去执行。</p>
<p>core.chaincode使用<code>Runtime</code>接口操控链码容器的启停。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaunchInit bypasses getting the chaincode spec from the LSCC table</span></span><br><span class="line"><span class="comment">// as in the case of v1.0-v1.2 lifecycle, the chaincode will not yet be</span></span><br><span class="line"><span class="comment">// defined in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">LaunchInit</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cname := ccci.Name + <span class="string">&quot;:&quot;</span> + ccci.Version</span><br><span class="line">	<span class="comment">// 已经有handler，即容器已经启动。调用链码的时候，也会获取handler</span></span><br><span class="line">	<span class="keyword">if</span> cs.HandlerRegistry.Handler(cname) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则启动容器，设置handler</span></span><br><span class="line">	<span class="keyword">return</span> cs.Launcher.Launch(ccci)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RuntimeLauncher)</span> <span class="title">Launch</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> startFailCh <span class="keyword">chan</span> error</span><br><span class="line">	<span class="keyword">var</span> timeoutCh &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	cname := ccci.Name + <span class="string">&quot;:&quot;</span> + ccci.Version</span><br><span class="line">	launchState, alreadyStarted := r.Registry.Launching(cname)</span><br><span class="line">	<span class="comment">// 链码容器未启动，启动容器</span></span><br><span class="line">	<span class="keyword">if</span> !alreadyStarted &#123;</span><br><span class="line">		startFailCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">		timeoutCh = time.NewTimer(r.StartupTimeout).C</span><br><span class="line"></span><br><span class="line">		codePackage, err := r.getCodePackage(ccci)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 启动容器</span></span><br><span class="line">			<span class="keyword">if</span> err := r.Runtime.Start(ccci, codePackage); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				startFailCh &lt;- errors.WithMessage(err, <span class="string">&quot;error starting container&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			exitCode, err := r.Runtime.Wait(ccci)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				launchState.Notify(errors.Wrap(err, <span class="string">&quot;failed to wait on container exit&quot;</span>))</span><br><span class="line">			&#125;</span><br><span class="line">			launchState.Notify(errors.Errorf(<span class="string">&quot;container exited with %d&quot;</span>, exitCode))</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime is used to manage chaincode runtime instances.</span></span><br><span class="line"><span class="keyword">type</span> Runtime <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>) error</span><br><span class="line">	Stop(ccci *ccprovider.ChaincodeContainerInfo) error</span><br><span class="line">	Wait(ccci *ccprovider.ChaincodeContainerInfo) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>ContainerRuntime</code>是core.chaincode封装出来和core.container交互的，在这里它会创建启动链码请求，交给container。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start launches chaincode in a runtime environment.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ContainerRuntime)</span> <span class="title">Start</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cname := ccci.Name + <span class="string">&quot;:&quot;</span> + ccci.Version</span><br><span class="line"></span><br><span class="line">	lc, err := c.LaunchConfig(cname, ccci.Type)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;start container: %s&quot;</span>, cname)</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;start container with args: %s&quot;</span>, strings.Join(lc.Args, <span class="string">&quot; &quot;</span>))</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;start container with env:\n\t%s&quot;</span>, strings.Join(lc.Envs, <span class="string">&quot;\n\t&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动链码的请求</span></span><br><span class="line">	scr := container.StartContainerReq&#123;</span><br><span class="line">		Builder: &amp;container.PlatformBuilder&#123;</span><br><span class="line">			Type:             ccci.Type,</span><br><span class="line">			Name:             ccci.Name,</span><br><span class="line">			Version:          ccci.Version,</span><br><span class="line">			Path:             ccci.Path,</span><br><span class="line">			CodePackage:      codePackage,</span><br><span class="line">			PlatformRegistry: c.PlatformRegistry,</span><br><span class="line">		&#125;,</span><br><span class="line">		Args:          lc.Args,</span><br><span class="line">		Env:           lc.Envs,</span><br><span class="line">		FilesToUpload: lc.Files,</span><br><span class="line">		CCID: ccintf.CCID&#123;</span><br><span class="line">			Name:    ccci.Name,</span><br><span class="line">			Version: ccci.Version,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理容器操作请求</span></span><br><span class="line">	<span class="keyword">if</span> err := c.Processor.Process(ccci.ContainerType, scr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;error starting container&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor processes vm and container requests.</span></span><br><span class="line"><span class="keyword">type</span> Processor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Process(vmtype <span class="keyword">string</span>, req container.VMCReq) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-container-1"><a href="#core-container-1" class="headerlink" title="core.container"></a>core.container</h3><p><code>VMController</code>实现了Processor，它会按指定的类型建立虚拟机，明明就是容器，为啥内部又叫VM，VM有2种：</p>
<ol>
<li>InprocVM，意思是运行在单独进程中的虚拟机，但不是指操作系统的进程，而是指一个隔离的环境，SCC是这类。</li>
<li>DockerVM，指利用Docker启动的容器，普通链码就是这类。</li>
</ol>
<p>类型是存在<code>ccci.ContainerType</code>中的，<code>ccci</code>包含了部署链码所需要的信息，这个信息在core.chaincode很早就获取到了，可以往前翻。</p>
<p><code>Process</code>就是创建VM，然后利用VM处理请求的过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据请求对VM进行某种操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">Process</span><span class="params">(vmtype <span class="keyword">string</span>, req VMCReq)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建vm</span></span><br><span class="line">	v := vmc.newVM(vmtype)</span><br><span class="line">	ccid := req.GetCCID()</span><br><span class="line">	id := ccid.GetName()</span><br><span class="line"></span><br><span class="line">	vmc.lockContainer(id)</span><br><span class="line">	<span class="keyword">defer</span> vmc.unlockContainer(id)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把vm传递给请求，即用该vm执行请求内容</span></span><br><span class="line">	<span class="keyword">return</span> req.Do(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用指定类型的vm provider创建vm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">newVM</span><span class="params">(typ <span class="keyword">string</span>)</span> <span class="title">VM</span></span> &#123;</span><br><span class="line">	v, ok := vmc.vmProviders[typ]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		vmLogger.Panicf(<span class="string">&quot;Programming error: unsupported VM type: %s&quot;</span>, typ)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.NewVM()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewVMController creates a new instance of VMController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVMController</span><span class="params">(vmProviders <span class="keyword">map</span>[<span class="keyword">string</span>]VMProvider)</span> *<span class="title">VMController</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;VMController&#123;</span><br><span class="line">		containerLocks: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*refCountedLock),</span><br><span class="line">		vmProviders:    vmProviders,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建VM需要使用<code>NewVMController</code>，回过去找它的创建地方。</p>
<p>在注册SCC的过程中，调用<code>registerChaincodeSupport</code>创建了<code>chaincodeSupport</code>，其中一个字段为创建<code>NewVMController</code>，就包含了2类Vm provider：</p>
<ol>
<li>ipRegistry，SCC的</li>
<li>dockerProvider，普通链码的</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">	packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// SCC的VM provider</span></span><br><span class="line">	ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">	dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">		viper.GetString(<span class="string">&quot;peer.id&quot;</span>),</span><br><span class="line">		viper.GetString(<span class="string">&quot;peer.networkId&quot;</span>),</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">		chaincode.GlobalConfig(),</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		userRunsCC,</span><br><span class="line">		ca.CertBytes(),</span><br><span class="line">		authenticator,</span><br><span class="line">		packageProvider,</span><br><span class="line">		lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">		aclProvider,</span><br><span class="line">        <span class="comment">// 创建了VM controller，controller提供了inproc和docker 2中子controller，</span></span><br><span class="line">		<span class="comment">// 即2中链码运行方式</span></span><br><span class="line">		container.NewVMController(</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">				dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">				inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">		sccp,</span><br><span class="line">		pr,</span><br><span class="line">		peer.DefaultSupport,</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VM处理操作虚拟机的请求"><a href="#VM处理操作虚拟机的请求" class="headerlink" title="VM处理操作虚拟机的请求"></a>VM处理操作虚拟机的请求</h4><p>core.container的请求，都实现了<code>VMCReq</code>接口，StartContainerReq、StopContainerReq、WaitContainerReq是实现VMCReq的3类请求。</p>
<p>启动实际是启动虚拟机接口，处理请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VMCReq - all requests should implement this interface.</span></span><br><span class="line"><span class="comment">//The context should be passed and tested at each layer till we stop</span></span><br><span class="line"><span class="comment">//note that we&#x27;d stop on the first method on the stack that does not</span></span><br><span class="line"><span class="comment">//take context</span></span><br><span class="line"><span class="keyword">type</span> VMCReq <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(v VM) error</span><br><span class="line">	GetCCID() ccintf.CCID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si StartContainerReq)</span> <span class="title">Do</span><span class="params">(v VM)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.Start(si.CCID, si.Args, si.Env, si.FilesToUpload, si.Builder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VM is an abstract virtual image for supporting arbitrary virual machines</span></span><br><span class="line"><span class="keyword">type</span> VM <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder Builder) error</span><br><span class="line">	Stop(ccid ccintf.CCID, timeout <span class="keyword">uint</span>, dontkill <span class="keyword">bool</span>, dontremove <span class="keyword">bool</span>) error</span><br><span class="line">	Wait(ccid ccintf.CCID) (<span class="keyword">int</span>, error)</span><br><span class="line">	HealthCheck(context.Context) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DockerVM和InprocVM都实现了VM接口，本文只关注InprocVM类型，即SCC的。</p>
<p>InprocVM会得到一个容器实例ipc，用它来运行SCC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Start starts a previously registered system codechain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *InprocVM)</span> <span class="title">Start</span><span class="params">(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder container.Builder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	path := ccid.GetName()</span><br><span class="line"></span><br><span class="line">	ipctemplate := vm.registry.getType(path)</span><br><span class="line">	<span class="keyword">if</span> ipctemplate == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">&quot;%s not registered&quot;</span>, path))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 即ccid.Name</span></span><br><span class="line">	instName := vm.GetVMName(ccid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取容器实例</span></span><br><span class="line">	ipc, err := vm.getInstance(ipctemplate, instName, args, env)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">&quot;could not create instance for %s&quot;</span>, instName))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已经在运行了，还部署个啥！</span></span><br><span class="line">	<span class="keyword">if</span> ipc.running &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">&quot;chaincode running %s&quot;</span>, path))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc.running = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">				inprocLogger.Criticalf(<span class="string">&quot;caught panic from chaincode  %s&quot;</span>, instName)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">// 启动进程级容器</span></span><br><span class="line">		ipc.launchInProc(instName, args, env)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inprocContainer</code>开启2个goroutine：</p>
<ol>
<li>第一个调用<code>shimStartInProc</code>，即利用core.chaincode.shim启动InProc类型的容器。</li>
<li>第二个调用<code>HandleChaincodeStream</code>，处理peer和Inproc容器间的通信数据，此处的stream是peer端的。</li>
</ol>
<p>这里可以看到创建了2个通道<code>peerRcvCCSend</code>和<code>ccRcvPeerSend</code>，它们表明了peer和scc的链码容器是通过通道直接通信的。peer和docker链码容器之间是走gRPC通信的，这个到普通链码的时候再介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从进程启动链码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ipc *inprocContainer)</span> <span class="title">launchInProc</span><span class="params">(id <span class="keyword">string</span>, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ipc.ChaincodeSupport == <span class="literal">nil</span> &#123;</span><br><span class="line">		inprocLogger.Panicf(<span class="string">&quot;Chaincode support is nil, most likely you forgot to set it immediately after calling inproccontroller.NewRegsitry()&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 和调用链码的上层通信的2个通道</span></span><br><span class="line">	peerRcvCCSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">	ccRcvPeerSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	ccchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	ccsupportchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	shimStartInProc := _shimStartInProc <span class="comment">// shadow to avoid race in test</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ccchan)</span><br><span class="line">		<span class="comment">// 启动链码</span></span><br><span class="line">		inprocLogger.Debugf(<span class="string">&quot;chaincode started for %s&quot;</span>, id)</span><br><span class="line">		<span class="keyword">if</span> args == <span class="literal">nil</span> &#123;</span><br><span class="line">			args = ipc.args</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> env == <span class="literal">nil</span> &#123;</span><br><span class="line">			env = ipc.env</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用shim启动</span></span><br><span class="line">		err := shimStartInProc(env, args, ipc.chaincode, ccRcvPeerSend, peerRcvCCSend)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;chaincode-support ended with err: %s&quot;</span>, err)</span><br><span class="line">			_inprocLoggerErrorf(<span class="string">&quot;%s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		inprocLogger.Debugf(<span class="string">&quot;chaincode ended for %s with err: %s&quot;</span>, id, err)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shadow function to avoid data race</span></span><br><span class="line">	inprocLoggerErrorf := _inprocLoggerErrorf</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ccsupportchan)</span><br><span class="line">		<span class="comment">// 处理scc和外部通信的消息流</span></span><br><span class="line">		inprocStream := newInProcStream(peerRcvCCSend, ccRcvPeerSend)</span><br><span class="line">		inprocLogger.Debugf(<span class="string">&quot;chaincode-support started for  %s&quot;</span>, id)</span><br><span class="line">		err := ipc.ChaincodeSupport.HandleChaincodeStream(inprocStream)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;chaincode ended with err: %s&quot;</span>, err)</span><br><span class="line">			inprocLoggerErrorf(<span class="string">&quot;%s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		inprocLogger.Debugf(<span class="string">&quot;chaincode-support ended for %s with err: %s&quot;</span>, id, err)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用shim启动Inproc链码容器中的程序"><a href="#利用shim启动Inproc链码容器中的程序" class="headerlink" title="利用shim启动Inproc链码容器中的程序"></a>利用shim启动Inproc链码容器中的程序</h4><p>shim是chaincode提供给容器，运行链码的工具，它运行在容器里。</p>
<p>利用shim启动InprocVM使用的函数是<code>StartInProc</code>，提取一些<strong>运行链码</strong>需要的数据，比如又一个stream，此处的stream是容器端的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动SCC的入口</span></span><br><span class="line"><span class="comment">// StartInProc is an entry point for system chaincodes bootstrap. It is not an</span></span><br><span class="line"><span class="comment">// API for chaincodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartInProc</span><span class="params">(env []<span class="keyword">string</span>, args []<span class="keyword">string</span>, cc Chaincode, recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 有点奇怪，这些日志都没有看到，因为已经在shim，不属于peer日志了</span></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;in proc %v&quot;</span>, args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从环境变量获取cc name</span></span><br><span class="line">	<span class="keyword">var</span> chaincodename <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> env &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Index(v, <span class="string">&quot;CORE_CHAINCODE_ID_NAME=&quot;</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			p := strings.SplitAfter(v, <span class="string">&quot;CORE_CHAINCODE_ID_NAME=&quot;</span>)</span><br><span class="line">			chaincodename = p[<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> chaincodename == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;error chaincode id not provided&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建peer和chaincode通信的通道</span></span><br><span class="line">	stream := newInProcStream(recv, send)</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;starting chat with peer using name=%s&quot;</span>, chaincodename)</span><br><span class="line">	<span class="comment">// 与peer进行通信</span></span><br><span class="line">	err := chatWithPeer(chaincodename, stream, cc)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>chatWithPeer</code>是通用的，普通的链码也调用这个程序。它创建了一个handler，用来处理消息（发送和接收），以及操作（调用）链码。</p>
<p>这个过程，它会向peer发送REGISTER消息，和peer先“握手”，也会从peer读消息，消息的处理函数就是里面的for循环，这样链码容器就运行起来了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用，SCC和CC都使用这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chatWithPeer</span><span class="params">(chaincodename <span class="keyword">string</span>, stream PeerChaincodeStream, cc Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 把stream和cc交给handler，handler可以发送和接收数据，即读写通道</span></span><br><span class="line">	<span class="comment">// Create the shim handler responsible for all control logic</span></span><br><span class="line">	handler := newChaincodeHandler(stream, cc)</span><br><span class="line">	<span class="keyword">defer</span> stream.CloseSend()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the ChaincodeID during register.</span></span><br><span class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Name: chaincodename&#125;</span><br><span class="line">	payload, err := proto.Marshal(chaincodeID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;error marshalling chaincodeID during chaincode registration&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在stream上向peer发送注册消息</span></span><br><span class="line">	<span class="comment">// Register on the stream</span></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;Registering.. sending %s&quot;</span>, pb.ChaincodeMessage_REGISTER)</span><br><span class="line">	<span class="keyword">if</span> err = handler.serialSend(&amp;pb.ChaincodeMessage&#123;Type: pb.ChaincodeMessage_REGISTER, Payload: payload&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;error sending chaincode REGISTER&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// holds return values from gRPC Recv below</span></span><br><span class="line">	<span class="keyword">type</span> recvMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">		msg *pb.ChaincodeMessage</span><br><span class="line">		err error</span><br><span class="line">	&#125;</span><br><span class="line">	msgAvail := <span class="built_in">make</span>(<span class="keyword">chan</span> *recvMsg, <span class="number">1</span>)</span><br><span class="line">	errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line">	receiveMessage := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		msgAvail &lt;- &amp;recvMsg&#123;in, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步读取1个消息</span></span><br><span class="line">	<span class="keyword">go</span> receiveMessage()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环处理peer发送的消息</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rmsg := &lt;-msgAvail:</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> rmsg.err == io.EOF:</span><br><span class="line">				err = errors.Wrapf(rmsg.err, <span class="string">&quot;received EOF, ending chaincode stream&quot;</span>)</span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">&quot;%+v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">case</span> rmsg.err != <span class="literal">nil</span>:</span><br><span class="line">				err := errors.Wrap(rmsg.err, <span class="string">&quot;receive failed&quot;</span>)</span><br><span class="line">				chaincodeLogger.Errorf(<span class="string">&quot;Received error from server, ending chaincode stream: %+v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">case</span> rmsg.msg == <span class="literal">nil</span>:</span><br><span class="line">				err := errors.New(<span class="string">&quot;received nil message, ending chaincode stream&quot;</span>)</span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">&quot;%+v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 处理消息</span></span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">&quot;[%s]Received message %s from peer&quot;</span>, shorttxid(rmsg.msg.Txid), rmsg.msg.Type)</span><br><span class="line">				err := handler.handleMessage(rmsg.msg, errc)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					err = errors.WithMessage(err, <span class="string">&quot;error handling message&quot;</span>)</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 读取下一个消息</span></span><br><span class="line">				<span class="keyword">go</span> receiveMessage()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> sendErr := &lt;-errc:</span><br><span class="line">			<span class="keyword">if</span> sendErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				err := errors.Wrap(sendErr, <span class="string">&quot;error sending&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的消息处理函数，先跳过，回过头来，关注scc容器和peer的通信。</p>
<h4 id="SCC和Peer的通信通道"><a href="#SCC和Peer的通信通道" class="headerlink" title="SCC和Peer的通信通道"></a>SCC和Peer的通信通道</h4><p>链码容器和Peer之间使用Stream进行通信，Stream有2种实现：</p>
<ol>
<li>使用channel封装的Stream</li>
<li>gRPC的Stream</li>
</ol>
<p><img src="https://lessisbetter.site/images/2019-09-peer-cc-communication.png"></p>
<p>链码容器和Peer通信的接口是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> PeerChaincodeStream <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*pb.ChaincodeMessage) error</span><br><span class="line">	Recv() (*pb.ChaincodeMessage, error)</span><br><span class="line">	CloseSend() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通链码使用gRPC：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chaincodeSupportRegisterClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统链码直接使用通道通信，发送和接收消息都在下面了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer和chaincode之间通信的通道</span></span><br><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> inProcStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage</span><br><span class="line">	send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInProcStream</span><span class="params">(recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> *<span class="title">inProcStream</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;inProcStream&#123;recv, send&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送其实就是向send写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Send</span><span class="params">(msg *pb.ChaincodeMessage)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	err = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//send may happen on a closed channel when the system is</span></span><br><span class="line">	<span class="comment">//shutting down. Just catch the exception and return error</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = SendPanicFailure(fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, r))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	s.send &lt;- msg</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收是从recv读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Recv</span><span class="params">()</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	msg, ok := &lt;-s.recv</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;channel is closed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">CloseSend</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实际啥也没做</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Peer和链码容器的交互，完成链码容器启动"><a href="#Peer和链码容器的交互，完成链码容器启动" class="headerlink" title="Peer和链码容器的交互，完成链码容器启动"></a>Peer和链码容器的交互，完成链码容器启动</h3><p>部署链码需要Peer和链码容器交互，不然Peer怎么知道链码容器已经启动。以下是一份peer的DEBUG日志，在下面标注了启动容器和链码Init过程中的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] LaunchConfig -&gt; DEBU 098 launchConfig: executable:&quot;chaincode&quot;,Args:[chaincode,-peer.address&#x3D;peer0.org1.example.com:7052],Envs:[CORE_CHAINCODE_LOGGING_LEVEL&#x3D;info,CORE_CHAINCODE_LOGGING_SHIM&#x3D;warning,CORE_CHAINCODE_LOGGING_FORMAT&#x3D;%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;,CORE_CHAINCODE_ID_NAME&#x3D;lscc:1.4.3,CORE_PEER_TLS_ENABLED&#x3D;true,CORE_TLS_CLIENT_KEY_PATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.key,CORE_TLS_CLIENT_CERT_PATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.crt,CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;peer.crt],Files:[&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.crt &#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.key &#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;peer.crt]</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 099 start container: lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09a start container with args: chaincode -peer.address&#x3D;peer0.org1.example.com:7052</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09b start container with env:</span><br><span class="line">	CORE_CHAINCODE_LOGGING_LEVEL&#x3D;info</span><br><span class="line">	CORE_CHAINCODE_LOGGING_SHIM&#x3D;warning</span><br><span class="line">	CORE_CHAINCODE_LOGGING_FORMAT&#x3D;%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;</span><br><span class="line">	CORE_CHAINCODE_ID_NAME&#x3D;lscc:1.4.3</span><br><span class="line">	CORE_PEER_TLS_ENABLED&#x3D;true</span><br><span class="line">	CORE_TLS_CLIENT_KEY_PATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.key</span><br><span class="line">	CORE_TLS_CLIENT_CERT_PATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.crt</span><br><span class="line">	CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;peer.crt</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09c waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09d got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] getInstance -&gt; DEBU 09e chaincode instance created for lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 09f container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a0 waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a1 got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 0a2 container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func2 -&gt; DEBU 0a3 chaincode-support started for  lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func1 -&gt; DEBU 0a4 chaincode started for lscc-1.4.3</span><br><span class="line">&#x2F;&#x2F; 以上日志对应的代码流程在上文都讲到了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下是交互过程peer日志</span><br><span class="line">&#x2F;&#x2F; peer收到容器的注册消息</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] handleMessage -&gt; DEBU 0a5 [] Fabric side handling ChaincodeMessage of type: REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a6 Received REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] Register -&gt; DEBU 0a7 registered handler complete for chaincode lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a8 Got REGISTER for chaincodeID &#x3D; name:&quot;lscc:1.4.3&quot; , sending back REGISTERED</span><br><span class="line">2019-09-09 07:52:09.920 UTC [grpc] HandleSubConnStateChange -&gt; DEBU 0a9 pickfirstBalancer: HandleSubConnStateChange: 0xc0026318c0, READY</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] HandleRegister -&gt; DEBU 0aa Changed state to established for name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; peer发送ready消息</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ab sending READY for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ac Changed to state ready for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 已经完成启动容器</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] Launch -&gt; DEBU 0ad launch complete</span><br><span class="line">2019-09-09 07:52:09.924 UTC [chaincode] Execute -&gt; DEBU 0ae Entry</span><br><span class="line">&#x2F;&#x2F; 收到容器COMPLETED消息</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] handleMessage -&gt; DEBU 0af [01b03aae] Fabric side handling ChaincodeMessage of type: COMPLETED in state ready</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通知scc，部署已经完成</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Notify -&gt; DEBU 0b0 [01b03aae] notifying Txid:01b03aae-17a6-4b63-874e-dc20d6f5df0c, channelID:</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Execute -&gt; DEBU 0b1 Exit</span><br><span class="line">2019-09-09 07:52:09.925 UTC [sccapi] deploySysCC -&gt; INFO 0b2 system chaincode lscc&#x2F;(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;lscc) deployed</span><br></pre></td></tr></table></figure>

<p>可以到REGISTER、READY、COMPLETED等消息，以及状态的改变：created、ready。</p>
<p>但前面还没有介绍Peer和链码容器之间的通信，所以不展示代码了，展示一下Peer和链码容器的消息交互图：</p>
<p><img src="https://lessisbetter.site/images/2019-09-deploycc-msg.png"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag"># 区块链</a>
              <a href="/tags/Fabric/" rel="tag"># Fabric</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/09/06/fabric-source-endorser-policy-flow/" rel="prev" title="Fabric 1.4源码解读 1：背书策略是怎么使用的">
                  <i class="fa fa-chevron-left"></i> Fabric 1.4源码解读 1：背书策略是怎么使用的
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/09/20/fabric-event-source/" rel="next" title="Fabric 1.4源码解读 3：事件(Event)原理解读">
                  Fabric 1.4源码解读 3：事件(Event)原理解读 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP </a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=18051706" rel="noopener" target="_blank">备18051706 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大彬</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  

<script src="//cdn.jsdelivr.net/npm/algoliasearch@4.8.2/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4.8.7/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>






  






<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5bfe6f6d1ad3c04f357d',
      clientSecret: 'c60d7cdad469c9afd60947dd84c0f4100874c655',
      repo        : 'shitaibin.github.io',
      owner       : 'Shitaibin',
      admin       : ['Shitaibin'],
      id          : '91c23b2180320eedadf4caf9a10d35c7',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
