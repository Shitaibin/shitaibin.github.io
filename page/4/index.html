<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lessisbetter.site","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="云原生、Go语言、区块链">
<meta property="og:type" content="website">
<meta property="og:title" content="Go语言充电站">
<meta property="og:url" content="http://lessisbetter.site/page/4/index.html">
<meta property="og:site_name" content="Go语言充电站">
<meta property="og:description" content="云原生、Go语言、区块链">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="大彬">
<meta property="article:tag" content="云原生 k8s kubernetes 区块链 Go语言 后端 技术 人生 编程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lessisbetter.site/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Go语言充电站</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Go语言充电站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大彬 less is better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li>
        <li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-专题"><a href="/subject/" rel="section"><i class="fa fa-calendar fa-fw"></i>专题</a></li>
        <li class="menu-item menu-item-大牛博客"><a href="/blogs/" rel="section"><i class="fa fa-calendar fa-fw"></i>大牛博客</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="大彬"
      src="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
  <p class="site-author-name" itemprop="name">大彬</p>
  <div class="site-description" itemprop="description">云原生、Go语言、区块链</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">138</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://xargin.com/" title="Xargin曹大博客 → https:&#x2F;&#x2F;xargin.com&#x2F;" rel="noopener" target="_blank">Xargin曹大博客</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://qcrao.github.io/" title="码农桃花源博客 → https:&#x2F;&#x2F;qcrao.github.io&#x2F;" rel="noopener" target="_blank">码农桃花源博客</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://book.eddycjy.com/golang/" title="煎鱼博客 → https:&#x2F;&#x2F;book.eddycjy.com&#x2F;golang&#x2F;" rel="noopener" target="_blank">煎鱼博客</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/11/18/fabric-orderer-structs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/18/fabric-orderer-structs/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 6：Orderer核心数据结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-18 20:45:23" itemprop="dateCreated datePublished" datetime="2019-11-18T20:45:23+08:00">2019-11-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>许多Orderer的文章，都是从Orderer的启动过程讲起，今天换一种“乐高”角度，先看看有哪些“零件”，再看这些零件怎么配合。</p>
<p>Orderer负责接收交易，把交易打包成区块，然后区块在所有Orderer节点之间达成一致，再分发给Peer的功能，这涉及了：</p>
<ul>
<li>网络：gRPC接收交易，向Peer发送区块</li>
<li>切块：把交易打包成区块</li>
<li>共识：所有Orderer节点达成一致</li>
</ul>
<p>这些功能是由Orderer核心数据结构组织起来。</p>
<blockquote>
<p>在Fabric中，通道和链在概念上都是一条区块链，所以本文中也会可能会混用链和通道。</p>
</blockquote>
<h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><h3 id="Registrar"><a href="#Registrar" class="headerlink" title="Registrar"></a>Registrar</h3><p><img src="https://lessisbetter.site/images/2019-11-orderer-registrar.png" alt="Registrar"></p>
<p>代码中，这样描述Registrar：</p>
<blockquote>
<p>Registrar serves as a point of access and control for the individual channel resources.</p>
</blockquote>
<p>可见它负责了每个channel资源的访问和控制点，也就说，要对某个通道怎么样，得从这入手。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock sync.RWMutex</span><br><span class="line">	<span class="comment">// 保存了多条链</span></span><br><span class="line">	chains <span class="keyword">map</span>[<span class="keyword">string</span>]*ChainSupport</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 共识插件</span></span><br><span class="line">	consenters         <span class="keyword">map</span>[<span class="keyword">string</span>]consensus.Consenter</span><br><span class="line">	ledgerFactory      blockledger.Factory</span><br><span class="line">	signer             crypto.LocalSigner</span><br><span class="line">    </span><br><span class="line">	systemChannelID    <span class="keyword">string</span></span><br><span class="line">	systemChannel      *ChainSupport</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>chains</code>保存了每一条链，每一条链在Orderer中都以<a href="#ChainSupport">ChainSupport</a>代表。</li>
<li><code>consenters</code>保存了所有的共识插件，每个共识插件都是一个<a href="#Consenter">Consenter</a>，Fabric 1.4中共识插件有Solo、Kafka、EtcdRaft。</li>
<li><code>ledgerFactory</code>用来读取和创建链的账本。</li>
<li><code>signer</code>用来对Orderer中的数据进行签名，以及创建<a href="http://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/#%E8%A7%A3%E5%AF%86SignatureHeader">SignatureHeader</a>。</li>
<li><code>systemChannelID</code>和<code>systemChannel</code>分别是系统链ID、系统链实例。</li>
</ul>
<h3 id="ChainSupport"><a href="#ChainSupport" class="headerlink" title="ChainSupport"></a>ChainSupport</h3><p><img src="https://lessisbetter.site/images/2019-11-orderer-chainsupport.png" alt="chainsupport"></p>
<p>ChainSupport汇集了一条通道所需要的所有资源，所以说一个ChainSupport代表了一条链。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChainSupport <span class="keyword">struct</span> &#123;</span><br><span class="line">	*ledgerResources</span><br><span class="line">	msgprocessor.Processor</span><br><span class="line">	*BlockWriter</span><br><span class="line">	consensus.Chain</span><br><span class="line">	cutter blockcutter.Receiver</span><br><span class="line">	crypto.LocalSigner</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChainSupport 是一堆接口的集合，这些接口构成一条链所有的操作，接口可以分为4类：</p>
<ul>
<li>账本：<code>ledgerResources</code>、<code>BlockWriter</code>分别是账本读写和把区块写入到账本。</li>
<li>消息：<code>msgprocessor.Processor</code>、<code>cutter</code>分别是处理交易和把交易切块。</li>
<li>共识：<code>consensus.Chain</code>是Orderer的共识实例，比如每条链都有自己的Raft共识实例，它们互不干扰。</li>
<li>签名：<code>crypto.LocalSigner</code>，同Registrar中的介绍。</li>
</ul>
<h3 id="Chain"><a href="#Chain" class="headerlink" title="Chain"></a>Chain</h3><p><img src="https://lessisbetter.site/images/2019-11-orderer-chain.png" alt="Chain"></p>
<p>Chain是接口，它的实现并不一条链，而是一条链的共识实例，可以是Solo、Kafka和EtcdRaft，它运行在单独的协程，使用Channel和ChainSupport通信，它调用其它接口完成切块，以及让所有的Orderer节点对交易达成一致。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chain defines a way to inject messages for ordering.</span></span><br><span class="line"><span class="comment">// Note, that in order to allow flexibility in the implementation, it is the responsibility of the implementer</span></span><br><span class="line"><span class="comment">// to take the ordered messages, send them through the blockcutter.Receiver supplied via HandleChain to cut blocks,</span></span><br><span class="line"><span class="comment">// and ultimately write the ledger also supplied via HandleChain.  This design allows for two primary flows</span></span><br><span class="line"><span class="comment">// 1. Messages are ordered into a stream, the stream is cut into blocks, the blocks are committed (solo, kafka)</span></span><br><span class="line"><span class="comment">// 2. Messages are cut into blocks, the blocks are ordered, then the blocks are committed (sbft)</span></span><br><span class="line"><span class="keyword">type</span> Chain <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 普通消息/交易排序</span></span><br><span class="line">	<span class="comment">// Order accepts a message which has been processed at a given configSeq.</span></span><br><span class="line">	<span class="comment">// If the configSeq advances, it is the responsibility of the consenter</span></span><br><span class="line">	<span class="comment">// to revalidate and potentially discard the message</span></span><br><span class="line">	<span class="comment">// The consenter may return an error, indicating the message was not accepted</span></span><br><span class="line">	Order(env *cb.Envelope, configSeq <span class="keyword">uint64</span>) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 配置消息/交易排序</span></span><br><span class="line">	<span class="comment">// Configure accepts a message which reconfigures the channel and will</span></span><br><span class="line">	<span class="comment">// trigger an update to the configSeq if committed.  The configuration must have</span></span><br><span class="line">	<span class="comment">// been triggered by a ConfigUpdate message. If the config sequence advances,</span></span><br><span class="line">	<span class="comment">// it is the responsibility of the consenter to recompute the resulting config,</span></span><br><span class="line">	<span class="comment">// discarding the message if the reconfiguration is no longer valid.</span></span><br><span class="line">	<span class="comment">// The consenter may return an error, indicating the message was not accepted</span></span><br><span class="line">	Configure(config *cb.Envelope, configSeq <span class="keyword">uint64</span>) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待排序集群可用</span></span><br><span class="line">	<span class="comment">// WaitReady blocks waiting for consenter to be ready for accepting new messages.</span></span><br><span class="line">	<span class="comment">// This is useful when consenter needs to temporarily block ingress messages so</span></span><br><span class="line">	<span class="comment">// that in-flight messages can be consumed. It could return error if consenter is</span></span><br><span class="line">	<span class="comment">// in erroneous states. If this blocking behavior is not desired, consenter could</span></span><br><span class="line">	<span class="comment">// simply return nil.</span></span><br><span class="line">	WaitReady() error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当排序集群发送错误时，会关闭返回的通道</span></span><br><span class="line">	<span class="comment">// Errored returns a channel which will close when an error has occurred.</span></span><br><span class="line">	<span class="comment">// This is especially useful for the Deliver client, who must terminate waiting</span></span><br><span class="line">	<span class="comment">// clients when the consenter is not up to date.</span></span><br><span class="line">	Errored() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动当前链</span></span><br><span class="line">	<span class="comment">// Start should allocate whatever resources are needed for staying up to date with the chain.</span></span><br><span class="line">	<span class="comment">// Typically, this involves creating a thread which reads from the ordering source, passes those</span></span><br><span class="line">	<span class="comment">// messages to a block cutter, and writes the resulting blocks to the ledger.</span></span><br><span class="line">	Start()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 停止当前链，并释放资源</span></span><br><span class="line">	<span class="comment">// Halt frees the resources which were allocated for this Chain.</span></span><br><span class="line">	Halt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Consenter"><a href="#Consenter" class="headerlink" title="Consenter"></a>Consenter</h3><p><img src="https://lessisbetter.site/images/2019-11-orderer-consenter.png" alt="Consenter"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Consenter <span class="keyword">interface</span> &#123;</span><br><span class="line">	HandleChain(support ConsenterSupport, metadata *cb.Metadata) (Chain, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Consenter也是接口，它只有1个功能用来创建<code>Chain</code>。每种共识插件，都有自己单独的<strong>consenter实现</strong>，分别用来创建solo实例、kafka实例或etcdraft实例。</p>
<h3 id="ConsenterSupport"><a href="#ConsenterSupport" class="headerlink" title="ConsenterSupport"></a>ConsenterSupport</h3><p><img src="https://lessisbetter.site/images/2019-11-orderer-consentersupport.png" alt="ConsenterSupport"></p>
<p>ConsenterSupport为<strong>consenter实现</strong>提供所需的资源，其实就是共识用来访问外部数据的接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsenterSupport provides the resources available to a Consenter implementation.</span></span><br><span class="line"><span class="keyword">type</span> ConsenterSupport <span class="keyword">interface</span> &#123;</span><br><span class="line">	crypto.LocalSigner</span><br><span class="line">	msgprocessor.Processor</span><br><span class="line"></span><br><span class="line">	<span class="comment">// VerifyBlockSignature verifies a signature of a block with a given optional</span></span><br><span class="line">	<span class="comment">// configuration (can be nil).</span></span><br><span class="line">	VerifyBlockSignature([]*cb.SignedData, *cb.ConfigEnvelope) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提供把消息切成块的接口</span></span><br><span class="line">	<span class="comment">// BlockCutter returns the block cutting helper for this channel.</span></span><br><span class="line">	BlockCutter() blockcutter.Receiver</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前链的orderer配置</span></span><br><span class="line">	<span class="comment">// SharedConfig provides the shared config from the channel&#x27;s current config block.</span></span><br><span class="line">	SharedConfig() channelconfig.Orderer</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前链的通道配置</span></span><br><span class="line">	<span class="comment">// ChannelConfig provides the channel config from the channel&#x27;s current config block.</span></span><br><span class="line">	ChannelConfig() channelconfig.Channel</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成区块</span></span><br><span class="line">	<span class="comment">// CreateNextBlock takes a list of messages and creates the next block based on the block with highest block number committed to the ledger</span></span><br><span class="line">	<span class="comment">// Note that either WriteBlock or WriteConfigBlock must be called before invoking this method a second time.</span></span><br><span class="line">	CreateNextBlock(messages []*cb.Envelope) *cb.Block</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读区块</span></span><br><span class="line">	<span class="comment">// Block returns a block with the given number,</span></span><br><span class="line">	<span class="comment">// or nil if such a block doesn&#x27;t exist.</span></span><br><span class="line">	Block(number <span class="keyword">uint64</span>) *cb.Block</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写区块</span></span><br><span class="line">	<span class="comment">// WriteBlock commits a block to the ledger.</span></span><br><span class="line">	WriteBlock(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写配置区块并更新配置</span></span><br><span class="line">	<span class="comment">// WriteConfigBlock commits a block to the ledger, and applies the config update inside.</span></span><br><span class="line">	WriteConfigBlock(block *cb.Block, encodedMetadataValue []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sequence returns the current config squence.</span></span><br><span class="line">	Sequence() <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ChainID returns the channel ID this support is associated with.</span></span><br><span class="line">	ChainID() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Height returns the number of blocks in the chain this channel is associated with.</span></span><br><span class="line">	Height() <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以原始数据的格式追加区块，不像WriteBlock那样会修改元数据</span></span><br><span class="line">	<span class="comment">// Append appends a new block to the ledger in its raw form,</span></span><br><span class="line">	<span class="comment">// unlike WriteBlock that also mutates its metadata.</span></span><br><span class="line">	Append(block *cb.Block) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h2><p>把上面介绍的各项，融合在一幅图中：</p>
<ul>
<li>Registrar 包容万象，主要是ChainSupport和Consenter，Consenter是可插拔的</li>
<li>ChainSupport 代表了一条链，能够指向属于本条链的共识实例，该共识实例由对应共识类型的Consenter创建</li>
<li>共识实例使用ConsenterSupport访问共识外部资源</li>
</ul>
<p><img src="https://lessisbetter.site/images/2019-11-core-struct-of-orderer.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/11/13/using-fabric-sdk-go-register-event/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/13/using-fabric-sdk-go-register-event/" class="post-title-link" itemprop="url">使用fabric-sdk-go订阅Fabric事件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-13 20:43:13" itemprop="dateCreated datePublished" datetime="2019-11-13T20:43:13+08:00">2019-11-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 14:18:43" itemprop="dateModified" datetime="2020-12-13T14:18:43+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a href="http://lessisbetter.site/2019/09/02/fabric-sdk-go-chaincode/">使用fabric-sdk-go操作链码</a>，介绍了使用官方Go SDK，安装、实例化和升级链码，调用和查询链码，本文介绍使用fabric-sdk-go订阅事件。</p>
<h2 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h2><p>本质上就3种事件：</p>
<ul>
<li>BlockEvent：获取区块信息</li>
<li>TransactionEvent：获取交易信息</li>
<li>ChainCodeEvnet：链码中<strong>自定义的</strong>链码事件</li>
</ul>
<p>但每种事件都有2 种类型：</p>
<ul>
<li><strong>Filtered</strong>：事件订阅时默认的类型，获取的<strong>信息“不全”</strong>，不同的事件缺失的数据不同，比如链码事件，如果是Filtered的，其响应字段中的Payload是空的，也就是不知道链码事件携带的数据。这种方式能够降低fabric网络和SDK之间的流量，当Filtered后的字段信息就足够时，这种方式非常适合。关于Filtered的更多信息，这篇文章 <a href="http://lessisbetter.site/2019/09/20/fabric-event-source/">Fabric 1.4源码解读 3：Event原理解读</a> 非常有帮助。</li>
<li><strong>非Filtered</strong> ：可以获取<strong>完整的</strong>区块、交易、链码事件<strong>信息</strong>，这种方式在SDK想获取更多信息时，是非常必要的。</li>
</ul>
<p>4 个注册事件的接口1个取消注册的接口如下：</p>
<table>
<thead>
<tr>
<th align="center">接口名称</th>
<th align="center">描述</th>
<th align="center">参数值</th>
<th align="center">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RegisterBlockEvent</td>
<td align="center">注册块事件</td>
<td align="center">filter …fab.BlockFilter</td>
<td align="center">fab.Registration, &lt;-chan *fab.BlockEvent, error</td>
</tr>
<tr>
<td align="center">RegisterFilteredBlockEvent</td>
<td align="center">注册过滤块事件</td>
<td align="center">无</td>
<td align="center">fab.Registration, &lt;-chan *fab.FilteredBlockEvent, error</td>
</tr>
<tr>
<td align="center">RegisterTxStatusEvent</td>
<td align="center">注册交易状态事件</td>
<td align="center">txID string</td>
<td align="center">fab.Registration, &lt;-chan *fab.TxStatusEvent, error</td>
</tr>
<tr>
<td align="center">RegisterChaincodeEvent</td>
<td align="center">注册链码事件</td>
<td align="center">ccID, eventFilter string</td>
<td align="center">fab.Registration, &lt;-chan *fab.CCEvent, error</td>
</tr>
<tr>
<td align="center">Unregister</td>
<td align="center">取消事件订阅</td>
<td align="center">fab.Registration</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>注册会得到管理可以管理订阅的Registration、接收事件的通道，以及可能注册时发生的错误，关于每个接口的具体介绍、使用，可以参考官方的<a target="_blank" rel="noopener" href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/event">Event文档</a>，其中包含了样例代码，如果想看真实的样例代码，可以参考<a href="#%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE">示例项目</a>。</p>
<h2 id="Option介绍"><a href="#Option介绍" class="headerlink" title="Option介绍"></a>Option介绍</h2><p>注册事件需要使用<code>EventClient</code>，创建EventClient时可以指定一些选项，这些选项其实就是事件订阅的选项。</p>
<p>有3个Option:</p>
<ul>
<li><p>func WithBlockEvents() ClientOption</p>
<p>  指定了此选项，事件就是<strong>非“filtered”</strong>，fabric会向调用SDK客户端发送完整的区块，可以获得订阅事件完整的信息。</p>
</li>
<li><p>func WithSeekType(seek seek.Type) ClientOption</p>
<p>  使用此选项可以<strong>指定从哪个区块高度获取事件</strong>。<code>seek.Type</code>有<code>Oldest</code>、<code>Newest</code>和<code>FromBlock</code> 3种取值，分别代表从第1个区块、最后一个区块和指定区块号开始获取事件，<code>FromBlock</code>需要结合<code>WithBlockNum</code>使用。So，可以通过这个选项<strong>获取历史事件</strong>。</p>
</li>
<li><p>func WithBlockNum(from uint64) ClientOption</p>
<p>  指定区块高度，只有<code>WithSeekType(FromBlock)</code>时才生效。</p>
</li>
</ul>
<h2 id="链码事件多说几句"><a href="#链码事件多说几句" class="headerlink" title="链码事件多说几句"></a>链码事件多说几句</h2><h3 id="链码如何发链码事件"><a href="#链码如何发链码事件" class="headerlink" title="链码如何发链码事件"></a>链码如何发链码事件</h3><p><code>ChaincodeStubInterface</code>有<code>SetEvent</code>的方法，入参分别为事件名称和事件锁携带的信息payload。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ChaincodeStubInterface is used by deployable chaincode apps to access and</span></span><br><span class="line"><span class="comment">// modify their ledgers</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeStubInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// SetEvent allows the chaincode to set an event on the response to the</span></span><br><span class="line">    <span class="comment">// proposal to be included as part of a transaction. The event will be</span></span><br><span class="line">    <span class="comment">// available within the transaction in the committed block regardless of the</span></span><br><span class="line">    <span class="comment">// validity of the transaction.</span></span><br><span class="line">    SetEvent(name <span class="keyword">string</span>, payload []<span class="keyword">byte</span>) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过ChannelClient订阅链码事件介绍"><a href="#通过ChannelClient订阅链码事件介绍" class="headerlink" title="通过ChannelClient订阅链码事件介绍"></a>通过ChannelClient订阅链码事件介绍</h3><p>SDK的channel client也有订阅链码事件的接口：<a target="_blank" rel="noopener" href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/channel#Client.RegisterChaincodeEvent">channel.Client.RegisterChaincodeEvent()</a>，它的定义和event client提供的接口完全一样，但功能上有所差别。</p>
<p>channel client没有指定 <code>WithBlockEvents</code>，所以这是<strong>Filtered的事件链码</strong>，获取的事件链码中，其Payload为空。</p>
<h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>示例项目<a target="_blank" rel="noopener" href="https://github.com/Shitaibin/fabric-sdk-go-sample/tree/master/samples/event">fabric-sdk-go-sample</a>是结合Fabric的BYFN展示如何使用fabric-sdk-go的项目，它的Event样例部分，介绍了如何使用以上接口订阅Fabric事件，具体请参加该部分<a target="_blank" rel="noopener" href="https://github.com/Shitaibin/fabric-sdk-go-sample/blob/master/samples/event/README.md">README</a>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/11/10/how-fabric-verify-signatures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/10/how-fabric-verify-signatures/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 5：Fabric是如何验证签名的？</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-10 21:23:36" itemprop="dateCreated datePublished" datetime="2019-11-10T21:23:36+08:00">2019-11-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>如果不清楚数字证书、公私钥与签名的关系，建议阅读阮一峰的<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">数字签名是什么？</a>。</p>
<h2 id="Fabric证书和密钥文件"><a href="#Fabric证书和密钥文件" class="headerlink" title="Fabric证书和密钥文件"></a>Fabric证书和密钥文件</h2><p>使用Fabric CA或者 cryptogen 工具可以生成证书和私钥文件，这里取 BYFN 例子的文件做介绍，Org1 Admin 账户的文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  first-network git:(release-1.4) ✗ tree crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com</span><br><span class="line">crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com</span><br><span class="line">├── msp</span><br><span class="line">│   ├── admincerts</span><br><span class="line">│   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">│   ├── cacerts</span><br><span class="line">│   │   └── ca.org1.example.com-cert.pem</span><br><span class="line">│   ├── keystore</span><br><span class="line">│   │   └── f9f3dddb7fcc40086de6d5ae77f1481abbb99bff7a74839b950720d3dca0d8ee_sk</span><br><span class="line">│   ├── signcerts</span><br><span class="line">│   │   └── Admin@org1.example.com-cert.pem</span><br><span class="line">│   └── tlscacerts</span><br><span class="line">│       └── tlsca.org1.example.com-cert.pem</span><br><span class="line">└── tls</span><br><span class="line">    ├── ca.crt</span><br><span class="line">    ├── client.crt</span><br><span class="line">    └── client.key</span><br></pre></td></tr></table></figure>

<p>msp目录，为Admin的身份信息：</p>
<ul>
<li>admincerts：组织管理员的身份验证证书。</li>
<li>cacerts：组织的根证书。</li>
<li>keystore：该用户的私钥，用来对消息签名。</li>
<li>signcerts：该用户的身份验证证书，被组织根证书签名。</li>
<li>tlscacerts：TLS通信用的身份证书，为组织的TLS证书。</li>
</ul>
<p>tls目录，为TLS通信相关的证书：</p>
<ul>
<li>ca.crt：组织根证书</li>
<li>client.crt：验证当前用户身份的证书，当前为验证管理员的证书</li>
<li>client.key：当前用户的身份私钥，用来签名</li>
</ul>
<h2 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><p>交易是区块链的核心，一切状态的转移都是一条交易，交易的真伪需要使用数字签名进行保证。</p>
<p>在Fabric中，交易涉及两个概念：</p>
<ul>
<li>Proposal：提案</li>
<li>Transaction：交易</li>
</ul>
<p>所以 Proposal 和 Transaction 都需要使用数字签名进行保护，它们相关的消息中，都包含了发送方的身份信息：mspid、证书（证书中实际包含了公钥）。</p>
<p>提案的实际消息是 SignedProposal，其中包含了：</p>
<ul>
<li>数字签名：Signature</li>
<li>证书、公钥等签名者身份信息：ProposalBytes.Proposal.Header.SignatureHeader.Creator</li>
</ul>
<p><img src="https://lessisbetter.site/images/2019-11-signed_proposal.png" alt="signed_proposal"></p>
<blockquote>
<p>图来自杨保华的<a target="_blank" rel="noopener" href="https://github.com/yeasy/hyperledger_code_fabric">hyperledger_code_fabric</a> 。</p>
</blockquote>
<p>交易中最重要的是Envelope结构体，SDK向Orderer提交交易时，会发送Envelope消息，它包含了：</p>
<ul>
<li>数字签名：Signature</li>
<li>交易发送方的身份信息：Payload.Header.SignatureHeader.Creator</li>
<li>可选背书节点的身份信息，不同的交易类型，Data包含了不同的信息，如果是需要背书的，可以包含背书的信息、签名和身份信息：Payload.Data.SignedChainccodeDeploymentSpec.OwnerEndorsements.signingidentity</li>
</ul>
<p><img src="https://lessisbetter.site/images/2019-11-tx_envelop.jpeg" alt="Signed transaction"></p>
<blockquote>
<p>图来自《区块链原理、设计与应用》，为升级链码的交易Envelope结构。</p>
</blockquote>
<p>在验证消息的签名时，会从中提取出数字签名Signature，身份信息（证书、公钥）和被签名消息体，完成以下验证：</p>
<ul>
<li>使用证书验证发送方的身份，发送方是否属于它所在的组织，以及发送方的公钥没有修改和替换</li>
<li>使用公钥验证消息是否为发送方签名，并且消息没有被修改</li>
</ul>
<p>验证的整体流程如下：</p>
<p><img src="https://lessisbetter.site/images/2019-11-verify-signature.png" alt="Verify signature"></p>
<h2 id="验证签名的函数"><a href="#验证签名的函数" class="headerlink" title="验证签名的函数"></a>验证签名的函数</h2><p><code>core/common/validation/msgvalidation.go</code> 提供了2验证消息签名的函数，用来验证Proposal和Transaction，它们会调用相同的函数<code>checkSignatureFromCreator</code>进行数字签名的验证。</p>
<h3 id="验证Porposal签名"><a href="#验证Porposal签名" class="headerlink" title="验证Porposal签名"></a>验证Porposal签名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateProposalMessage</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*pb.Proposal, *common.Header, *pb.ChaincodeHeaderExtension, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从SignatureHeader交易客户端的签名</span></span><br><span class="line">	<span class="comment">// validate the signature</span></span><br><span class="line">	err = checkSignatureFromCreator(shdr.Creator, signedProp.Signature, signedProp.ProposalBytes, chdr.ChannelId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// log the exact message on the peer but return a generic error message to</span></span><br><span class="line">		<span class="comment">// avoid malicious users scanning for channels</span></span><br><span class="line">		putilsLogger.Warningf(<span class="string">&quot;channel [%s]: %s&quot;</span>, chdr.ChannelId, err)</span><br><span class="line">		sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">		err := proto.Unmarshal(shdr.Creator, sId)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// log the error here as well but still only return the generic error</span></span><br><span class="line">			err = errors.Wrap(err, <span class="string">&quot;could not deserialize a SerializedIdentity&quot;</span>)</span><br><span class="line">			putilsLogger.Warningf(<span class="string">&quot;channel [%s]: %s&quot;</span>, chdr.ChannelId, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;access denied: channel [%s] creator org [%s]&quot;</span>, chdr.ChannelId, sId.Mspid)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证Transaction签名"><a href="#验证Transaction签名" class="headerlink" title="验证Transaction签名"></a>验证Transaction签名</h3><p>Commit阶段会对交易进行验证，会调用此函数，该函数完成了对Transaction的验证，包含发送方数字签名的验证。</p>
<p>交易是包含背书结果和背书签名的，背书相关的验证并不包含在此，而是专门的背书验证，具体请看<a href="http://lessisbetter.site/2019/09/06/fabric-source-endorser-policy-flow/">Fabric 1.4源码解读 1：背书策略是怎么使用的</a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValidateTransaction checks that the transaction envelope is properly formed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateTransaction</span><span class="params">(e *common.Envelope, c channelconfig.ApplicationCapabilities)</span> <span class="params">(*common.Payload, pb.TxValidationCode)</span></span> &#123;</span><br><span class="line">	putilsLogger.Debugf(<span class="string">&quot;ValidateTransactionEnvelope starts for envelope %p&quot;</span>, e)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate the header</span></span><br><span class="line">	chdr, shdr, err := validateCommonHeader(payload.Header)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		putilsLogger.Errorf(<span class="string">&quot;validateCommonHeader returns err %s&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_COMMON_HEADER</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate the signature in the envelope</span></span><br><span class="line">	err = checkSignatureFromCreator(shdr.Creator, e.Signature, e.Payload, chdr.ChannelId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		putilsLogger.Errorf(<span class="string">&quot;checkSignatureFromCreator returns err %s&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_CREATOR_SIGNATURE</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// continue the validation in a way that depends on the type specified in the header</span></span><br><span class="line">	<span class="keyword">switch</span> common.HeaderType(chdr.Type) &#123;</span><br><span class="line">	<span class="keyword">case</span> common.HeaderType_ENDORSER_TRANSACTION:</span><br><span class="line">		<span class="comment">// Verify that the transaction ID has been computed properly.</span></span><br><span class="line">		<span class="comment">// This check is needed to ensure that the lookup into the ledger</span></span><br><span class="line">		<span class="comment">// for the same TxID catches duplicates.</span></span><br><span class="line">		err = utils.CheckTxID(</span><br><span class="line">			chdr.TxId,</span><br><span class="line">			shdr.Nonce,</span><br><span class="line">			shdr.Creator)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			putilsLogger.Errorf(<span class="string">&quot;CheckTxID returns err %s&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, pb.TxValidationCode_BAD_PROPOSAL_TXID</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果是背书交易，背书的签名不在此验证，由背书策略模块进行验证</span></span><br><span class="line">		err = validateEndorserTransaction(payload.Data, payload.Header)</span><br><span class="line">		putilsLogger.Debugf(<span class="string">&quot;ValidateTransactionEnvelope returns err %s&quot;</span>, err)</span><br></pre></td></tr></table></figure>

<h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// given a creator, a message and a signature,</span></span><br><span class="line"><span class="comment">// this function returns nil if the creator</span></span><br><span class="line"><span class="comment">// is a valid cert and the signature is valid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkSignatureFromCreator</span><span class="params">(creatorBytes []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>, msg []<span class="keyword">byte</span>, ChainID <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	putilsLogger.Debugf(<span class="string">&quot;begin&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check for nil argument</span></span><br><span class="line">	<span class="keyword">if</span> creatorBytes == <span class="literal">nil</span> || sig == <span class="literal">nil</span> || msg == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;nil arguments&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 每个链有各自的msp</span></span><br><span class="line">	mspObj := mspmgmt.GetIdentityDeserializer(ChainID)</span><br><span class="line">	<span class="keyword">if</span> mspObj == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;could not get msp for channel [%s]&quot;</span>, ChainID)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取proposal创建者/发送方的Identity</span></span><br><span class="line">	<span class="comment">// creatorBytes 中是序列化后的mspid、证书、公钥等信息</span></span><br><span class="line">	creator, err := mspObj.DeserializeIdentity(creatorBytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;MSP error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	putilsLogger.Debugf(<span class="string">&quot;creator is %s&quot;</span>, creator.GetIdentifier())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 验证证书是否有效</span></span><br><span class="line">	<span class="comment">// ensure that creator is a valid certificate</span></span><br><span class="line">	err = creator.Validate()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;creator certificate is not valid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	putilsLogger.Debugf(<span class="string">&quot;creator is valid&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate the signature</span></span><br><span class="line">	<span class="comment">// 验证签名</span></span><br><span class="line">	err = creator.Verify(msg, sig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;creator&#x27;s signature over the proposal is not valid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	putilsLogger.Debugf(<span class="string">&quot;exits successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取Identity"><a href="#获取Identity" class="headerlink" title="获取Identity"></a>获取Identity</h3><p>获取当前通道的MSP manager：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetIdentityDeserializer returns the IdentityDeserializer for the given chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetIdentityDeserializer</span><span class="params">(chainID <span class="keyword">string</span>)</span> <span class="title">msp</span>.<span class="title">IdentityDeserializer</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> chainID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> GetLocalMSP()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> GetManagerForChain(chainID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetManagerForChain returns the msp manager for the supplied</span></span><br><span class="line"><span class="comment">// chain; if no such manager exists, one is created</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetManagerForChain</span><span class="params">(chainID <span class="keyword">string</span>)</span> <span class="title">msp</span>.<span class="title">MSPManager</span></span> &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 先从缓存查找</span></span><br><span class="line">	mspMgr, ok := mspMap[chainID]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="comment">// 找不到则新建立当前通道Msp manager</span></span><br><span class="line">		mspLogger.Debugf(<span class="string">&quot;Created new msp manager for channel `%s`&quot;</span>, chainID)</span><br><span class="line">		mspMgmtMgr := &amp;mspMgmtMgr&#123;msp.NewMSPManager(), <span class="literal">false</span>&#125;</span><br><span class="line">		mspMap[chainID] = mspMgmtMgr</span><br><span class="line">		mspMgr = mspMgmtMgr</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// check for internal mspManagerImpl and mspMgmtMgr types. if a different</span></span><br><span class="line">		<span class="comment">// type is found, it&#x27;s because a developer has added a new type that</span></span><br><span class="line">		<span class="comment">// implements the MSPManager interface and should add a case to the logic</span></span><br><span class="line">		<span class="comment">// above to handle it.</span></span><br><span class="line">		<span class="keyword">if</span> !(reflect.TypeOf(mspMgr).Elem().Name() == <span class="string">&quot;mspManagerImpl&quot;</span> || reflect.TypeOf(mspMgr).Elem().Name() == <span class="string">&quot;mspMgmtMgr&quot;</span>) &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;Found unexpected MSPManager type.&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mspLogger.Debugf(<span class="string">&quot;Returning existing manager for channel &#x27;%s&#x27;&quot;</span>, chainID)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mspMgr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MSPManager has been setup for a channel, which indicates whether the channel</span></span><br><span class="line"><span class="comment">// exists or not</span></span><br><span class="line"><span class="keyword">type</span> mspMgmtMgr <span class="keyword">struct</span> &#123;</span><br><span class="line">	msp.MSPManager</span><br><span class="line">	<span class="comment">// track whether this MSPManager has been setup successfully</span></span><br><span class="line">	up <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>msp.MSPManager</code>是一个接口，从上面代码可以得知，它是利用<code>NewMSPManager</code>创建的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建等待Setup的MSPManager</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMSPManager</span><span class="params">()</span> <span class="title">MSPManager</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;mspManagerImpl&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>疑问是，啥时候Setup的，当前调用路径上没发现这个路径，可能从系统整体流程上，已经保证了，当前调用时，已经创建好了。</p>
<p>获取Identity，是一个剥洋葱的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *mspMgmtMgr)</span> <span class="title">DeserializeIdentity</span><span class="params">(serializedIdentity []<span class="keyword">byte</span>)</span> <span class="params">(msp.Identity, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !mgr.up &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;channel doesn&#x27;t exist&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mgr.MSPManager.DeserializeIdentity(serializedIdentity)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际调用<code>mspManagerImpl</code>的<code>DeserializeIdentity</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeserializeIdentity returns an identity given its serialized version supplied as argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mgr *mspManagerImpl)</span> <span class="title">DeserializeIdentity</span><span class="params">(serializedID []<span class="keyword">byte</span>)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// We first deserialize to a SerializedIdentity to get the MSP ID</span></span><br><span class="line">	sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">	err := proto.Unmarshal(serializedID, sId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;could not deserialize a SerializedIdentity&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取发送方的msp实例</span></span><br><span class="line">	<span class="comment">// we can now attempt to obtain the MSP</span></span><br><span class="line">	msp := mgr.mspsMap[sId.Mspid]</span><br><span class="line">	<span class="keyword">if</span> msp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;MSP %s is unknown&quot;</span>, sId.Mspid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> t := msp.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *bccspmsp:</span><br><span class="line">		<span class="keyword">return</span> t.deserializeIdentityInternal(sId.IdBytes)</span><br><span class="line">	<span class="keyword">case</span> *idemixmsp:</span><br><span class="line">		<span class="keyword">return</span> t.deserializeIdentityInternal(sId.IdBytes)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> t.DeserializeIdentity(serializedID)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转到bccspmsp的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化二进制，得到证书，然后用证书获取公钥，使用证书、公钥和msp，创建Identity</span></span><br><span class="line"><span class="comment">// deserializeIdentityInternal returns an identity given its byte-level representation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(msp *bccspmsp)</span> <span class="title">deserializeIdentityInternal</span><span class="params">(serializedIdentity []<span class="keyword">byte</span>)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// This MSP will always deserialize certs this way</span></span><br><span class="line">	bl, _ := pem.Decode(serializedIdentity)</span><br><span class="line">	<span class="keyword">if</span> bl == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;could not decode the PEM structure&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	cert, err := x509.ParseCertificate(bl.Bytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;parseCertificate failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now we have the certificate; make sure that its fields</span></span><br><span class="line">	<span class="comment">// (e.g. the Issuer.OU or the Subject.OU) match with the</span></span><br><span class="line">	<span class="comment">// MSP id that this MSP has; otherwise it might be an attack</span></span><br><span class="line">	<span class="comment">// TODO!</span></span><br><span class="line">	<span class="comment">// We can&#x27;t do it yet because there is no standardized way</span></span><br><span class="line">	<span class="comment">// (yet) to encode the MSP ID into the x.509 body of a cert</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从证书中提取公钥，封装一下，满足bccsp.Key接口</span></span><br><span class="line">	pub, err := msp.bccsp.KeyImport(cert, &amp;bccsp.X509PublicKeyImportOpts&#123;Temporary: <span class="literal">true</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">&quot;failed to import certificate&#x27;s public key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 利用证书、公钥和msp建立角色身份</span></span><br><span class="line">	<span class="keyword">return</span> newIdentity(cert, pub, msp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Identity包含了Identity标示符，证书、公钥和所在的msp，创建Identity就是计算以上几项信息的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> identity <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// id contains the identifier (MSPID and identity identifier) for this instance</span></span><br><span class="line">	id *IdentityIdentifier</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cert contains the x.509 certificate that signs the public key of this instance</span></span><br><span class="line">	cert *x509.Certificate</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this is the public key of this instance</span></span><br><span class="line">	pk bccsp.Key</span><br><span class="line"></span><br><span class="line">	<span class="comment">// reference to the MSP that &quot;owns&quot; this identity</span></span><br><span class="line">	msp *bccspmsp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newIdentity</span><span class="params">(cert *x509.Certificate, pk bccsp.Key, msp *bccspmsp)</span> <span class="params">(Identity, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) &#123;</span><br><span class="line">		mspIdentityLogger.Debugf(<span class="string">&quot;Creating identity instance for cert %s&quot;</span>, certToPEM(cert))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查证书</span></span><br><span class="line">	<span class="comment">// Sanitize first the certificate</span></span><br><span class="line">	cert, err := msp.sanitizeCert(cert)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute identity identifier</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use the hash of the identity&#x27;s certificate as id in the IdentityIdentifier</span></span><br><span class="line">	hashOpt, err := bccsp.GetHashOpt(msp.cryptoConfig.IdentityIdentifierHashFunction)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">&quot;failed getting hash function options&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	digest, err := msp.bccsp.Hash(cert.Raw, hashOpt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">&quot;failed hashing raw certificate to compute the id of the IdentityIdentifier&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	id := &amp;IdentityIdentifier&#123;</span><br><span class="line">		Mspid: msp.name,</span><br><span class="line">		Id:    hex.EncodeToString(digest)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;identity&#123;id: id, cert: cert, pk: pk, msp: msp&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证数字签名"><a href="#验证数字签名" class="headerlink" title="验证数字签名"></a>验证数字签名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Verify checks against a signature and a message</span></span><br><span class="line"><span class="comment">// to determine whether this identity produced the</span></span><br><span class="line"><span class="comment">// signature; it returns nil if so or an error otherwise</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(id *identity)</span> <span class="title">Verify</span><span class="params">(msg []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// mspIdentityLogger.Infof(&quot;Verifying signature&quot;)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute Hash</span></span><br><span class="line">	hashOpt, err := id.getHashOpt(id.msp.cryptoConfig.SignatureHashFamily)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;failed getting hash function options&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	digest, err := id.msp.bccsp.Hash(msg, hashOpt)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;failed computing digest&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mspIdentityLogger.IsEnabledFor(zapcore.DebugLevel) &#123;</span><br><span class="line">		mspIdentityLogger.Debugf(<span class="string">&quot;Verify: digest = %s&quot;</span>, hex.Dump(digest))</span><br><span class="line">		mspIdentityLogger.Debugf(<span class="string">&quot;Verify: sig = %s&quot;</span>, hex.Dump(sig))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终会调用bccsp的接口验证签名，SW或者国密</span></span><br><span class="line">	valid, err := id.msp.bccsp.Verify(id.pk, sig, digest, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;could not determine the validity of the signature&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !valid &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;The signature is invalid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解密SignatureHeader"><a href="#解密SignatureHeader" class="headerlink" title="解密SignatureHeader"></a>解密SignatureHeader</h2><p>Fabric 使用 <code>SignatureHeader</code> 保存发送方的身份信息，Creator即为序列化后的信息。</p>
<p><code>SignatureHeaderMaker</code> 接口定义了创建一个 <code>SignatureHeader</code> 的方法，搜索起来实现该接口的结构体很多，本质上只有2个：<code>mspSigner</code> 和 <code>SignatureHeaderCreator</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SignatureHeaderMaker creates a new SignatureHeader</span></span><br><span class="line"><span class="keyword">type</span> SignatureHeaderMaker <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// NewSignatureHeader creates a SignatureHeader with the correct signing identity and a valid nonce</span></span><br><span class="line">	NewSignatureHeader() (*cb.SignatureHeader, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// localmsp</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspSigner)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// crypto</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bs *SignatureHeaderCreator)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>两个实现本质上是一样的，以 <code>mspSigner</code> 为例进行介绍。首先获取实现SigningIdentity接口的实例，然后调用<code>Serialize</code>得到序列化后的身份信息，再随机生成一个Nonce，创建出<code>SignatureHeader</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSignatureHeader creates a SignatureHeader with the correct signing identity and a valid nonce</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *mspSigner)</span> <span class="title">NewSignatureHeader</span><span class="params">()</span> <span class="params">(*cb.SignatureHeader, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获得SigningIdentity接口实例</span></span><br><span class="line">	signer, err := mspmgmt.GetLocalMSP().GetDefaultSigningIdentity()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Failed getting MSP-based signer [%s]&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 序列化得到creator</span></span><br><span class="line">	creatorIdentityRaw, err := signer.Serialize()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Failed serializing creator public identity [%s]&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取一个随机nonce</span></span><br><span class="line">	nonce, err := crypto.GetRandomNonce()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Failed creating nonce [%s]&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sh := &amp;cb.SignatureHeader&#123;&#125;</span><br><span class="line">	sh.Creator = creatorIdentityRaw</span><br><span class="line">	sh.Nonce = nonce</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sh, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SigningIdentity</code>接口包含了<code>Identity</code>接口，Identity声明了跟证书相关的方法，SigningIdentity则增加了对消息签名的函数<code>Sign</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SigningIdentity <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extends Identity</span></span><br><span class="line">	Identity</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sign the message</span></span><br><span class="line">	Sign(msg []<span class="keyword">byte</span>) ([]<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// GetPublicVersion returns the public parts of this identity</span></span><br><span class="line">	GetPublicVersion() Identity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Identity <span class="keyword">interface</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// Serialize converts an identity to bytes</span></span><br><span class="line">	Serialize() ([]<span class="keyword">byte</span>, error)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Serialize</code>的实现，实际只包含了证书和MSPID，说明了<strong>消息中携带的只包含MSPID和证书作为身份信息</strong>，而不是<code>signingidentity</code>的所有字段（signingidentity实现了SigningIdentity接口）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Serialize returns a byte array representation of this identity</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(id *identity)</span> <span class="title">Serialize</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// mspIdentityLogger.Infof(&quot;Serializing identity %s&quot;, id.id)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Raw格式证书</span></span><br><span class="line">	pb := &amp;pem.Block&#123;Bytes: id.cert.Raw, Type: <span class="string">&quot;CERTIFICATE&quot;</span>&#125;</span><br><span class="line">	pemBytes := pem.EncodeToMemory(pb)</span><br><span class="line">	<span class="keyword">if</span> pemBytes == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;encoding of identity failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用MSPID和序列化后的证书，再次序列化得到身份信息 </span></span><br><span class="line">	sId := &amp;msp.SerializedIdentity&#123;Mspid: id.id.Mspid, IdBytes: pemBytes&#125;</span><br><span class="line">	idBytes, err := proto.Marshal(sId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;could not marshal a SerializedIdentity structure for identity %s&quot;</span>, id.id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> idBytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/yeasy/hyperledger_code_fabric">https://github.com/yeasy/hyperledger_code_fabric</a></li>
<li>《区块链原理、设计与应用》第9章、第10章</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/10/31/go-modules-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/31/go-modules-notes/" class="post-title-link" itemprop="url">Go Modules 方法、问题汇总贴</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-31 17:07:59" itemprop="dateCreated datePublished" datetime="2019-10-31T17:07:59+08:00">2019-10-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 14:18:43" itemprop="dateModified" datetime="2020-12-13T14:18:43+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="教程资料"><a href="#教程资料" class="headerlink" title="教程资料"></a>教程资料</h2><ul>
<li>简单操作：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016703769">https://segmentfault.com/a/1190000016703769</a></li>
<li>多项介绍：<a target="_blank" rel="noopener" href="https://learnku.com/golang/t/33859">https://learnku.com/golang/t/33859</a></li>
<li>官方教程：<a target="_blank" rel="noopener" href="https://blog.golang.org/using-go-modules">https://blog.golang.org/using-go-modules</a></li>
</ul>
<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="replace-使用http或https"><a href="#replace-使用http或https" class="headerlink" title="replace 使用http或https"></a>replace 使用http或https</h3><p>在使用go replace时，有2点注意：</p>
<ul>
<li>目标仓库不能带协议头，比如http、https，要从域名或者IP开始</li>
<li>版本号格式要符合语义格式化，测试版本是否符合规则：<a target="_blank" rel="noopener" href="https://play.golang.org/p/S_Jz3-Uxh_T">Go playground 样例代码</a></li>
</ul>
<p>直接修改 <code>go.mod</code> 文件格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace github.com&#x2F;hyperledger&#x2F;fabric v1.4.1 &#x3D;&gt; 192.168.9.251&#x2F;hyperledger&#x2F;fabric v1.4.1-alpha.11-yx</span><br></pre></td></tr></table></figure>

<p>或使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace&#x3D;github.com&#x2F;hyperledger&#x2F;fabric@v1.4.1&#x3D;192.168.9.251&#x2F;hyperledger&#x2F;fabric@v1.4.1</span><br></pre></td></tr></table></figure>

<h3 id="Gitlab-仓库没开启https"><a href="#Gitlab-仓库没开启https" class="headerlink" title="Gitlab 仓库没开启https"></a>Gitlab 仓库没开启https</h3><p>go mod 默认使用 go get 下载依赖，而 go get 默认使用 https，如果 Gitlab 仓库没有启用 https，需要使用 <code>-insecure</code> 让go get走http。</p>
<p>问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY&#x3D;&quot;&quot; go get github.com&#x2F;hyperledger&#x2F;fabric@v1.4.1</span><br><span class="line">go: 192.168.9.251&#x2F;hyperledger&#x2F;fabric@v1.4.1-alpha.11-yx: unrecognized import path &quot;192.168.9.251&#x2F;hyperledger&#x2F;fabric&quot; (https fetch: Get https:&#x2F;&#x2F;192.168.9.251&#x2F;hyperledger&#x2F;fabric?go-get&#x3D;1: dial tcp 192.168.9.251:443: connect: connection refused)</span><br><span class="line">go: error loading module requirements</span><br></pre></td></tr></table></figure>

<p>方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPROXY&#x3D;&quot;&quot; go get -insecure github.com&#x2F;hyperledger&#x2F;fabric@v1.4.1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注解：遇到问题时，使用 <code>go get -v</code> 可以看到更多信息，有助分析问题。</p>
</blockquote>
<h3 id="Go-Modules-代理"><a href="#Go-Modules-代理" class="headerlink" title="Go Modules 代理"></a>Go Modules 代理</h3><p>由于某些网络原因，国内下载 Github 等处的依赖，不够流程，需要设置代理，不同版本的设置如下：</p>
<ul>
<li><p>go1.12</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn</span><br></pre></td></tr></table></figure>
</li>
<li><p>go1.13</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export GOPRIVATE&#x3D;192.168.9.251</span><br><span class="line">$ export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>如果仓库设置为私有，这要求用户必须登录才能访问仓库。</p>
<p>Go Modules 默认使用 go get 下载依赖，go get 利用 https 或者 http, 但下载过程没有设置用户名和密码的地方，下载依赖时，可能遇到一下错误：</p>
<ul>
<li>connection refused</li>
<li>unkown revision</li>
</ul>
<p>可以通过设置Github/Gitlab Access Token结果，通过token的方式，访问仓库，token的获取方式为，登录Gitlab仓库，进入以下页面：</p>
<p>Gitlab User Setting -&gt; Access Tokens</p>
<p>在此页面复制下顶端的 <code>Your New Personal Access Token</code>, 然后填写token名字和勾选下方的权限进行创建 Token。</p>
<p>然后执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global \</span><br><span class="line">url.<span class="string">&quot;http://oauth2:<span class="variable">$&#123;your_access_token&#125;</span>@ip_address_or_domain&quot;</span>.insteadOf \</span><br><span class="line"><span class="string">&quot;http://ip_address_or_domain&quot;</span></span><br></pre></td></tr></table></figure>

<p>后面再去 go get 的时候，就可顺利下载依赖。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/10/31/fabric-sdk-go-configure-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/31/fabric-sdk-go-configure-graph/" class="post-title-link" itemprop="url">fabric-sdk-go 配置项分类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-31 11:41:49" itemprop="dateCreated datePublished" datetime="2019-10-31T11:41:49+08:00">2019-10-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>fabric-sdk-go 配置文件示例 <a target="_blank" rel="noopener" href="https://github.com/hyperledger/fabric-sdk-go/blob/master/test/fixtures/config/config_e2e.yaml">config_e2e</a>。</p>
<p>配置项内容可按以下分类：</p>
<p><img src="https://lessisbetter.site/images/2019-10-fabric-sdk-go-conf-yaml.png" alt="fabric-sdk-go configure"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/10/29/fabric-transaction-endorser-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/29/fabric-transaction-endorser-source/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 4：交易背书流程解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-29 18:05:43" itemprop="dateCreated datePublished" datetime="2019-10-29T18:05:43+08:00">2019-10-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>在 <a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/">快速入门Fabric核心概念和框架</a> 这篇文章中，介绍了 Fabric 的很多概念，其中也包含了交易、提案（Proposal）和链码。同时也介绍了，交易的执行流程，链码的调用流程等。</p>
<p>本文聚焦介绍交易流程的一个环节：交易背书，以下的3幅图，在<a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/">快速入门Fabric核心概念和框架</a> 中都有介绍，有必要的话，去读一下上下文信息。</p>
<h3 id="交易宏观流程"><a href="#交易宏观流程" class="headerlink" title="交易宏观流程"></a>交易宏观流程</h3><p><img src="https://lessisbetter.site/images/2019-07-tx-flow.png"></p>
<p>交易的详细流程请阅读 <a href="http://lessisbetter.site/2019/07/17/fabric-concepts-notes/#%E4%BA%A4%E6%98%93">交易流程</a>，了解交易流程的几大环节。</p>
<h3 id="链码调用流程"><a href="#链码调用流程" class="headerlink" title="链码调用流程"></a>链码调用流程</h3><p><img src="https://lessisbetter.site/images/2019-07-fabric-invoke-chaincode.png"></p>
<p>上图，展示了客户端、Peer，以及链码容器 3大主体在交易流程中的背书过程，请关注一下Peer中的 Handler，它负责和链码容器交互。</p>
<h3 id="提案背书流程"><a href="#提案背书流程" class="headerlink" title="提案背书流程"></a>提案背书流程</h3><p><img src="https://lessisbetter.site/images/2019-07-chaincode_swimlane.png"></p>
<p>上图，从接近源码的层面，展示了交易背书过程。其中Fabric、Shim 是 Peer 中的模块，ChainCode 代表链码容器，Endorser Chaincode 代表 Peer 对交易提案和模拟执行结果进行背书。</p>
<p>如果了解过Chaincode，你会知道 Shim 是链码容器和 Peer 交互所依赖的模块。</p>
<p>最后推荐一份保华大佬整理的 <a target="_blank" rel="noopener" href="https://github.com/yeasy/hyperledger_code_fabric/blob/master/process/peer_endorse.md">Peer 提案背书过程</a>，是读源码前，必读的资料。虽然精简，但把重要的核心流程都串联起来了。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Proposal定义"><a href="#Proposal定义" class="headerlink" title="Proposal定义"></a>Proposal定义</h3><p>客户端发送被背书节点的是 <code>SignedProposal</code> ，它包含了签名和Proposal，这是它在<code>proposal.proto</code>中的组成简介，：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SignedProposal</span><br><span class="line">|\_ Signature                                    (signature on the Proposal message by the creator specified in the header)</span><br><span class="line"> \_ Proposal</span><br><span class="line">    |\_ Header                                   (the header for this proposal)</span><br><span class="line">     \_ Payload                                  (the payload for this proposal)</span><br></pre></td></tr></table></figure>

<p><code>proposal.proto</code>这个文件还简要介绍了Client和背书节点之间通信的消息类型和过程。</p>
<h4 id="Proposal"><a href="#Proposal" class="headerlink" title="Proposal"></a>Proposal</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SignedProposal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The bytes of Proposal</span></span><br><span class="line">	ProposalBytes []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=proposal_bytes,json=proposalBytes,proto3&quot; json:&quot;proposal_bytes,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Signaure over proposalBytes; this signature is to be verified against</span></span><br><span class="line">	<span class="comment">// the creator identity contained in the header of the Proposal message</span></span><br><span class="line">	<span class="comment">// marshaled as proposalBytes</span></span><br><span class="line">	Signature            []<span class="keyword">byte</span>   <span class="string">`protobuf:&quot;bytes,2,opt,name=signature,proto3&quot; json:&quot;signature,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Proposal <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The header of the proposal. It is the bytes of the Header</span></span><br><span class="line">	Header []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=header,proto3&quot; json:&quot;header,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// The payload of the proposal as defined by the type in the proposal</span></span><br><span class="line">	<span class="comment">// header.</span></span><br><span class="line">	Payload []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,2,opt,name=payload,proto3&quot; json:&quot;payload,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Optional extensions to the proposal. Its content depends on the Header&#x27;s</span></span><br><span class="line">	<span class="comment">// type field.  For the type CHAINCODE, it might be the bytes of a</span></span><br><span class="line">	<span class="comment">// ChaincodeAction message.</span></span><br><span class="line">	Extension            []<span class="keyword">byte</span>   <span class="string">`protobuf:&quot;bytes,3,opt,name=extension,proto3&quot; json:&quot;extension,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	ChannelHeader        []<span class="keyword">byte</span>   <span class="string">`protobuf:&quot;bytes,1,opt,name=channel_header,json=channelHeader,proto3&quot; json:&quot;channel_header,omitempty&quot;`</span></span><br><span class="line">	SignatureHeader      []<span class="keyword">byte</span>   <span class="string">`protobuf:&quot;bytes,2,opt,name=signature_header,json=signatureHeader,proto3&quot; json:&quot;signature_header,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is a generic replay prevention and identity message to include in a signed payload</span></span><br><span class="line"><span class="keyword">type</span> ChannelHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type <span class="keyword">int32</span> <span class="string">`protobuf:&quot;varint,1,opt,name=type,proto3&quot; json:&quot;type,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Version indicates message protocol version</span></span><br><span class="line">	Version <span class="keyword">int32</span> <span class="string">`protobuf:&quot;varint,2,opt,name=version,proto3&quot; json:&quot;version,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Timestamp is the local time when the message was created</span></span><br><span class="line">	<span class="comment">// by the sender</span></span><br><span class="line">	Timestamp *timestamp.Timestamp <span class="string">`protobuf:&quot;bytes,3,opt,name=timestamp,proto3&quot; json:&quot;timestamp,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Identifier of the channel this message is bound for</span></span><br><span class="line">	ChannelId <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,4,opt,name=channel_id,json=channelId,proto3&quot; json:&quot;channel_id,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// An unique identifier that is used end-to-end.</span></span><br><span class="line">	<span class="comment">//  -  set by higher layers such as end user or SDK</span></span><br><span class="line">	<span class="comment">//  -  passed to the endorser (which will check for uniqueness)</span></span><br><span class="line">	<span class="comment">//  -  as the header is passed along unchanged, it will be</span></span><br><span class="line">	<span class="comment">//     be retrieved by the committer (uniqueness check here as well)</span></span><br><span class="line">	<span class="comment">//  -  to be stored in the ledger</span></span><br><span class="line">	TxId <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,5,opt,name=tx_id,json=txId,proto3&quot; json:&quot;tx_id,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// The epoch in which this header was generated, where epoch is defined based on block height</span></span><br><span class="line">	<span class="comment">// Epoch in which the response has been generated. This field identifies a</span></span><br><span class="line">	<span class="comment">// logical window of time. A proposal response is accepted by a peer only if</span></span><br><span class="line">	<span class="comment">// two conditions hold:</span></span><br><span class="line">	<span class="comment">// 1. the epoch specified in the message is the current epoch</span></span><br><span class="line">	<span class="comment">// 2. this message has been only seen once during this epoch (i.e. it hasn&#x27;t</span></span><br><span class="line">	<span class="comment">//    been replayed)</span></span><br><span class="line">	Epoch <span class="keyword">uint64</span> <span class="string">`protobuf:&quot;varint,6,opt,name=epoch,proto3&quot; json:&quot;epoch,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Extension that may be attached based on the header type</span></span><br><span class="line">	Extension []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,7,opt,name=extension,proto3&quot; json:&quot;extension,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// If mutual TLS is employed, this represents</span></span><br><span class="line">	<span class="comment">// the hash of the client&#x27;s TLS certificate</span></span><br><span class="line">	TlsCertHash          []<span class="keyword">byte</span>   <span class="string">`protobuf:&quot;bytes,8,opt,name=tls_cert_hash,json=tlsCertHash,proto3&quot; json:&quot;tls_cert_hash,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SignatureHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Creator of the message, a marshaled msp.SerializedIdentity</span></span><br><span class="line">	Creator []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=creator,proto3&quot; json:&quot;creator,omitempty&quot;`</span></span><br><span class="line">	<span class="comment">// Arbitrary number that may only be used once. Can be used to detect replay attacks.</span></span><br><span class="line">	Nonce                []<span class="keyword">byte</span>   <span class="string">`protobuf:&quot;bytes,2,opt,name=nonce,proto3&quot; json:&quot;nonce,omitempty&quot;`</span></span><br><span class="line">	XXX_NoUnkeyedLiteral <span class="keyword">struct</span>&#123;&#125; <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_unrecognized     []<span class="keyword">byte</span>   <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">	XXX_sizecache        <span class="keyword">int32</span>    <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gRPC定义"><a href="#gRPC定义" class="headerlink" title="gRPC定义"></a>gRPC定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EndorserClient is the client API for Endorser service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> EndorserClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	ProcessProposal(ctx context.Context, in *SignedProposal, opts ...grpc.CallOption) (*ProposalResponse, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EndorserServer is the server API for Endorser service.</span></span><br><span class="line"><span class="keyword">type</span> EndorserServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	ProcessProposal(context.Context, *SignedProposal) (*ProposalResponse, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SDK发送Proposal"><a href="#SDK发送Proposal" class="headerlink" title="SDK发送Proposal"></a>SDK发送Proposal</h3><h3 id="Peer接收Proposal"><a href="#Peer接收Proposal" class="headerlink" title="Peer接收Proposal"></a>Peer接收Proposal</h3><h3 id="Peer处理Proposal主流程"><a href="#Peer处理Proposal主流程" class="headerlink" title="Peer处理Proposal主流程"></a>Peer处理Proposal主流程</h3><p>主要是把背书节点的背书工作聚合一下：</p>
<ol>
<li>Proposal预处理</li>
<li>获取交易执行模拟器，模拟执行Proposal</li>
<li>如果模拟执行成功，调用ESCC对Proposal和结果进行背书，如果模拟执行失败直接返回背书失败的响应</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">ProcessProposal</span><span class="params">(ctx context.Context, signedProp *pb.SignedProposal)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 0 -- check and validate</span></span><br><span class="line">	<span class="comment">// 这里有相当多的工作量</span></span><br><span class="line">	vr, err := e.preProcess(signedProp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		resp := vr.resp</span><br><span class="line">		<span class="keyword">return</span> resp, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	prop, hdrExt, chainID, txid := vr.prop, vr.hdrExt, vr.chainID, vr.txid</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取指定账本模拟器</span></span><br><span class="line">	<span class="comment">// obtaining once the tx simulator for this proposal. This will be nil</span></span><br><span class="line">	<span class="comment">// for chainless proposals</span></span><br><span class="line">	<span class="comment">// Also obtain a history query executor for history queries, since tx simulator does not cover history</span></span><br><span class="line">	<span class="keyword">var</span> txsim ledger.TxSimulator</span><br><span class="line">	<span class="keyword">var</span> historyQueryExecutor ledger.HistoryQueryExecutor</span><br><span class="line">	<span class="keyword">if</span> acquireTxSimulator(chainID, vr.hdrExt.ChaincodeId) &#123;</span><br><span class="line">		<span class="keyword">if</span> txsim, err = e.s.GetTxSimulator(chainID, txid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">defer</span> txsim.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">		ChannelID:            chainID,</span><br><span class="line">		TxID:                 txid,</span><br><span class="line">		SignedProp:           signedProp,</span><br><span class="line">		Proposal:             prop,</span><br><span class="line">		TXSimulator:          txsim,</span><br><span class="line">		HistoryQueryExecutor: historyQueryExecutor,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// this could be a request to a chainless SysCC</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟执行交易，失败则返回背书失败的响应</span></span><br><span class="line">	<span class="comment">// 1 -- simulate</span></span><br><span class="line">	cd, res, simulationResult, ccevent, err := e.SimulateProposal(txParams, hdrExt.ChaincodeId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> res.Status &gt;= shim.ERROR &#123;</span><br><span class="line">			endorserLogger.Errorf(<span class="string">&quot;[%s][%s] simulateProposal() resulted in chaincode %s response status %d for txid: %s&quot;</span>, chainID, shorttxid(txid), hdrExt.ChaincodeId, res.Status, txid)</span><br><span class="line">			<span class="keyword">var</span> cceventBytes []<span class="keyword">byte</span></span><br><span class="line">			<span class="keyword">if</span> ccevent != <span class="literal">nil</span> &#123;</span><br><span class="line">				cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed to marshal event bytes&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> pResp, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对模拟执行的结果进行签名背书</span></span><br><span class="line">	<span class="comment">// 2 -- endorse and get a marshalled ProposalResponse message</span></span><br><span class="line">	<span class="keyword">var</span> pResp *pb.ProposalResponse</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TODO till we implement global ESCC, CSCC for system chaincodes</span></span><br><span class="line">	<span class="comment">// chainless proposals (such as CSCC) don&#x27;t have to be endorsed</span></span><br><span class="line">	<span class="keyword">if</span> chainID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		pResp = &amp;pb.ProposalResponse&#123;Response: res&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: To endorseProposal(), we pass the released txsim. Hence, an error would occur if we try to use this txsim</span></span><br><span class="line">		pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the proposal response payload - it</span></span><br><span class="line">	<span class="comment">// contains the &quot;return value&quot; from the</span></span><br><span class="line">	<span class="comment">// chaincode invocation</span></span><br><span class="line">	pResp.Response = res</span><br><span class="line"></span><br><span class="line">	<span class="comment">// total failed proposals = ProposalsReceived-SuccessfulProposals</span></span><br><span class="line">	e.Metrics.SuccessfulProposals.Add(<span class="number">1</span>)</span><br><span class="line">	success = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pResp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preProcess-检查和获取信息"><a href="#preProcess-检查和获取信息" class="headerlink" title="preProcess 检查和获取信息"></a>preProcess 检查和获取信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// preProcess checks the tx proposal headers, uniqueness and ACL</span></span><br><span class="line"><span class="comment">// 检查proposal、ACL</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">preProcess</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*validateResult, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 包含proposal、header、chainID、txid等信息</span></span><br><span class="line">	vr := &amp;validateResult&#123;&#125;</span><br><span class="line">	<span class="comment">// at first, we check whether the message is valid</span></span><br><span class="line">	<span class="comment">// 检查proposal，并获取各种需要的信息</span></span><br><span class="line">	prop, hdr, hdrExt, err := validation.ValidateProposalMessage(signedProp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		e.Metrics.ProposalValidationFailed.Add(<span class="number">1</span>)</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取Header中的2个Header</span></span><br><span class="line">	chdr, err := putils.UnmarshalChannelHeader(hdr.ChannelHeader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shdr, err := putils.GetSignatureHeader(hdr.SignatureHeader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查是否调用了不可外部（用户）的系统链码</span></span><br><span class="line">	<span class="comment">// 先找到链码实例，然后调用链码的方法判断本身是否可调用</span></span><br><span class="line">	<span class="comment">// block invocations to security-sensitive system chaincodes</span></span><br><span class="line">	<span class="keyword">if</span> e.s.IsSysCCAndNotInvokableExternal(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line">		endorserLogger.Errorf(<span class="string">&quot;Error: an attempt was made by %#v to invoke system chaincode %s&quot;</span>, shdr.Creator, hdrExt.ChaincodeId.Name)</span><br><span class="line">		err = errors.Errorf(<span class="string">&quot;chaincode %s cannot be invoked through a proposal&quot;</span>, hdrExt.ChaincodeId.Name)</span><br><span class="line">		vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">		<span class="keyword">return</span> vr, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chainID := chdr.ChannelId</span><br><span class="line">	txid := chdr.TxId</span><br><span class="line">	endorserLogger.Debugf(<span class="string">&quot;[%s][%s] processing txid: %s&quot;</span>, chainID, shorttxid(txid), txid)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> chainID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// labels that provide context for failure metrics</span></span><br><span class="line">		meterLabels := []<span class="keyword">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;channel&quot;</span>, chainID,</span><br><span class="line">			<span class="string">&quot;chaincode&quot;</span>, hdrExt.ChaincodeId.Name + <span class="string">&quot;:&quot;</span> + hdrExt.ChaincodeId.Version,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查交易是否已上链</span></span><br><span class="line">		<span class="comment">// Here we handle uniqueness check and ACLs for proposals targeting a chain</span></span><br><span class="line">		<span class="comment">// Notice that ValidateProposalMessage has already verified that TxID is computed properly</span></span><br><span class="line">		<span class="keyword">if</span> _, err = e.s.GetTransactionByID(chainID, txid); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// increment failure due to duplicate transactions. Useful for catching replay attacks in</span></span><br><span class="line">			<span class="comment">// addition to benign retries</span></span><br><span class="line">			e.Metrics.DuplicateTxsFailure.With(meterLabels...).Add(<span class="number">1</span>)</span><br><span class="line">			err = errors.Errorf(<span class="string">&quot;duplicate transaction found [%s]. Creator [%x]&quot;</span>, txid, shdr.Creator)</span><br><span class="line">			vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">			<span class="keyword">return</span> vr, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 用户链码检查ACL</span></span><br><span class="line">		<span class="comment">// check ACL only for application chaincodes; ACLs</span></span><br><span class="line">		<span class="comment">// for system chaincodes are checked elsewhere</span></span><br><span class="line">		<span class="keyword">if</span> !e.s.IsSysCC(hdrExt.ChaincodeId.Name) &#123;</span><br><span class="line">			<span class="comment">// check that the proposal complies with the Channel&#x27;s writers</span></span><br><span class="line">			<span class="keyword">if</span> err = e.s.CheckACL(signedProp, chdr, shdr, hdrExt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				e.Metrics.ProposalACLCheckFailed.With(meterLabels...).Add(<span class="number">1</span>)</span><br><span class="line">				vr.resp = &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;</span><br><span class="line">				<span class="keyword">return</span> vr, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// chainless proposals do not/cannot affect ledger and cannot be submitted as transactions</span></span><br><span class="line">		<span class="comment">// ignore uniqueness checks; also, chainless proposals are not validated using the policies</span></span><br><span class="line">		<span class="comment">// of the chain since by definition there is no chain; they are validated against the local</span></span><br><span class="line">		<span class="comment">// MSP of the peer instead by the call to ValidateProposalMessage above</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存提取的各信息</span></span><br><span class="line">	vr.prop, vr.hdrExt, vr.chainID, vr.txid = prop, hdrExt, chainID, txid</span><br><span class="line">	<span class="keyword">return</span> vr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ValidateProposalMessage checks the validity of a SignedProposal message</span></span><br><span class="line"><span class="comment">// this function returns Header and ChaincodeHeaderExtension messages since they</span></span><br><span class="line"><span class="comment">// have been unmarshalled and validated</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateProposalMessage</span><span class="params">(signedProp *pb.SignedProposal)</span> <span class="params">(*pb.Proposal, *common.Header, *pb.ChaincodeHeaderExtension, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> signedProp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;nil arguments&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	putilsLogger.Debugf(<span class="string">&quot;ValidateProposalMessage starts for signed proposal %p&quot;</span>, signedProp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// extract the Proposal message from signedProp</span></span><br><span class="line">	prop, err := utils.GetProposal(signedProp.ProposalBytes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1) look at the ProposalHeader</span></span><br><span class="line">	hdr, err := utils.GetHeader(prop.Header)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate the header</span></span><br><span class="line">	chdr, shdr, err := validateCommonHeader(hdr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从SignatureHeader交易客户端的签名</span></span><br><span class="line">	<span class="comment">// validate the signature</span></span><br><span class="line">	err = checkSignatureFromCreator(shdr.Creator, signedProp.Signature, signedProp.ProposalBytes, chdr.ChannelId)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// log the exact message on the peer but return a generic error message to</span></span><br><span class="line">		<span class="comment">// avoid malicious users scanning for channels</span></span><br><span class="line">		putilsLogger.Warningf(<span class="string">&quot;channel [%s]: %s&quot;</span>, chdr.ChannelId, err)</span><br><span class="line">		sId := &amp;msp.SerializedIdentity&#123;&#125;</span><br><span class="line">		err := proto.Unmarshal(shdr.Creator, sId)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// log the error here as well but still only return the generic error</span></span><br><span class="line">			err = errors.Wrap(err, <span class="string">&quot;could not deserialize a SerializedIdentity&quot;</span>)</span><br><span class="line">			putilsLogger.Warningf(<span class="string">&quot;channel [%s]: %s&quot;</span>, chdr.ChannelId, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;access denied: channel [%s] creator org [%s]&quot;</span>, chdr.ChannelId, sId.Mspid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查txid的计算是否符合规则</span></span><br><span class="line">	<span class="comment">// Verify that the transaction ID has been computed properly.</span></span><br><span class="line">	<span class="comment">// This check is needed to ensure that the lookup into the ledger</span></span><br><span class="line">	<span class="comment">// for the same TxID catches duplicates.</span></span><br><span class="line">	err = utils.CheckTxID(</span><br><span class="line">		chdr.TxId,</span><br><span class="line">		shdr.Nonce,</span><br><span class="line">		shdr.Creator)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 依据不同的proposal类型对proposal分别进行检查</span></span><br><span class="line">	<span class="comment">// continue the validation in a way that depends on the type specified in the header</span></span><br><span class="line">	<span class="keyword">switch</span> common.HeaderType(chdr.Type) &#123;</span><br><span class="line">	<span class="keyword">case</span> common.HeaderType_CONFIG:</span><br><span class="line">		<span class="comment">//which the types are different the validation is the same</span></span><br><span class="line">		<span class="comment">//viz, validate a proposal to a chaincode. If we need other</span></span><br><span class="line">		<span class="comment">//special validation for confguration, we would have to implement</span></span><br><span class="line">		<span class="comment">//special validation</span></span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> common.HeaderType_ENDORSER_TRANSACTION:</span><br><span class="line">		<span class="comment">// 主要是提取ChaincodeHeaderExtension</span></span><br><span class="line">		<span class="comment">// validation of the proposal message knowing it&#x27;s of type CHAINCODE</span></span><br><span class="line">		chaincodeHdrExt, err := validateChaincodeProposalMessage(prop, hdr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> prop, hdr, chaincodeHdrExt, err</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">//NOTE : we proably need a case</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;unsupported proposal type %d&quot;</span>, common.HeaderType(chdr.Type))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="背书节点模拟执行交易"><a href="#背书节点模拟执行交易" class="headerlink" title="背书节点模拟执行交易"></a>背书节点模拟执行交易</h3><h4 id="获取模拟器"><a href="#获取模拟器" class="headerlink" title="获取模拟器"></a>获取模拟器</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support contains functions that the endorser requires to execute its tasks</span></span><br><span class="line"><span class="keyword">type</span> Support <span class="keyword">interface</span> &#123;</span><br><span class="line">	crypto.SignerSupport</span><br><span class="line">	<span class="comment">// IsSysCCAndNotInvokableExternal returns true if the supplied chaincode is</span></span><br><span class="line">	<span class="comment">// ia system chaincode and it NOT invokable</span></span><br><span class="line">	IsSysCCAndNotInvokableExternal(name <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// GetTxSimulator returns the transaction simulator for the specified ledger</span></span><br><span class="line">	<span class="comment">// a client may obtain more than one such simulator; they are made unique</span></span><br><span class="line">	<span class="comment">// by way of the supplied txid</span></span><br><span class="line">	GetTxSimulator(ledgername <span class="keyword">string</span>, txid <span class="keyword">string</span>) (ledger.TxSimulator, error)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetTxSimulator returns the transaction simulator for the specified ledger</span></span><br><span class="line"><span class="comment">// a client may obtain more than one such simulator; they are made unique</span></span><br><span class="line"><span class="comment">// by way of the supplied txid</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupportImpl)</span> <span class="title">GetTxSimulator</span><span class="params">(ledgername <span class="keyword">string</span>, txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用账本和txid创建模拟器，每个交易有单独的模拟器</span></span><br><span class="line">	lgr := s.Peer.GetLedger(ledgername)</span><br><span class="line">	<span class="keyword">if</span> lgr == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;Channel does not exist: %s&quot;</span>, ledgername)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lgr.NewTxSimulator(txid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTxSimulator returns new `ledger.TxSimulator`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *kvLedger)</span> <span class="title">NewTxSimulator</span><span class="params">(txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> l.txtmgmt.NewTxSimulator(txid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTxSimulator implements method in interface `txmgmt.TxMgr`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txmgr *LockBasedTxMgr)</span> <span class="title">NewTxSimulator</span><span class="params">(txid <span class="keyword">string</span>)</span> <span class="params">(ledger.TxSimulator, error)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">&quot;constructing new tx simulator&quot;</span>)</span><br><span class="line">	s, err := newLockBasedTxSimulator(txmgr, txid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	txmgr.commitRWLock.RLock()</span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就2项重要的：查询执行器、读写集构建器</span></span><br><span class="line"><span class="comment">// LockBasedTxSimulator is a transaction simulator used in `LockBasedTxMgr`</span></span><br><span class="line"><span class="keyword">type</span> lockBasedTxSimulator <span class="keyword">struct</span> &#123;</span><br><span class="line">	lockBasedQueryExecutor</span><br><span class="line">	rwsetBuilder              *rwsetutil.RWSetBuilder</span><br><span class="line">	writePerformed            <span class="keyword">bool</span></span><br><span class="line">	pvtdataQueriesPerformed   <span class="keyword">bool</span></span><br><span class="line">	simulationResultsComputed <span class="keyword">bool</span></span><br><span class="line">	paginatedQueriesPerformed <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newLockBasedTxSimulator</span><span class="params">(txmgr *LockBasedTxMgr, txid <span class="keyword">string</span>)</span> <span class="params">(*lockBasedTxSimulator, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建读写集构建器，能帮助构建读写集</span></span><br><span class="line">	rwsetBuilder := rwsetutil.NewRWSetBuilder()</span><br><span class="line">	helper := newQueryHelper(txmgr, rwsetBuilder)</span><br><span class="line">	logger.Debugf(<span class="string">&quot;constructing new tx simulator txid = [%s]&quot;</span>, txid)</span><br><span class="line">	<span class="keyword">return</span> &amp;lockBasedTxSimulator&#123;lockBasedQueryExecutor&#123;helper, txid&#125;, rwsetBuilder, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LockBasedQueryExecutor is a query executor used in `LockBasedTxMgr`</span></span><br><span class="line"><span class="comment">// &quot;只读&quot;，不包含写相关的操作</span></span><br><span class="line"><span class="keyword">type</span> lockBasedQueryExecutor <span class="keyword">struct</span> &#123;</span><br><span class="line">	helper *queryHelper</span><br><span class="line">	txid   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h4><h5 id="endorser部分"><a href="#endorser部分" class="headerlink" title="endorser部分"></a>endorser部分</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> acquireTxSimulator(chainID, vr.hdrExt.ChaincodeId) &#123;</span><br><span class="line">	<span class="keyword">if</span> txsim, err = e.s.GetTxSimulator(chainID, txid); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> txsim.Done()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 历史查询器</span></span><br><span class="line">	<span class="keyword">if</span> historyQueryExecutor, err = e.s.GetHistoryQueryExecutor(chainID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: &amp;pb.Response&#123;Status: <span class="number">500</span>, Message: err.Error()&#125;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">	ChannelID:            chainID,</span><br><span class="line">	TxID:                 txid,</span><br><span class="line">	SignedProp:           signedProp,</span><br><span class="line">	Proposal:             prop,</span><br><span class="line">	TXSimulator:          txsim,	<span class="comment">// 模拟器在此</span></span><br><span class="line">	HistoryQueryExecutor: historyQueryExecutor,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this could be a request to a chainless SysCC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> if the proposal has an extension, it will be of type ChaincodeAction;</span></span><br><span class="line"><span class="comment">//       if it&#x27;s present it means that no simulation is to be performed because</span></span><br><span class="line"><span class="comment">//       we&#x27;re trying to emulate a submitting peer. On the other hand, we need</span></span><br><span class="line"><span class="comment">//       to validate the supplied action before endorsing it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟执行交易，失败则返回背书失败的响应</span></span><br><span class="line"><span class="comment">// 1 -- simulate</span></span><br><span class="line">cd, res, simulationResult, ccevent, err := e.SimulateProposal(txParams, hdrExt.ChaincodeId)</span><br></pre></td></tr></table></figure>

<p>调用chaincode模块模拟执行交易，获取交易执行的公开和私密数据读写集，以及交易执行产生的事件，并把结果返回给上层进行背书。</p>
<p>其中还包含了私密数据的处理，会把它取出来，然后通过Gossip传播给在私密数据中的Peer节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimulateProposal simulates the proposal by calling the chaincode</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">SimulateProposal</span><span class="params">(txParams *ccprovider.TransactionParams, cid *pb.ChaincodeID)</span> <span class="params">(ccprovider.ChaincodeDefinition, *pb.Response, []<span class="keyword">byte</span>, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	endorserLogger.Debugf(<span class="string">&quot;[%s][%s] Entry chaincode: %s&quot;</span>, txParams.ChannelID, shorttxid(txParams.TxID), cid)</span><br><span class="line">	<span class="keyword">defer</span> endorserLogger.Debugf(<span class="string">&quot;[%s][%s] Exit&quot;</span>, txParams.ChannelID, shorttxid(txParams.TxID))</span><br><span class="line">	<span class="comment">// we do expect the payload to be a ChaincodeInvocationSpec</span></span><br><span class="line">	<span class="comment">// if we are supporting other payloads in future, this be glaringly point</span></span><br><span class="line">	<span class="comment">// as something that should change</span></span><br><span class="line">	<span class="comment">// 根据Proposal生成Invoke需要的信息</span></span><br><span class="line">	cis, err := putils.GetChaincodeInvocationSpec(txParams.Proposal)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 链码的元数据</span></span><br><span class="line">	<span class="keyword">var</span> cdLedger ccprovider.ChaincodeDefinition</span><br><span class="line">	<span class="keyword">var</span> version <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置version</span></span><br><span class="line">	<span class="keyword">if</span> !e.s.IsSysCC(cid.Name) &#123;</span><br><span class="line">		<span class="comment">// 根据要调用的链码名称，从lscc获取链码的元数据</span></span><br><span class="line">		cdLedger, err = e.s.GetChaincodeDefinition(cid.Name, txParams.TXSimulator)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">&quot;make sure the chaincode %s has been successfully instantiated and try again&quot;</span>, cid.Name))</span><br><span class="line">		&#125;</span><br><span class="line">		version = cdLedger.CCVersion()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实际被打桩了，无实现</span></span><br><span class="line">		err = e.s.CheckInstantiationPolicy(cid.Name, version, cdLedger)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// scc版本是固定的&quot;latest&quot;</span></span><br><span class="line">		version = util.GetSysCCVersion()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---3. execute the proposal and get simulation results</span></span><br><span class="line">	<span class="keyword">var</span> simResult *ledger.TxSimulationResults</span><br><span class="line">	<span class="keyword">var</span> pubSimResBytes []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> res *pb.Response</span><br><span class="line">	<span class="keyword">var</span> ccevent *pb.ChaincodeEvent</span><br><span class="line">	<span class="comment">// 模拟执行，执行结果保存在模拟器</span></span><br><span class="line">	res, ccevent, err = e.callChaincode(txParams, version, cis.ChaincodeSpec.Input, cid)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Errorf(<span class="string">&quot;[%s][%s] failed to invoke chaincode %s, error: %+v&quot;</span>, txParams.ChannelID, shorttxid(txParams.TxID), cid, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> txParams.TXSimulator != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 通过模拟器获取模拟执行结果，包含公开和私密数据2份读写集</span></span><br><span class="line">		<span class="keyword">if</span> simResult, err = txParams.TXSimulator.GetTxSimulationResults(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			txParams.TXSimulator.Done()</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 存在私密数据</span></span><br><span class="line">		<span class="keyword">if</span> simResult.PvtSimulationResults != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> cid.Name == <span class="string">&quot;lscc&quot;</span> &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> remove once we can store collection configuration outside of LSCC</span></span><br><span class="line">				txParams.TXSimulator.Done()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">&quot;Private data is forbidden to be used in instantiate&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 获取要通过Gossip传播的私密数据</span></span><br><span class="line">			pvtDataWithConfig, err := e.AssemblePvtRWSet(simResult.PvtSimulationResults, txParams.TXSimulator)</span><br><span class="line">			<span class="comment">// To read collection config need to read collection updates before</span></span><br><span class="line">			<span class="comment">// releasing the lock, hence txParams.TXSimulator.Done()  moved down here</span></span><br><span class="line">			txParams.TXSimulator.Done()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">&quot;failed to obtain collections config&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			endorsedAt, err := e.s.GetLedgerHeight(txParams.ChannelID)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprint(<span class="string">&quot;failed to obtain ledger height for channel&quot;</span>, txParams.ChannelID))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add ledger height at which transaction was endorsed,</span></span><br><span class="line">			<span class="comment">// `endorsedAt` is obtained from the block storage and at times this could be &#x27;endorsement Height + 1&#x27;.</span></span><br><span class="line">			<span class="comment">// However, since we use this height only to select the configuration (3rd parameter in distributePrivateData) and</span></span><br><span class="line">			<span class="comment">// manage transient store purge for orphaned private writesets (4th parameter in distributePrivateData), this works for now.</span></span><br><span class="line">			<span class="comment">// Ideally, ledger should add support in the simulator as a first class function `GetHeight()`.</span></span><br><span class="line">			pvtDataWithConfig.EndorsedAt = endorsedAt</span><br><span class="line">			<span class="comment">// 把私密数据同通道id、交易id和区块高度发出去，代表私密数据所属的区块和交易</span></span><br><span class="line">			<span class="keyword">if</span> err := e.distributePrivateData(txParams.ChannelID, txParams.TxID, pvtDataWithConfig, endorsedAt); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 交易模拟完成，释放模拟器占用的资源</span></span><br><span class="line">		txParams.TXSimulator.Done()</span><br><span class="line">		<span class="comment">// 获取模拟执行的公开结果</span></span><br><span class="line">		<span class="keyword">if</span> pubSimResBytes, err = simResult.GetPubSimulationBytes(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回链码元数据、模拟执行结果、交易执行产生的事件</span></span><br><span class="line">	<span class="keyword">return</span> cdLedger, res, pubSimResBytes, ccevent, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callChaincode</code> 调用chaincode模块执行链码。在前面的流程中，还没有区分系统链码SCC和用户链码UCC，SCC和UCC都会通过<code>Execute</code>函数被传递给chaincode模块而执行。</p>
<p>如果是调用<code>lscc</code>部署或升级UCC，会调用<code>ExecuteLegacyInit</code>执行链码容器的初始化。</p>
<p>最后返回链码模拟执行结果和事件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call specified chaincode (system or user)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">callChaincode</span><span class="params">(txParams *ccprovider.TransactionParams, version <span class="keyword">string</span>, input *pb.ChaincodeInput, cid *pb.ChaincodeID)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// scc也在这执行</span></span><br><span class="line">	<span class="comment">// is this a system chaincode</span></span><br><span class="line">	res, ccevent, err = e.s.Execute(txParams, txParams.ChannelID, cid.Name, version, txParams.TxID, txParams.SignedProp, txParams.Proposal, input)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是调用lscc部署或升级链码，会走这段流程</span></span><br><span class="line">	<span class="keyword">if</span> cid.Name == <span class="string">&quot;lscc&quot;</span> &amp;&amp; <span class="built_in">len</span>(input.Args) &gt;= <span class="number">3</span> &amp;&amp; (<span class="keyword">string</span>(input.Args[<span class="number">0</span>]) == <span class="string">&quot;deploy&quot;</span> || <span class="keyword">string</span>(input.Args[<span class="number">0</span>]) == <span class="string">&quot;upgrade&quot;</span>) &#123;</span><br><span class="line">		userCDS, err := putils.GetChaincodeDeploymentSpec(input.Args[<span class="number">2</span>], e.PlatformRegistry)</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 进行链码容器初始化，最后会调用链码的Init的函数</span></span><br><span class="line">		_, _, err = e.s.ExecuteLegacyInit(txParams, txParams.ChannelID, cds.ChaincodeSpec.ChaincodeId.Name, cds.ChaincodeSpec.ChaincodeId.Version, txParams.TxID, txParams.SignedProp, txParams.Proposal, cds)</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ----- END -------</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res, ccevent, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Support</code> 接口实际集合了众多背书节点需要的外部模块功能，比如链码、系统链码、ACL等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support contains functions that the endorser requires to execute its tasks</span></span><br><span class="line"><span class="keyword">type</span> Support <span class="keyword">interface</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// SupportImpl provides an implementation of the endorser.Support interface</span></span><br><span class="line"><span class="comment">// issuing calls to various static methods of the peer</span></span><br><span class="line"><span class="keyword">type</span> SupportImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">	*PluginEndorser</span><br><span class="line">	crypto.SignerSupport</span><br><span class="line">	Peer             peer.Operations</span><br><span class="line">	PeerSupport      peer.Support</span><br><span class="line">	ChaincodeSupport *chaincode.ChaincodeSupport</span><br><span class="line">	SysCCProvider    *scc.Provider</span><br><span class="line">	ACLProvider      aclmgmt.ACLProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Execute</code>就是调用<code>ChaincodeSupport.Execute</code>实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute a proposal and return the chaincode response</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupportImpl)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cid, name, version, txid <span class="keyword">string</span>, signedProp *pb.SignedProposal, prop *pb.Proposal, input *pb.ChaincodeInput)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	cccid := &amp;ccprovider.CCContext&#123;</span><br><span class="line">		Name:    name,</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// decorate the chaincode input</span></span><br><span class="line">	decorators := library.InitRegistry(library.Config&#123;&#125;).Lookup(library.Decoration).([]decoration.Decorator)</span><br><span class="line">	input.Decorations = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>)</span><br><span class="line">	input = decoration.Apply(prop, input, decorators...)</span><br><span class="line">	txParams.ProposalDecorations = input.Decorations</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.ChaincodeSupport.Execute(txParams, cccid, input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="chaincode部分"><a href="#chaincode部分" class="headerlink" title="chaincode部分"></a>chaincode部分</h5><p>通过上面的接口，跨入chaincode模块的大门。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Invoke得到ChaincodeMessage</span></span><br><span class="line">	resp, err := cs.Invoke(txParams, cccid, input)</span><br><span class="line">	<span class="comment">// 根据ChaincodeMessage得到Response和事件</span></span><br><span class="line">	<span class="keyword">return</span> processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Invoke</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	h, err := cs.Launch(txParams.ChannelID, cccid.Name, cccid.Version, txParams.TXSimulator)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行调用链码的交易（和链码之间的消息为ChaincodeMessage_TRANSACTION）</span></span><br><span class="line">	cctype := pb.ChaincodeMessage_TRANSACTION</span><br><span class="line">	<span class="keyword">return</span> cs.execute(cctype, txParams, cccid, input, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="获取链码执行环境"><a href="#获取链码执行环境" class="headerlink" title="获取链码执行环境"></a>获取链码执行环境</h5><p><code>Launch</code> 可以获取链码执行环境，即用户链码容器，如果已实例化的链码，在当前背书节点上，链码容器未启动，则启动链码容器，<code>Launch</code>会返回一个跟链码容器交互Handler。</p>
<p>某个 Peer 上可以部署多个链码容器，Peer 为了和这些链码容器交互/通信，给每个链码容器都创建了一个 Handler，Handler 携带了 Peer 和链码容器交互的资源。</p>
<p><img src="https://lessisbetter.site/images/2019-10-peer-cc-handler.png"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch starts executing chaincode if it is not already running. This method</span></span><br><span class="line"><span class="comment">// blocks until the peer side handler gets into ready state or encounters a fatal</span></span><br><span class="line"><span class="comment">// error. If the chaincode is already running, it simply returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">Launch</span><span class="params">(chainID, chaincodeName, chaincodeVersion <span class="keyword">string</span>, qe ledger.QueryExecutor)</span> <span class="params">(*Handler, error)</span></span> &#123;</span><br><span class="line">	cname := chaincodeName + <span class="string">&quot;:&quot;</span> + chaincodeVersion</span><br><span class="line">	<span class="keyword">if</span> h := cs.HandlerRegistry.Handler(cname); h != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> h, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动链码容器 ...</span></span><br><span class="line"></span><br><span class="line">	h := cs.HandlerRegistry.Handler(cname)</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;[channel %s] claimed to start chaincode container for %s but could not find handler&quot;</span>, chainID, cname)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链码容器的启动过程，不是本文的重点，所以不继续深入Launch的调用细节。</p>
<h5 id="模拟执行交易"><a href="#模拟执行交易" class="headerlink" title="模拟执行交易"></a>模拟执行交易</h5><p><code>execute</code>封装出执行交易的消息，然后使用 Handler 执行交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// execute executes a transaction and waits for it to complete until a timeout value.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">execute</span><span class="params">(cctyp pb.ChaincodeMessage_Type, txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, input *pb.ChaincodeInput, h *Handler)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	input.Decorations = txParams.ProposalDecorations</span><br><span class="line">	<span class="comment">// 创建消息</span></span><br><span class="line">	ccMsg, err := createCCMessage(cctyp, txParams.ChannelID, txParams.TxID, input)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, <span class="string">&quot;failed to create chaincode message&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行交易</span></span><br><span class="line">	ccresp, err := h.Execute(txParams, cccid, ccMsg, cs.ExecuteTimeout)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithMessage(err, fmt.Sprintf(<span class="string">&quot;error sending&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ccresp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意以下这个参数 <code>txParams *ccprovider.TransactionParams</code> 其类型定义如下，它包含了一条交易执行过程中的信息和资源，所以交易传递的过程中，一直有这个参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionParams are parameters which are tied to a particular transaction</span></span><br><span class="line"><span class="comment">// and which are required for invoking chaincode.</span></span><br><span class="line"><span class="keyword">type</span> TransactionParams <span class="keyword">struct</span> &#123;</span><br><span class="line">	TxID                 <span class="keyword">string</span></span><br><span class="line">	ChannelID            <span class="keyword">string</span></span><br><span class="line">	SignedProp           *pb.SignedProposal</span><br><span class="line">	Proposal             *pb.Proposal</span><br><span class="line">	TXSimulator          ledger.TxSimulator</span><br><span class="line">	HistoryQueryExecutor ledger.HistoryQueryExecutor</span><br><span class="line">	CollectionStore      privdata.CollectionStore</span><br><span class="line">	IsInitTransaction    <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// this is additional data passed to the chaincode</span></span><br><span class="line">	ProposalDecorations <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler 执行交易的过程如下，创建交易执行的上下文 Context，因为链码容器在执行交易的时候，会和 Peer 之间进行多次通信，进行数据的读写，上下文可以让数据读写获取到正确的信息。</p>
<p>之后 Handler 把消息发送给链码容器，并等待链码容器发来包含执行结果的消息，或者执行超时，默认执行时间是 30s。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Execute</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, msg *pb.ChaincodeMessage, timeout time.Duration)</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;Entry&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> chaincodeLogger.Debugf(<span class="string">&quot;Exit&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 私密数据</span></span><br><span class="line">	txParams.CollectionStore = h.getCollectionStore(msg.ChannelId)</span><br><span class="line">	<span class="comment">// 是否是执行链码初始化</span></span><br><span class="line">	txParams.IsInitTransaction = (msg.Type == pb.ChaincodeMessage_INIT)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建交易context</span></span><br><span class="line">	txctx, err := h.TXContexts.Create(txParams)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 退出时（执行交易完毕），释放交易上下文资源</span></span><br><span class="line">	<span class="keyword">defer</span> h.TXContexts.Delete(msg.ChannelId, msg.Txid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// proposal保存到msg</span></span><br><span class="line">	<span class="keyword">if</span> err := h.setChaincodeProposal(txParams.SignedProp, txParams.Proposal, msg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 向链码容器发送msg</span></span><br><span class="line">	h.serialSendAsync(msg)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待链码容器响应，或者超时</span></span><br><span class="line">	<span class="keyword">var</span> ccresp *pb.ChaincodeMessage</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ccresp = &lt;-txctx.ResponseNotifier:</span><br><span class="line">		<span class="comment">// response is sent to user or calling chaincode. ChaincodeMessage_ERROR</span></span><br><span class="line">		<span class="comment">// are typically treated as error</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">		err = errors.New(<span class="string">&quot;timeout expired while executing transaction&quot;</span>)</span><br><span class="line">		ccName := cccid.Name + <span class="string">&quot;:&quot;</span> + cccid.Version</span><br><span class="line">		h.Metrics.ExecuteTimeouts.With(</span><br><span class="line">			<span class="string">&quot;chaincode&quot;</span>, ccName,</span><br><span class="line">		).Add(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ccresp, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="处理链码容器模拟响应"><a href="#处理链码容器模拟响应" class="headerlink" title="处理链码容器模拟响应"></a>处理链码容器模拟响应</h5><p>链码容器执行的响应会向上传递，直到 <code>ChaincodeSupport.Execute</code>，它调用 <code>processChaincodeExecutionResult</code> 把链码容器返回的响应，转化为交易模拟执行的 Response，而 Response 最终会返回给Endorser，大家可去调用流程上翻。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processChaincodeExecutionResult</span><span class="params">(txid, ccName <span class="keyword">string</span>, resp *pb.ChaincodeMessage, err error)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to execute transaction %s&quot;</span>, txid)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;nil response from transaction %s&quot;</span>, txid)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> resp.ChaincodeEvent != <span class="literal">nil</span> &#123;</span><br><span class="line">		resp.ChaincodeEvent.ChaincodeId = ccName</span><br><span class="line">		resp.ChaincodeEvent.TxId = txid</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> resp.Type &#123;</span><br><span class="line">	<span class="comment">// 交易执行成功则提取Payload中保存的Response</span></span><br><span class="line">	<span class="keyword">case</span> pb.ChaincodeMessage_COMPLETED:</span><br><span class="line">		res := &amp;pb.Response&#123;&#125;</span><br><span class="line">		err := proto.Unmarshal(resp.Payload, res)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;failed to unmarshal response for transaction %s&quot;</span>, txid)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res, resp.ChaincodeEvent, <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 	失败，则提取Payload中保存的错误信息</span></span><br><span class="line">	<span class="keyword">case</span> pb.ChaincodeMessage_ERROR:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, resp.ChaincodeEvent, errors.Errorf(<span class="string">&quot;transaction returned with failure: %s&quot;</span>, resp.Payload)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;unexpected response type %d for transaction %s&quot;</span>, resp.Type, txid)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放模拟器资源"><a href="#释放模拟器资源" class="headerlink" title="释放模拟器资源"></a>释放模拟器资源</h4><p>回想一下，在 <code>Endorser.SimulateProposal</code> 中，它获取了 交易模拟执行器 <code>TXSimulator</code>，这里面可是有很多资源的，如果不及时释放，在高 TPS 下，Peer压力上大，资源泄露，性能低下等问题会爆发出来。</p>
<p><code>txParams.TXSimulator.Done()</code> 用来释放资源，上文提到 <code>TxSimulator</code> 包含了 <code>QueryExecutor</code>, <code>lockBasedQueryExecutor</code> 实现了 <code>QueryExecutor</code>，也就是说，主要是释放查询操作相关的资源。</p>
<p>从源码可以看到会释放读写锁以及迭代器资源，如果不及时释放，后果果然不堪。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Done implements method in interface `ledger.QueryExecutor`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *lockBasedQueryExecutor)</span> <span class="title">Done</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">&quot;Done with transaction simulation / query execution [%s]&quot;</span>, q.txid)</span><br><span class="line">	q.helper.done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *queryHelper)</span> <span class="title">done</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h.doneInvoked &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 释放锁</span></span><br><span class="line">		h.txmgr.commitRWLock.RUnlock()</span><br><span class="line">		h.doneInvoked = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// 释放迭代器</span></span><br><span class="line">		<span class="keyword">for</span> _, itr := <span class="keyword">range</span> h.itrs &#123;</span><br><span class="line">			itr.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ESCC处理模拟执行结果"><a href="#ESCC处理模拟执行结果" class="headerlink" title="ESCC处理模拟执行结果"></a>ESCC处理模拟执行结果</h3><p>上文提到，模拟执行的 Response 会最终回到 Endorser，Endorser 会调用 ESCC 对结果进行背书，最终生成 <code>ProposalResponse</code>，我们看一下这个过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">ProcessProposal</span><span class="params">(ctx context.Context, signedProp *pb.SignedProposal)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Pre-process, simulate</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> chainID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		pResp = &amp;pb.ProposalResponse&#123;Response: res&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: To endorseProposal(), we pass the released txsim. Hence, an error would occur if we try to use this txsim</span></span><br><span class="line">		pResp, err = e.endorseProposal(ctx, chainID, txid, signedProp, prop, res, simulationResult, ccevent, hdrExt.PayloadVisibility, hdrExt.ChaincodeId, txsim, cd)</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Endorser-endorseProposal"><a href="#Endorser-endorseProposal" class="headerlink" title="Endorser.endorseProposal"></a>Endorser.endorseProposal</h5><p>背书链码实现了可插拔，可以使用不同的ESCC，系统链码和用户链码的背书过程是不同的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// endorse the proposal by calling the ESCC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endorser)</span> <span class="title">endorseProposal</span><span class="params">(_ context.Context, chainID <span class="keyword">string</span>, txid <span class="keyword">string</span>, signedProp *pb.SignedProposal, proposal *pb.Proposal, response *pb.Response, simRes []<span class="keyword">byte</span>, event *pb.ChaincodeEvent, visibility []<span class="keyword">byte</span>, ccid *pb.ChaincodeID, txsim ledger.TxSimulator, cd ccprovider.ChaincodeDefinition)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">	endorserLogger.Debugf(<span class="string">&quot;[%s][%s] Entry chaincode: %s&quot;</span>, chainID, shorttxid(txid), ccid)</span><br><span class="line">	<span class="keyword">defer</span> endorserLogger.Debugf(<span class="string">&quot;[%s][%s] Exit&quot;</span>, chainID, shorttxid(txid))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 系统链码和用户链码使用不同的ESCC</span></span><br><span class="line">	isSysCC := cd == <span class="literal">nil</span></span><br><span class="line">	<span class="comment">// 1) extract the name of the escc that is requested to endorse this chaincode</span></span><br><span class="line">	<span class="keyword">var</span> escc <span class="keyword">string</span></span><br><span class="line">	<span class="comment">// ie, &quot;lscc&quot; or system chaincodes</span></span><br><span class="line">	<span class="keyword">if</span> isSysCC &#123;</span><br><span class="line">		escc = <span class="string">&quot;escc&quot;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		escc = cd.Endorsement()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	endorserLogger.Debugf(<span class="string">&quot;[%s][%s] escc for chaincode %s is %s&quot;</span>, chainID, shorttxid(txid), ccid, escc)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// marshalling event bytes</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">var</span> eventBytes []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">if</span> event != <span class="literal">nil</span> &#123;</span><br><span class="line">		eventBytes, err = putils.GetBytesChaincodeEvent(event)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed to marshal event bytes&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set version of executing chaincode</span></span><br><span class="line">	<span class="keyword">if</span> isSysCC &#123;</span><br><span class="line">		<span class="comment">// if we want to allow mixed fabric levels we should</span></span><br><span class="line">		<span class="comment">// set syscc version to &quot;&quot;</span></span><br><span class="line">		ccid.Version = util.GetSysCCVersion()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ccid.Version = cd.CCVersion()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建背书上下文信息</span></span><br><span class="line">	ctx := Context&#123;</span><br><span class="line">		PluginName:     escc, <span class="comment">// 插件名称</span></span><br><span class="line">		Channel:        chainID,</span><br><span class="line">		SignedProposal: signedProp,</span><br><span class="line">		ChaincodeID:    ccid,</span><br><span class="line">		Event:          eventBytes,</span><br><span class="line">		SimRes:         simRes,</span><br><span class="line">		Response:       response,</span><br><span class="line">		Visibility:     visibility,</span><br><span class="line">		Proposal:       proposal,</span><br><span class="line">		TxID:           txid,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用插件背书</span></span><br><span class="line">	<span class="keyword">return</span> e.s.EndorseWithPlugin(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>背书插件实现下面的接口即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Plugin endorses a proposal response</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Endorse signs the given payload(ProposalResponsePayload bytes), and optionally mutates it.</span></span><br><span class="line">	<span class="comment">// Returns:</span></span><br><span class="line">	<span class="comment">// The Endorsement: A signature over the payload, and an identity that is used to verify the signature</span></span><br><span class="line">	<span class="comment">// The payload that was given as input (could be modified within this function)</span></span><br><span class="line">	<span class="comment">// Or error on failure</span></span><br><span class="line">	Endorse(payload []<span class="keyword">byte</span>, sp *peer.SignedProposal) (*peer.Endorsement, []<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init injects dependencies into the instance of the Plugin</span></span><br><span class="line">	Init(dependencies ...Dependency) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用插件背书，需获取插件实例，然后组装响应Payload，它包含了交易执行的多种结果，然后对Payload以及签名的Proposal背书。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EndorseWithPlugin endorses the response with a plugin</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pe *PluginEndorser)</span> <span class="title">EndorseWithPlugin</span><span class="params">(ctx Context)</span> <span class="params">(*pb.ProposalResponse, error)</span></span> &#123;</span><br><span class="line">	endorserLogger.Debug(<span class="string">&quot;Entering endorsement for&quot;</span>, ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ctx.Response == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;response is nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ctx.Response.Status &gt;= shim.ERRORTHRESHOLD &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.ProposalResponse&#123;Response: ctx.Response&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取插件</span></span><br><span class="line">	plugin, err := pe.getOrCreatePlugin(PluginName(ctx.PluginName), ctx.Channel)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Warning(<span class="string">&quot;Endorsement with plugin for&quot;</span>, ctx, <span class="string">&quot; failed:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Errorf(<span class="string">&quot;plugin with name %s could not be used: %v&quot;</span>, ctx.PluginName, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把模拟执行的信息组成生成背书响应Payload</span></span><br><span class="line">	prpBytes, err := proposalResponsePayloadFromContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Warning(<span class="string">&quot;Endorsement with plugin for&quot;</span>, ctx, <span class="string">&quot; failed:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;failed assembling proposal response payload&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对Payload和签名的Proposal进行背书</span></span><br><span class="line">	endorsement, prpBytes, err := plugin.Endorse(prpBytes, ctx.SignedProposal)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		endorserLogger.Warning(<span class="string">&quot;Endorsement with plugin for&quot;</span>, ctx, <span class="string">&quot; failed:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.WithStack(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp := &amp;pb.ProposalResponse&#123;</span><br><span class="line">		Version:     <span class="number">1</span>,</span><br><span class="line">		Endorsement: endorsement,</span><br><span class="line">		Payload:     prpBytes,</span><br><span class="line">		Response:    ctx.Response,</span><br><span class="line">	&#125;</span><br><span class="line">	endorserLogger.Debug(<span class="string">&quot;Exiting&quot;</span>, ctx)</span><br><span class="line">	<span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统提供的默认背书插件如下，<strong>本质是对交易执行结果和Proposal签名人信息进行签名。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endorse signs the given payload(ProposalResponsePayload bytes), and optionally mutates it.</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// The Endorsement: A signature over the payload, and an identity that is used to verify the signature</span></span><br><span class="line"><span class="comment">// The payload that was given as input (could be modified within this function)</span></span><br><span class="line"><span class="comment">// Or error on failure</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DefaultEndorsement)</span> <span class="title">Endorse</span><span class="params">(prpBytes []<span class="keyword">byte</span>, sp *peer.SignedProposal)</span> <span class="params">(*peer.Endorsement, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 提取Proposal的签名人</span></span><br><span class="line">	signer, err := e.SigningIdentityForRequest(sp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;failed fetching signing identity: %v&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 得到签名人身份</span></span><br><span class="line">	<span class="comment">// serialize the signing identity</span></span><br><span class="line">	identityBytes, err := signer.Serialize()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;could not serialize the signing identity: %v&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对Payload和身份进行签名</span></span><br><span class="line">	<span class="comment">// sign the concatenation of the proposal response and the serialized endorser identity with this endorser&#x27;s key</span></span><br><span class="line">	signature, err := signer.Sign(<span class="built_in">append</span>(prpBytes, identityBytes...))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(fmt.Sprintf(<span class="string">&quot;could not sign the proposal response payload: %v&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	endorsement := &amp;peer.Endorsement&#123;Signature: signature, Endorser: identityBytes&#125;</span><br><span class="line">	<span class="keyword">return</span> endorsement, prpBytes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送Response"><a href="#发送Response" class="headerlink" title="发送Response"></a>发送Response</h3><p><code>ProcessProposal</code> 会把 ProposalResponse 作为返回值，剩下的就交给 gRPC，发送给请求方了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从宏观和源码层面，解读了交易提案背书涉及的数据结构，以及其主要背书流程，核心可以主要包含以下几步：</p>
<ol>
<li>检查Proposal</li>
<li>为交易创建模拟器，并调用模拟器模拟执行交易，生成执行结果</li>
<li>背书模块对执行结果和Proposal身份信息背书（签名），然后生成背书响应发送给客户端</li>
</ol>
<p>关于背书流程，本文未涉及的环节有：</p>
<ol>
<li>Proposal中各字段，层层递进的含义</li>
<li>模拟执行交易，是链码执行函数，并和Peer交互的过程，以及模拟执行的各种资源</li>
<li>2种插件化ESCC的实现</li>
</ol>
<p>后面的章节，会对相关源码实现做进一步分析。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/20/go-gc-1-history-and-priciple/" class="post-title-link" itemprop="url">Go垃圾回收 1：历史和原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-20 11:13:11" itemprop="dateCreated datePublished" datetime="2019-10-20T11:13:11+08:00">2019-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>新老朋友好久不见，我是大彬。今天为大家带来的分享是Go语言垃圾回收，这篇文章筹划的了很久，因为GC也是很强大的一个话题，关于GC已经有很多篇论文还有书籍，想通过一篇文章来介绍Go语言的垃圾回收是困难的，所以决定分几篇文章来完成Go语言垃圾回收的相关话题：</p>
<ol>
<li>Go垃圾回收 1: 历史和原理</li>
<li>Go垃圾回收 2: GC主要流程</li>
<li>Go垃圾回收 3: 源码分析</li>
<li>Go垃圾回收 4: GC对性能的影响与优化</li>
</ol>
<p>虽然划分成了3部分，但每个子话题依然很大，依然难写，依然大而不全，每一篇文章都会有宏观与细节，这样的大而不全对于不了解GC的朋友是好事，即可以有宏观上的认识，又可以有重要细节的感知。</p>
<p>这篇文章就是第一个话题：Go垃圾回收历史和原理，希望各位有所收获。</p>
<h2 id="Go语言垃圾回收简介"><a href="#Go语言垃圾回收简介" class="headerlink" title="Go语言垃圾回收简介"></a>Go语言垃圾回收简介</h2><p><strong>垃圾</strong>指内存中不再使用的内存区域，自动发现与释放这种内存区域的过程就是垃圾回收。</p>
<p>内存资源是有限的，而垃圾回收可以让内存重复使用，并且减轻开发者对内存管理的负担，减少程序中的内存问题。</p>
<p>以下是从网上对垃圾回收的2个定义：</p>
<blockquote>
<ol>
<li>Garbage consists of objects that are dead.</li>
<li>In tracing garbage collection, the term is sometimes used to mean objects that are known to be dead; that is, objects that are unreachable.</li>
</ol>
</blockquote>
<h3 id="Go垃圾回收发展史"><a href="#Go垃圾回收发展史" class="headerlink" title="Go垃圾回收发展史"></a>Go垃圾回收发展史</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.1#performance">go1.1</a>，提高效率和垃圾回收精确度。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.3#garbage_collector">go1.3</a>，提高了垃圾回收的精确度。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.4#runtime">go1.4</a>，之前版本的runtime大部分是使用C写的，这个版本大量使用Go进行了重写，让GC有了扫描stack的能力，进一步提高了垃圾回收的精确度。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.5#gc">go1.5</a>，目标是降低GC延迟，采用了<strong>并发标记和并发清除，三色标记</strong>，<strong>write barrier</strong>，以及实现了更好的<strong>回收器调度</strong>，设计<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4/edit">文档1</a>，<a target="_blank" rel="noopener" href="https://golang.org/s/go15gcpacing">文档2</a>，以及这个版本的<a target="_blank" rel="noopener" href="https://talks.golang.org/2015/go-gc.pdf" title="Go talk: go1.5">Go talk</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.6">go1.6</a>，小优化，当程序使用大量内存时，GC暂停时间有所降低。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.7">go1.7</a>，小优化，当程序有大量空闲goroutine，stack大小波动比较大时，GC暂停时间有显著降低。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.8">go1.8</a>，<strong>write barrier切换到hybrid write barrier</strong>，以消除STW中的re-scan，把STW的最差情况降低到<strong>50us</strong>，设计<a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">文档</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.9#gc">go1.9</a>，提升指标比较多，1）过去 <a target="_blank" rel="noopener" href="https://golang.org/pkg/runtime/#GC"><code>runtime.GC</code></a>, <a target="_blank" rel="noopener" href="https://golang.org/pkg/runtime/debug/#SetGCPercent"><code>debug.SetGCPercent</code></a>, 和 <a target="_blank" rel="noopener" href="https://golang.org/pkg/runtime/debug/#FreeOSMemory"><code>debug.FreeOSMemory</code></a>都不能触发<strong>并发GC</strong>，他们触发的GC都是阻塞的，go1.9可以了，变成了在垃圾回收之前只阻塞调用GC的goroutine。2）<a target="_blank" rel="noopener" href="https://golang.org/pkg/runtime/debug/#SetGCPercent"><code>debug.SetGCPercent</code></a>只在有必要的情况下才会触发GC。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.10#performance">go.1.10</a>，小优化，加速了GC，程序应当运行更快<em>一点点</em>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://golang.org/doc/go1.12">go1.12</a>，显著提高了堆内存存在大碎片情况下的sweeping性能，能够降低GC后立即分配内存的延迟。</p>
</li>
</ul>
<p>以上的历史版本信息都来自<a target="_blank" rel="noopener" href="https://golang.org/doc/devel/release.html">Go release归档</a>，有兴趣可以去翻阅一下。</p>
<h3 id="Go垃圾回收主要流程"><a href="#Go垃圾回收主要流程" class="headerlink" title="Go垃圾回收主要流程"></a>Go垃圾回收主要流程</h3><p>下面这幅图来自Go1.5的<a target="_blank" rel="noopener" href="https://talks.golang.org/2015/go-gc.pdf" title="Go talk: go1.5">go talk</a>，虽然go1.12的GC与go1.5有了许多改变，但总体的流程没有较大改变，并且也找不到官方更新的图了，所有就用这幅图介绍GC主流程。</p>
<p><img src="https://lessisbetter.site/images/2019-10-gc-go1.7.png" alt="Go GC"></p>
<p>Go 垃圾回收是分<strong>轮次</strong>的，每一轮GC都是从 Off 状态开始，如果不是 Off 状态，则代表上一轮GC还未完成，如果这时修改指针的值，是直接修改的。</p>
<p>Go 垃圾回收的主要分2部分，第1部分是扫描所有对象进行三色标记，标记为黑色、灰色和白色，标记完成后只有黑色和白色对象，黑色代表使用中对象，白色对象代表垃圾，灰色是白色过渡到黑色的中间临时状态，第2部分是清扫垃圾，即清理白色对象。</p>
<p>第1部分包含了栈扫描、标记和标记结束3个阶段。在栈扫描之前有2个重要的准备：STW（Stop The World）和开启<strong>写屏障</strong>（WB，Write Barrier）。</p>
<p>STW是为了暂停当前所有运行中的goroutine，进行一些准备工作，比如开启WB，把全局变量，以及每个goroutine中的 <strong>Root对象</strong> 收集起来，Root对象是标记扫描的源头，可以从Root对象依次索引到使用中的对象。</p>
<p><img src="https://lessisbetter.site/images/2019-10-obj-tree.png" alt="Objects Reference Tree"></p>
<blockquote>
<p>假设内存中的对象用圆圈表示，那根据对象的指向关系，所有的对象可以组成若干依赖树，每一个 Root对象 都是树根，按图索骥能找到每一个使用中的对象。但树根不一定是Root对象，也有可能是垃圾，使用灰色树根代表Root对象，白色树根代表垃圾。</p>
</blockquote>
<p>每个P都有一个 <code>mcache</code> ，每个 <code>mcache</code> 都有1个Span用来存放 TinyObject，TinyObject 都是不包含指针的对象，所以这些对象可以直接标记为黑色，然后关闭 STW。</p>
<blockquote>
<p>如果不了解mcache和Tiny对象，赶紧翻一下这篇文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3gGbJaeuvx4klqcv34hmmw" title="Go内存分配那些事，就这么简单!">Go内存分配那些事</a>。</p>
</blockquote>
<p>每个P都有1个进行扫描标记的 goroutine，可以进行并发标记，关闭STW后，这些 goroutine 就变成可运行状态，接收 Go Scheduler 的调度，被调度时执行1轮标记，它负责第1部分任务：栈扫描、标记和标记结束。</p>
<p><strong>栈扫描阶段</strong>就是把前面搜集的Root对象找出来，标记为黑色，然后把它们引用的对象也找出来，标记为灰色，并且加入到<strong>gcWork队列</strong>，gcWork队列保存了灰色的对象，每个灰色的对象都是一个Work。</p>
<p>后面可以进入<strong>标记阶段</strong>，它是一个循环，不断的从gcWork队列中取出work，所指向的对象标记为黑色，该对象指向的对象标记为灰色，然后加入队列，直到队列为空。</p>
<p>然后进入<strong>标记结束阶段</strong>，再次开启STW，不同的版本处理方式是不同的。</p>
<p>在Go1.7的版本是<strong>Dijkstra写屏障</strong>，这个写屏障只监控堆上指针数据的变动，由于成本原因，没有监控栈上指针的变动，由于应用goroutine和GC的标记goroutine都在运行，当栈上的指针指向的对象变更为白色对象时，这个白色对象应当标记为黑色，需要再次扫描全局变量和栈，以免释放这类不该释放的对象。</p>
<p>在Go1.8及以后的版本引入了<strong>混合写屏障</strong>，这个写屏障依然不监控栈上指针的变动，但是它的策略，使得无需再次扫描栈和全局变量，但依然需要STW然后进行一些检查。</p>
<p>标记结束阶段的最后会关闭写屏障，然后关闭STW，唤醒熟睡已久的负责清扫垃圾的goroutine。</p>
<p><strong>清扫goroutine是应用启动后立即创建的一个后台goroutine</strong>，它会立刻进入睡眠，等待被唤醒，然后执行垃圾清理：把白色对象挨个清理掉，清扫goroutine和应用goroutine是并发进行的。清扫完成之后，它再次进入睡眠状态，等待下次被唤醒。</p>
<p>最后执行一些数据统计和状态修改的工作，并且设置好触发下一轮GC的阈值，把GC状态设置为Off。</p>
<p><strong>以上就是Go垃圾回收的主要流程，但和go1.12的源码稍微有一些不同</strong>，比如标记结束后，就开始设置各种状态数据以及把GC状态成了Off，在开启一轮GC时，会自动检测当前是否处于Off，如果不是Off，则当前goroutine会调用清扫函数，帮助清扫goroutine一起清扫span，实际的Go垃圾回收流程以源码为准。</p>
<p>主要流程是宏观一点的角度，接下去会扩散一下，介绍主要流程中提到的各种概念，比如三色标记、并发标记清理、STW、写屏障、辅助GC、GC persent。</p>
<h2 id="几类垃圾回收思想"><a href="#几类垃圾回收思想" class="headerlink" title="几类垃圾回收思想"></a>几类垃圾回收思想</h2><p>垃圾回收的研究已经存在了几十年，远在Go诞生之前，就存在了多种垃圾回收的思想，我们这里看几个跟Go垃圾回收相关的几个。</p>
<h3 id="Tracing-GC"><a href="#Tracing-GC" class="headerlink" title="Tracing GC"></a>Tracing GC</h3><p>WIKI介绍：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">https://en.wikipedia.org/wiki/Tracing_garbage_collection</a></p>
<p>Tracing GC 是垃圾回收的一个大类，另外一个大类是<strong>引用计数</strong>，关于各种垃圾回收的类别可以看下这个系列文章<a target="_blank" rel="noopener" href="https://liujiacai.net/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收</a>。</p>
<p>本文主要介绍Tracing GC的简要原理，我们首先看一下引用树的概念。把内存中所有的对象，都作为一个节点，对象A中的指针，指向了对象B，就存在从对象A指向对象B的一条边，对象B也可能指向了其他对象，那么根据指向关系就能生成一颗对象引用树。</p>
<p><img src="https://lessisbetter.site/images/2019-10-obj-ref-tree.png" alt="Objects Reference Tree"></p>
<p>把内存中所有的对象引用树组合起来，就组成了一幅图。</p>
<p><img src="https://lessisbetter.site/images/2019-10-mem-obj.png" alt="Memory Objects"></p>
<p>Tracing GC中有2类对象：</p>
<ol>
<li>可到达对象，即使用中对象</li>
<li>不可到达对象，即垃圾</li>
</ol>
<p>Tracing GC使用对象引用树找到所有可到达的对象，找到可到达对象有2个原则。</p>
<p><strong>原则1：被程序中调用栈，或者全局变量指向的对象是可到达对象。</strong></p>
<p><img src="https://lessisbetter.site/images/2019-10-obj-root.png" alt="Root Objects"></p>
<p><strong>原则2：被可到达对象指向的对象也是可到达对象。</strong></p>
<p>A是可到达的，并且B被A引用，所以B也是可到达的。</p>
<p><img src="https://lessisbetter.site/images/2019-10-obj-reachable.png" alt="Reachable Objects"></p>
<p>Tracing GC使用任何一种图论的遍历算法，都可以从<strong>Root对象</strong>，根据引用关系找到所有的可到达对象，并把他们做标记。Tracing GC扫描后，<strong>黑色</strong>对象为可到达对象，剩下的<strong>白色</strong>对象为不可到达对象。</p>
<blockquote>
<p>原生的 Tracing GC 只有黑色和白色2种颜色。</p>
</blockquote>
<p><img src="https://lessisbetter.site/images/2019-10-obj-traced.png" alt="Tracing GC"></p>
<h3 id="增量式垃圾回收思想"><a href="#增量式垃圾回收思想" class="headerlink" title="增量式垃圾回收思想"></a>增量式垃圾回收思想</h3><p>垃圾回收离不开STW，STW是Stop The World，指会暂停所有正在执行的用户线程/协程，进行垃圾回收的操作，STW为垃圾对象的扫描和标记提供了必要的条件。</p>
<p><strong>非增量式垃圾</strong>回收需要STW，在STW期间完成<strong>所有</strong>垃圾对象的标记，STW结束后慢慢的执行垃圾对象的清理。</p>
<p><strong>增量式垃圾回收</strong>也需要STW，在STW期间完成<strong>部分</strong>垃圾对象的标记，然后结束STW继续执行用户线程，一段时间后再次执行STW再标记<strong>部分</strong>垃圾对象，这个过程会多次重复执行，直到<strong>所有</strong>垃圾对象标记完成。</p>
<p><img src="https://lessisbetter.site/images/2019-10-increment-gc.png" alt="Increment GC"></p>
<p>GC算法有3大性能指标：吞吐量、最大暂停时间（最大的STW占时）、内存占用率。<strong>增量式垃圾回收不能提高吞吐量，但和非增量式垃圾回收相比，每次STW的时间更短，能够降低最大暂停时间</strong>，就是Go每个版本Release Note中提到的GC延迟、GC暂停时间。</p>
<p>下图是非增量式GC和增量式GC的对比：</p>
<p><img src="https://lessisbetter.site/images/2019-10-normal-vs-incremnt.png" alt="Normal V.S. Increment GC"></p>
<blockquote>
<p>以上图片来自 <a target="_blank" rel="noopener" href="https://blog.heroku.com/incremental-gc">Incremental Garbage Collection in Ruby 2.2</a> ，它也很好的介绍了增量式垃圾回收的思想。</p>
</blockquote>
<h3 id="并发垃圾回收"><a href="#并发垃圾回收" class="headerlink" title="并发垃圾回收"></a>并发垃圾回收</h3><p>减少最大暂停时间还有一种思路：并发垃圾回收，注意不是并行垃圾回收。</p>
<p><strong>并行垃圾回收</strong>是每个核上都跑垃圾回收的线程，同时进行垃圾回收，这期间为STW，会暂停用户线程的执行。</p>
<p><strong>并发垃圾回收</strong>是先STW找到所有的Root对象，然后结束STW，让垃圾标记线程和用户线程并发执行，垃圾标记完成后，再次开启STW，再次扫描和标记，以免释放使用中的内存。</p>
<p>并发垃圾回收和并行垃圾回收的重要区别就是不会持续暂停用户线程，并发垃圾回收也降低了STW的时间，达到了减少最大暂停时间的目的。</p>
<p><img src="https://dt-cdn.net/images/the-different-gc-algorithms-510-ed7afde0fb.png"></p>
<blockquote>
<p>图片来自 <a target="_blank" rel="noopener" href="https://www.dynatrace.com/resources/ebooks/javabook/reduce-garbage-collection-pause-time/">Reducing Garbage-Collection Pause Time</a> ，橙色线条为垃圾回收线程的运行，蓝色线条为用户线程。</p>
</blockquote>
<h2 id="Go垃圾回收主要原理"><a href="#Go垃圾回收主要原理" class="headerlink" title="Go垃圾回收主要原理"></a>Go垃圾回收主要原理</h2><h3 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h3><p><strong>为什么需要三色标记？</strong></p>
<p>三色标记的目的，主要是利用Tracing GC做增量式垃圾回收，降低最大暂停时间。原生Tracing GC只有黑色和白色，没有中间的状态，这就要求GC扫描过程必须一次性完成，得到最后的黑色和白色对象。在前面增量式GC中介绍到了，这种方式会存在较大的暂停时间。</p>
<p>三色标记增加了中间状态灰色，增量式GC运行过程中，应用线程的运行可能改变了对象引用树，只要让黑色对象不直接引用白色对象，GC就可以增量式的运行，减少停顿时间。</p>
<p><strong>什么是三色标记？</strong></p>
<p>三色标记，望文生义可以知道它由3种颜色组成：</p>
<ol>
<li>黑色 Black：表示对象是<strong>可达的</strong>，即使用中的对象，黑色是已经被扫描的对象。</li>
<li>灰色 Gary：表示<strong>被黑色对象直接引用的对象</strong>，但还没对它进行扫描。</li>
<li>白色 White：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象。</li>
</ol>
<p>三色标记规则：</p>
<ol>
<li>黑色不能指向白色对象。</li>
<li>即黑色可以指向灰色，灰色可以指向白色。</li>
</ol>
<p>三色标记主要流程：</p>
<ol>
<li>初始所有对象被标记为白色。</li>
<li>寻找所有Root对象，比如被线程直接引用的对象，把Root对象标记为灰色。</li>
<li>把灰色对象标记为黑色，并把它们引用的对象标记为灰色。</li>
<li>持续遍历每一个灰色对象，直到没有灰色对象。</li>
<li>剩余白色对象为垃圾对象。</li>
</ol>
<p>推荐一篇结合Go代码展示了三色标记的过程的优秀文章：<br><a target="_blank" rel="noopener" href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/">Golang’s Real-time GC in Theory and Practice</a> 。</p>
<p><strong>记录三色的方法简介</strong></p>
<p>Go1.12 使用位图和队列结合表示三种颜色状态：</p>
<ol>
<li>白色：位图没有标记被扫描。</li>
<li>灰色：位图被标记已扫描，并且对象在队列。</li>
<li>黑色：位图被标记已扫描，并且对象已从队列弹出。</li>
</ol>
<p>位图是全局的，表示了Heap中内存块是否被扫描，是否包含指针等。</p>
<p>队列有全局的一个和每个P有一个本地队列，扫描对象进行标记的过程，优先处理本P的队列，其思想与P的g本地队列和全局队列类似，减少资源竞争，提高并行化。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>我们结合一段用户代码介绍写屏障：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.Next = B</span><br><span class="line">A.Next = &amp;C&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>三色标记的扫描线程是跟用户线程并发执行的，考虑这种情况：</p>
<p>用户线程执行完 <code>A.Next = B</code> 后，扫描线程把A标记为黑色，B标记为灰色，用户线程执行 <code>A.Next = &amp;C&#123;&#125;</code> ，C是新对象，被标记为白色，由于A已经被扫描，不会重复扫描，所以C不会被标记为灰色，造成了黑色对象指向白色对象的情况，这违反了三色标记中的不变性规则，结果是C被认为是垃圾对象，最终被清扫掉，当访问C时会造成非法内存访问而Panic。</p>
<p>写屏障可以解决这个问题，当对象引用树发生改变时，即对象指向关系发生变化时，将被指向的对象标记为灰色，维护了三色标记的约束：黑色对象不能直接引用白色对象，这避免了使用中的对象被释放。</p>
<p>有写屏障后，用户线程执行 <code>A.Next = &amp;C&#123;&#125;</code> 后，写屏障把C标记为灰色。</p>
<h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h3><p>并发垃圾回收的主要思想上文已经介绍，Go的垃圾回收为每个P都分配了一个gcMarker协程，用于并发标记对象，这样有些P在标记对象，而有些P上继续运行用户协程。</p>
<p>Go的并发标记有4种运行模式，还没深入研究，这里举一个并发标记的场景：在goroutine的调度过程中，如果当前P上已经没有g可以执行，也偷不到g时，P就空闲下来了，这时候可以运行当前P的gcMarker协程。</p>
<h3 id="触发GC"><a href="#触发GC" class="headerlink" title="触发GC"></a>触发GC</h3><p>GC有3种触发方式：</p>
<ul>
<li><p>辅助GC</p>
<p>在分配内存时，会判断当前的Heap内存分配量是否达到了触发一轮GC的阈值（每轮GC完成后，该阈值会被动态设置），如果超过阈值，则启动一轮GC。</p>
</li>
<li><p>调用<code>runtime.GC()</code>强制启动一轮GC。</p>
</li>
<li><p><strong>sysmon</strong>是运行时的守护进程，当超过 <code>forcegcperiod</code> (2分钟)没有运行GC会启动一轮GC。</p>
</li>
</ul>
<h3 id="GC调节参数"><a href="#GC调节参数" class="headerlink" title="GC调节参数"></a>GC调节参数</h3><p>Go垃圾回收不像Java垃圾回收那样，有很多参数可供调节，Go为了保证使用GC的简洁性，只提供了一个参数<code>GOGC</code>。</p>
<p><code>GOGC</code>代表了占用中的内存增长比率，达到该比率时应当触发1次GC，该参数可以通过环境变量设置。</p>
<p>它的单位是百分比，取值范围并不是 [0, 100]，可以是1000，甚至2000，2000时代表2000%，即20倍。</p>
<p>假如当前heap占用内存为4MB，<code>GOGC = 75</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 * (1+75%) &#x3D; 7MB</span><br></pre></td></tr></table></figure>

<p>等heap占用内存大小达到7MB时会触发1轮GC。</p>
<p><code>GOGC</code>还有2个特殊值：</p>
<ol>
<li><code>&quot;off&quot;</code> : 代表关闭GC</li>
<li><code>0</code> : 代表持续进行垃圾回收，只用于调试 </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了Go垃圾回收的发展史，以及Go垃圾回收的一些主要概念，是为掌握Go垃圾回收提供一个基础。下期文章将把本文提到的概念串起来，介绍Go垃圾回收的主要流程，下期见。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1186944">一个专家眼中的Go与Java垃圾回收算法大对比</a></p>
<p>这篇文章介绍了一些垃圾回收的标准，比如GC吞吐量、分配性能、暂停时间等等。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2017/03/garbage-collection-algorithm">理解垃圾回收算法</a></p>
<p>这篇文章介绍了几种常见的垃圾机制，并使用gif展示回收过程。</p>
</li>
</ul>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://liujiacai.net/blog/2018/06/15/garbage-collection-intro/">深入浅出垃圾回收（一）简介篇</a>，<a target="_blank" rel="noopener" href="https://liujiacai.net/blog/2018/08/04/incremental-gc/">深入浅出垃圾回收（三）增量式 GC</a>，<a target="_blank" rel="noopener" href="https://liujiacai.net/blog/2018/08/18/generational-gc/">深入浅出垃圾回收（四）分代式 GC</a></p>
<p>这个系列文章介绍了垃圾回收的概念、策略，以及三色标记等增量回收，以及分代收集。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://engineering.linecorp.com/en/blog/go-gc/">Go gc</a></p>
<p>这篇文章做了Go和Java GC的简单对比表。看起来Go Gc比JVM GC少很多东西，但这其中解释了一些理由。</p>
<p>Go没有使用compaction来解决碎片问题，而是使用了TCMalloc来减缓碎片和优化分配。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>JAVA (JAVA8 HOTSPOT VM)</th>
<th>GO</th>
</tr>
</thead>
<tbody><tr>
<td>Collector</td>
<td>Several collectors (Serial, Parallel, CMS, G1)</td>
<td>CMS</td>
</tr>
<tr>
<td>Compaction</td>
<td>Compacts</td>
<td>Does not compact</td>
</tr>
<tr>
<td>Generational GC</td>
<td>Generational GC</td>
<td>Non-generational GC</td>
</tr>
<tr>
<td>Tuning parameters</td>
<td>Depends on the collector.Multiple parameters available.</td>
<td>Go垃圾回收 only</td>
</tr>
</tbody></table>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d2825bff265da1b6836e8d4">【译】 Golang 中的垃圾回收（一）</a></p>
<p>这篇文章是William Kennedy垃圾回收系列文章的第一篇的译文，这个文章从宏观的角度介绍了垃圾回收的原理，把垃圾回收跟调度结合起来介绍，分析了Go GC是如何实现低延时的。并且详细介绍了并发标记、STW、并发清除等。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://i6448038.github.io/2019/03/04/golang-garbage-collector/">图解Golang的GC算法</a></p>
<p>RyuGou用图的方式简述了三色标记法的标记清除过程以及写屏障。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/">Golang’s Real-time GC in Theory and Practice</a></p>
<p>这篇文章有一个非常棒的GC动画。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.wangriyu.wang/2019/04-Golang-GC.html">学习 Golang GC</a></p>
<p>这篇文章对GC的历史、原理、goroutine栈，Go GC历史，基础原理，触发时间都有介绍，是一篇大而全的文章，但每个部分确实也都不详细，值得再参考。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://legendtkl.com/2017/04/28/golang-gc/">Golang 垃圾回收剖析</a></p>
</li>
</ul>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zkweb/p/7880099.html">Golang源码探索(三) GC的实现原理</a></p>
<p>Go垃圾回收的绝佳源码文章，图文并茂，从内存分配，讲到垃圾回收。</p>
</li>
</ul>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://talks.golang.org/2015/go-gc.pdf">Go talk 2015: Go Gc: Latency Problem Solved</a></p>
<p>go1.5降低GC延迟的PPT介绍。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">Proposal: Eliminate STW stack re-scanning</a></p>
<p>消除Go垃圾回收中第二次STW的re-scanning的提案。</p>
</li>
</ul>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/">http://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple/</a></li>
</ol>
</blockquote>
<div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div>
<img src="https://lessisbetter.site/images/blog-gzh.png" style="border:0"  align=center />
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/20/fabric-event-source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/20/fabric-event-source/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 3：事件(Event)原理解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-20 19:46:41" itemprop="dateCreated datePublished" datetime="2019-09-20T19:46:41+08:00">2019-09-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Event是应用和Fabric网络交互的一种方式，应用可以通过<strong>SDK</strong>向<strong>Peer</strong>订阅某种类型的事件，当Peer发现事件发生时，可以把Event发送给应用，应用获取到通知信息。</p>
<h2 id="Event功能介绍"><a href="#Event功能介绍" class="headerlink" title="Event功能介绍"></a>Event功能介绍</h2><p>Event从来源上可以分为2类：</p>
<ol>
<li>链码容器发出的Event</li>
<li>Peer上账本变更发出的Event</li>
</ol>
<p><img src="https://lessisbetter.site/images/2019-09-sdk-event.png" alt="fabric event"></p>
<p><em>图源自<a target="_blank" rel="noopener" href="https://medium.com/coinmonks/tutorial-chaincode-event-listener-on-hyperledger-fabric-java-sdk-557304f1fe28">Tutorial Chaincode Event Listener on Hyperledger Fabric Java SDK</a></em></p>
<p>翻阅Node SDK和Go SDK的文档，发现SDK提供了4类事件：</p>
<ol>
<li>BlockEvent，可以用来监控被添加到账本上的区块。客户端需要Admin权限，这样才能读取完整的区块，每产生一个区块，它都会接收到通知。区块中有交易，交易中有chaincode event，所以可以通过BlockEvent获取其他事件。</li>
<li>FilteredBlockEvent，可以用来监控简要的区块信息，当不只关心区块包含了哪些交易，交易是否成功时，它非常实用，还可以降低网络负载。它包含区块的部分信息，所以被称为filtered，信息有channel ID，区块号，交易的validation code。</li>
<li>TransactionStatusEvent，可以用来监控某个交易在当前组织的peer何时完成。可以得到交易的validation code和交易所在区块。</li>
<li>ChaincodeEvent，用来监听Chaincode发出的事件，不同的链码可以自定义自己的事件，所以这个更具有个性化。包含了交易id、区块号、链码id、事件名称，事件内容。如果想要查看事件内容，客户端所使用的账号，必须是Admin权限。</li>
</ol>
<p>另外，订阅事件时可以指定开启和结束的区块号范围，如果开始的区块号已经产生，即区块已经写入账本，可以重放事件，更多信息可以看下面的文档。</p>
<p>关于Event的2篇重要文档，深深感觉Node SDK的文档，比Go SDK的文档丰富。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://fabric-sdk-node.github.io/tutorial-channel-events.html">Hyperledger Fabric SDK for node.js Tutorial: How to use the channel-based event service</a></li>
<li><a target="_blank" rel="noopener" href="https://hyperledger-fabric-cn.readthedocs.io/zh/latest/peer_event_services.html">Peer channel-based event services — hyperledger-fabricdocs master 文档</a></li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>上一节的介绍能够知道有哪些Event，各有什么作用，这一节介绍SDK和Peer是如何进行事件交互的。</p>
<p>SDK和Peer之间是通过gRPC通信的，gRPC的<a target="_blank" rel="noopener" href="https://github.com/hyperledger/fabric/blob/release-1.4/protos/peer/events.proto">protos的定义文件</a>4种message：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FilteredBlock，给FilteredBlockEvent使用</span><br><span class="line">FilteredTransaction，结合下一个，给FilteredTransactionEvent使用</span><br><span class="line">FilteredTransactionActions</span><br><span class="line">FilteredChaincodeAction，给ChaincodeEvent使用</span><br></pre></td></tr></table></figure>

<p>和1个Response，其中使用了oneof。</p>
<ul>
<li>status，指http status，成功的时候无需使用，错误的时候可以使用指明错误。</li>
<li>block，给BlockEvent使用</li>
<li>FilteredBlock，给另外3种事件使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; DeliverResponse</span><br><span class="line">message DeliverResponse &#123;</span><br><span class="line">    oneof Type &#123;</span><br><span class="line">        common.Status status &#x3D; 1;</span><br><span class="line">        common.Block block &#x3D; 2;</span><br><span class="line">        FilteredBlock filtered_block &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及2个gRPC通信接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">service Deliver &#123;</span><br><span class="line">    &#x2F;&#x2F; deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span><br><span class="line">    &#x2F;&#x2F; Payload data as a marshaled orderer.SeekInfo message,</span><br><span class="line">    &#x2F;&#x2F; then a stream of block replies is received</span><br><span class="line">    rpc Deliver (stream common.Envelope) returns (stream DeliverResponse) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span><br><span class="line">    &#x2F;&#x2F; Payload data as a marshaled orderer.SeekInfo message,</span><br><span class="line">    &#x2F;&#x2F; then a stream of **filtered** block replies is received</span><br><span class="line">    rpc DeliverFiltered (stream common.Envelope) returns (stream DeliverResponse) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咦，4个Event，怎么只有2个接口？</p>
<p>配合下图，我们做一番讲解。</p>
<p><img src="https://lessisbetter.site/images/2019-11-fabric-events.png" alt="fabric sdk go event"></p>
<p>对于Peer而言，只有2中类型的订阅：</p>
<ol>
<li>BlockEvent，即完整的区块</li>
<li>FilteredBlockEvent，即不完整的区块，可以根据FilteredBlockEvent中的信息，生成FilteredTransactionEvent信息和ChainCodeEvent信息</li>
</ol>
<p>图中深蓝色和绿色的线分别代表BlockEvent和FilteredBlockEvent相关的数据流，BlockEvent使用的是Deliver函数，FilteredBlockEvent使用的是DeliverFiltered函数。</p>
<p>每一个事件订阅，都是一个gRPC连接，Peer会不断的从账本读区块，然后根据区块生成事件，发送给客户端。</p>
<p>Go SDK中实现了一个Dispatcher，就是提供这么一个中转的功能，对上层应用提供4中类型的事件，把4种事件注册请求转换为2种，调用DeliverClient把事件订阅请求发送给Peer，又把Peer发来的2种事件，转换为应用订阅的事件响应。</p>
<p>Peer启动时，启动gRPC服务后，会注册好DeliverServer接收事件订阅，然后调用deliverBlocks进入循环，在新区块产生后，会生成订阅的BlockEvent或FilteredBlockEvent，利用ResponseSender把事件发送给SDK。</p>
<h2 id="event-pb-go源码"><a href="#event-pb-go源码" class="headerlink" title="event.pb.go源码"></a>event.pb.go源码</h2><p>这就是根据<code>events.proto</code>生成的Go文件，负责创建gRPC通信的客户端和服务端，以及两边的消息发送。</p>
<p>主要关注下2个接口：</p>
<p><code>deliverClient</code>实现了<code>DeliverClient</code>，已经在该源文件实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeliverClient is the client API for Deliver service.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.</span></span><br><span class="line"><span class="keyword">type</span> DeliverClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line">	<span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line">	<span class="comment">// then a stream of block replies is received</span></span><br><span class="line">	Deliver(ctx context.Context, opts ...grpc.CallOption) (Deliver_DeliverClient, error)</span><br><span class="line">	<span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line">	<span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line">	<span class="comment">// then a stream of **filtered** block replies is received</span></span><br><span class="line">	DeliverFiltered(ctx context.Context, opts ...grpc.CallOption) (Deliver_DeliverFilteredClient, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DeliverServer</code>是服务端的接口，需要Peer实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeliverServer is the server API for Deliver service.</span></span><br><span class="line"><span class="keyword">type</span> DeliverServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line">	<span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line">	<span class="comment">// then a stream of block replies is received</span></span><br><span class="line">	Deliver(Deliver_DeliverServer) error</span><br><span class="line">	<span class="comment">// deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with</span></span><br><span class="line">	<span class="comment">// Payload data as a marshaled orderer.SeekInfo message,</span></span><br><span class="line">	<span class="comment">// then a stream of **filtered** block replies is received</span></span><br><span class="line">	DeliverFiltered(Deliver_DeliverFilteredServer) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Peer-event源码"><a href="#Peer-event源码" class="headerlink" title="Peer event源码"></a>Peer event源码</h2><p>Peer干了这么几件事：</p>
<ol>
<li>注册gRPC服务，即注册接受客户端发来的事件订阅的函数</li>
<li>gRPC收到消息，订阅相应事件注册处理函数</li>
<li>处理函数持续向客户端发送区块事件，直到结束</li>
</ol>
<h3 id="添加Deliver服务"><a href="#添加Deliver服务" class="headerlink" title="添加Deliver服务"></a>添加Deliver服务</h3><p><code>serve</code>是Peer启动后的运行的主函数，它会创建gRPC server，以及创建DeliverEvent server，并把它绑定到gRPC server上。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer/node/start.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建peer的gRPC server</span></span><br><span class="line">    peerServer, err := peer.NewPeerServer(listenAddr, serverConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Fatalf(<span class="string">&quot;Failed to create peer server (%s)&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建和启动基于gRPC的event deliver server</span></span><br><span class="line">    abServer := peer.NewDeliverEventsServer(mutualTLS, policyCheckerProvider, &amp;peer.DeliverChainManager&#123;&#125;, metricsProvider)</span><br><span class="line">    pb.RegisterDeliverServer(peerServer.Server(), abServer)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建DeliverEventsServer，实际是创建好处理事件订阅的handler。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core/peer/deliverevents.go</span></span><br><span class="line"><span class="comment">// NewDeliverEventsServer creates a peer.Deliver server to deliver block and</span></span><br><span class="line"><span class="comment">// filtered block events</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeliverEventsServer</span><span class="params">(mutualTLS <span class="keyword">bool</span>, policyCheckerProvider PolicyCheckerProvider, chainManager deliver.ChainManager, metricsProvider metrics.Provider)</span> <span class="title">peer</span>.<span class="title">DeliverServer</span></span> &#123;</span><br><span class="line">	timeWindow := viper.GetDuration(<span class="string">&quot;peer.authentication.timewindow&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> timeWindow == <span class="number">0</span> &#123;</span><br><span class="line">		defaultTimeWindow := <span class="number">15</span> * time.Minute</span><br><span class="line">		logger.Warningf(<span class="string">&quot;`peer.authentication.timewindow` not set; defaulting to %s&quot;</span>, defaultTimeWindow)</span><br><span class="line">		timeWindow = defaultTimeWindow</span><br><span class="line">	&#125;</span><br><span class="line">	metrics := deliver.NewMetrics(metricsProvider)</span><br><span class="line">	<span class="keyword">return</span> &amp;server&#123;</span><br><span class="line">		<span class="comment">// 创建handler</span></span><br><span class="line">		dh:                    deliver.NewHandler(chainManager, timeWindow, mutualTLS, metrics),</span><br><span class="line">		policyCheckerProvider: policyCheckerProvider,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewHandler creates an implementation of the Handler interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHandler</span><span class="params">(cm ChainManager, timeWindow time.Duration, mutualTLS <span class="keyword">bool</span>, metrics *Metrics)</span> *<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Handler&#123;</span><br><span class="line">		ChainManager:     cm,</span><br><span class="line">		TimeWindow:       timeWindow,</span><br><span class="line">		BindingInspector: InspectorFunc(comm.NewBindingInspector(mutualTLS, ExtractChannelHeaderCertHash)),</span><br><span class="line">		Metrics:          metrics,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>server</code>实现了<code>DeliverServer</code>接口，当gRPC接收到事件注册时，就可以调用Deliver或者FilteredDeliver被调用时，就调用server的<code>DeliverFiltered</code>或者<code>Deliver</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; server holds the dependencies necessary to create a deliver server</span><br><span class="line">type server struct &#123;</span><br><span class="line">	dh                    *deliver.Handler</span><br><span class="line">	policyCheckerProvider PolicyCheckerProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收事件订阅"><a href="#接收事件订阅" class="headerlink" title="接收事件订阅"></a>接收事件订阅</h3><p>BlockEvent的注册和事件处理主要流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.Deliver -&gt; Handler.Handle -&gt;</span><br><span class="line">deliverBlocks -&gt; SendBlockResponse -&gt; blockResponseSender.SendBlockResponse -&gt; gRPC生成的server Send函数</span><br></pre></td></tr></table></figure>

<p>FilteredBlockEvent的注册和事件处理主要流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.DeliverFiltered -&gt; Handler.Handle -&gt;</span><br><span class="line">deliverBlocks -&gt; SendBlockResponse -&gt; filteredBlockResponseSender.SendBlockResponseg -&gt; RPC生成的server Send函数</span><br></pre></td></tr></table></figure>

<p>它们2个流程是类似的，下面就以BlockEvent的流程介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Deliver sends a stream of blocks to a client after commitment</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span> <span class="title">Deliver</span><span class="params">(srv peer.Deliver_DeliverServer)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">&quot;Starting new Deliver handler&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> dumpStacktraceOnPanic()</span><br><span class="line">	<span class="comment">// getting policy checker based on resources.Event_Block resource name</span></span><br><span class="line">	deliverServer := &amp;deliver.Server&#123;</span><br><span class="line">		PolicyChecker: s.policyCheckerProvider(resources.Event_Block),</span><br><span class="line">		Receiver:      srv,</span><br><span class="line">		<span class="comment">// 创建了sender</span></span><br><span class="line">		ResponseSender: &amp;blockResponseSender&#123;</span><br><span class="line">			Deliver_DeliverServer: srv,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.dh.Handle(srv.Context(), deliverServer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle receives incoming deliver requests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Handle</span><span class="params">(ctx context.Context, srv *Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	addr := util.ExtractRemoteAddress(ctx)</span><br><span class="line">	logger.Debugf(<span class="string">&quot;Starting new deliver loop for %s&quot;</span>, addr)</span><br><span class="line">	h.Metrics.StreamsOpened.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> h.Metrics.StreamsClosed.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		logger.Debugf(<span class="string">&quot;Attempting to read seek info message from %s&quot;</span>, addr)</span><br><span class="line">		envelope, err := srv.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			logger.Debugf(<span class="string">&quot;Received EOF from %s, hangup&quot;</span>, addr)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Warningf(<span class="string">&quot;Error reading from %s: %s&quot;</span>, addr, err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 主体</span></span><br><span class="line">		status, err := h.deliverBlocks(ctx, srv, envelope)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = srv.SendStatusResponse(status)</span><br><span class="line">		<span class="keyword">if</span> status != cb.Status_SUCCESS &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Warningf(<span class="string">&quot;Error sending to %s: %s&quot;</span>, addr, err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		logger.Debugf(<span class="string">&quot;Waiting for new SeekInfo from %s&quot;</span>, addr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>deliverBlocks</code>的主要作用就是不停的获取区块，然后调用sender发送事件，其中还包含了事件订阅信息的获取，错误处理等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">deliverBlocks</span><span class="params">(ctx context.Context, srv *Server, envelope *cb.Envelope)</span> <span class="params">(status cb.Status, err error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">var</span> block *cb.Block</span><br><span class="line">		<span class="keyword">var</span> status cb.Status</span><br><span class="line"></span><br><span class="line">		iterCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 获取下一个区块，当账本Append Block时，就可以拿到要写入到账本的区块</span></span><br><span class="line">			block, status = cursor.Next()</span><br><span class="line">			<span class="built_in">close</span>(iterCh)</span><br><span class="line">		&#125;()</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 发送区块</span></span><br><span class="line">		<span class="keyword">if</span> err := srv.SendBlockResponse(block); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.Warningf(<span class="string">&quot;[channel: %s] Error sending to %s: %s&quot;</span>, chdr.ChannelId, addr, err)</span><br><span class="line">			<span class="keyword">return</span> cb.Status_INTERNAL_SERVER_ERROR, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		h.Metrics.BlocksSent.With(labels...).Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 停止判断</span></span><br><span class="line">		<span class="keyword">if</span> stopNum == block.Header.Number &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Iterator</code>接口用来获取区块.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iterator is useful for a chain Reader to stream blocks as they are created</span></span><br><span class="line"><span class="keyword">type</span> Iterator <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Next blocks until there is a new block available, or returns an error if</span></span><br><span class="line">	<span class="comment">// the next block is no longer retrievable</span></span><br><span class="line">	Next() (*cb.Block, cb.Status)</span><br><span class="line">	<span class="comment">// Close releases resources acquired by the Iterator</span></span><br><span class="line">	Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fabric有3种类型的账本：ram、json和file，它们都实现了这个接口，这里主要是为了辅助解释事件机制，我们看一个最简单的：ram的实现。</p>
<p><code>Next()</code>拿到的区块是从<code>simpleList.SetNext()</code>存进去的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next blocks until there is a new block available, or returns an error if the</span></span><br><span class="line"><span class="comment">// next block is no longer retrievable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cu *cursor)</span> <span class="title">Next</span><span class="params">()</span> <span class="params">(*cb.Block, cb.Status)</span></span> &#123;</span><br><span class="line">	<span class="comment">// This only loops once, as signal reading indicates non-nil next</span></span><br><span class="line">	<span class="comment">// 实际只执行1次</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 拿到区块</span></span><br><span class="line">		next := cu.list.getNext()</span><br><span class="line">		<span class="keyword">if</span> next != <span class="literal">nil</span> &#123;</span><br><span class="line">			cu.list = next</span><br><span class="line">			<span class="keyword">return</span> cu.list.block, cb.Status_SUCCESS</span><br><span class="line">		&#125;</span><br><span class="line">		&lt;-cu.list.signal</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *simpleList)</span> <span class="title">getNext</span><span class="params">()</span> *<span class="title">simpleList</span></span> &#123;</span><br><span class="line">	s.lock.RLock()</span><br><span class="line">	<span class="keyword">defer</span> s.lock.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> s.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *simpleList)</span> <span class="title">setNext</span><span class="params">(n *simpleList)</span></span> &#123;</span><br><span class="line">	s.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.lock.Unlock()</span><br><span class="line">	s.next = n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Append()</code>是账本对外提供的接口，当要把区块追加到账本时，会调用此函数，该函数会调用<code>setNext()</code>设置待追加的区块。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Append appends a new block to the ledger</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *ramLedger)</span> <span class="title">Append</span><span class="params">(block *cb.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	rl.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rl.lock.Unlock()</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	rl.appendBlock(block)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rl *ramLedger)</span> <span class="title">appendBlock</span><span class="params">(block *cb.Block)</span></span> &#123;</span><br><span class="line">	next := &amp;simpleList&#123;</span><br><span class="line">		signal: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		block:  block,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置最新的区块</span></span><br><span class="line">	rl.newest.setNext(next)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送事件消息"><a href="#发送事件消息" class="headerlink" title="发送事件消息"></a>发送事件消息</h3><p><code>blockResponseSender.SendBlockResponse</code>是BlockEvent的事件发送函数，实际就是调用gRPC生成的函数。</p>
<p><code>blockResponseSender</code>是在<code>server.Deliver</code>中创建的，它实际就是<code>peer.Deliver_DeliverServer</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blockResponseSender structure used to send block responses</span></span><br><span class="line"><span class="keyword">type</span> blockResponseSender <span class="keyword">struct</span> &#123;</span><br><span class="line">	peer.Deliver_DeliverServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SendBlockResponse generates deliver response with block message</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(brs *blockResponseSender)</span> <span class="title">SendBlockResponse</span><span class="params">(block *common.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	response := &amp;peer.DeliverResponse&#123;</span><br><span class="line">		Type: &amp;peer.DeliverResponse_Block&#123;Block: block&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> brs.Send(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Go-SDK源码"><a href="#Go-SDK源码" class="headerlink" title="Go SDK源码"></a>Go SDK源码</h2><p>社区正在重构fabric-sdk-go，所以这里不着重介绍sdk的源码了，提醒几个重要的点，可能以后还有。</p>
<p><code>Deliver</code>和<code>DeliverFiltered</code>被封装成了2个全局函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">	&#x2F;&#x2F; Deliver creates a Deliver stream</span><br><span class="line">	Deliver &#x3D; func(client pb.DeliverClient) (deliverStream, error) &#123;</span><br><span class="line">		return client.Deliver(context.Background())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; DeliverFiltered creates a DeliverFiltered stream</span><br><span class="line">	DeliverFiltered &#x3D; func(client pb.DeliverClient) (deliverStream, error) &#123;</span><br><span class="line">		return client.DeliverFiltered(context.Background())</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>它们会被调用，进一步封装成provider，provider会为dispatch服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deliverProvider is the connection provider used for connecting to the Deliver service</span></span><br><span class="line"><span class="keyword">var</span> deliverProvider = <span class="function"><span class="keyword">func</span><span class="params">(context fabcontext.Client, chConfig fab.ChannelCfg, peer fab.Peer)</span> <span class="params">(api.Connection, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> peer == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Peer is nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	eventEndpoint, ok := peer.(api.EventEndpoint)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;peer is not an EventEndpoint&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> deliverconn.New(context, chConfig, deliverconn.Deliver, peer.URL(), eventEndpoint.Opts()...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p><code>Dispatcher</code>会保存BlockEvent和FilteredBlockEvent的注册，以及用2个map<code>txRegistrations</code>和<code>ccRegistrations</code>保存交易和Chaincode Event的注册，<code>handlers</code>是各种注册事件的处理函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatcher is responsible for handling all events, including connection and registration events originating from the client,</span></span><br><span class="line"><span class="comment">// and events originating from the channel event service. All events are processed in a single Go routine</span></span><br><span class="line"><span class="comment">// in order to avoid any race conditions and to ensure that events are processed in the order in which they are received.</span></span><br><span class="line"><span class="comment">// This also avoids the need for synchronization.</span></span><br><span class="line"><span class="comment">// The lastBlockNum member MUST be first to ensure it stays 64-bit aligned on 32-bit machines.</span></span><br><span class="line"><span class="keyword">type</span> Dispatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	lastBlockNum <span class="keyword">uint64</span> <span class="comment">// Must be first, do not move</span></span><br><span class="line">	params</span><br><span class="line">	updateLastBlockInfoOnly    <span class="keyword">bool</span></span><br><span class="line">	state                      <span class="keyword">int32</span></span><br><span class="line">	eventch                    <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	blockRegistrations         []*BlockReg</span><br><span class="line">	filteredBlockRegistrations []*FilteredBlockReg</span><br><span class="line">	handlers                   <span class="keyword">map</span>[reflect.Type]Handler</span><br><span class="line">	txRegistrations            <span class="keyword">map</span>[<span class="keyword">string</span>]*TxStatusReg</span><br><span class="line">	ccRegistrations            <span class="keyword">map</span>[<span class="keyword">string</span>]*ChaincodeReg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h3><p>这是Dispatcher的事件注册函数，在它眼里，不止有4个事件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterHandler registers an event handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">RegisterHandler</span><span class="params">(t <span class="keyword">interface</span>&#123;&#125;, h Handler)</span></span> &#123;</span><br><span class="line">	htype := reflect.TypeOf(t)</span><br><span class="line">	<span class="keyword">if</span> _, ok := ed.handlers[htype]; !ok &#123;</span><br><span class="line">		logger.Debugf(<span class="string">&quot;Registering handler for %s on dispatcher %T&quot;</span>, htype, ed)</span><br><span class="line">		ed.handlers[htype] = h</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		logger.Debugf(<span class="string">&quot;Cannot register handler %s on dispatcher %T since it&#x27;s already registered&quot;</span>, htype, ed)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册各注册事件的处理函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterHandlers registers all of the handlers by event type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">RegisterHandlers</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ed.RegisterHandler(&amp;RegisterChaincodeEvent&#123;&#125;, ed.handleRegisterCCEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;RegisterTxStatusEvent&#123;&#125;, ed.handleRegisterTxStatusEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;RegisterBlockEvent&#123;&#125;, ed.handleRegisterBlockEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;RegisterFilteredBlockEvent&#123;&#125;, ed.handleRegisterFilteredBlockEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;UnregisterEvent&#123;&#125;, ed.handleUnregisterEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;StopEvent&#123;&#125;, ed.HandleStopEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;TransferEvent&#123;&#125;, ed.HandleTransferEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;StopAndTransferEvent&#123;&#125;, ed.HandleStopAndTransferEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;RegistrationInfoEvent&#123;&#125;, ed.handleRegistrationInfoEvent)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following events are used for testing only</span></span><br><span class="line">	ed.RegisterHandler(&amp;fab.BlockEvent&#123;&#125;, ed.handleBlockEvent)</span><br><span class="line">	ed.RegisterHandler(&amp;fab.FilteredBlockEvent&#123;&#125;, ed.handleFilteredBlockEvent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="接收Peer事件"><a href="#接收Peer事件" class="headerlink" title="接收Peer事件"></a>接收Peer事件</h3><p><code>handleEvent</code>用来处理来自Peer的事件，不同的类型调用不同的handler。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">handleEvent</span><span class="params">(e esdispatcher.Event)</span></span> &#123;</span><br><span class="line">	delevent := e.(*connection.Event)</span><br><span class="line">	evt := delevent.Event.(*pb.DeliverResponse)</span><br><span class="line">	<span class="keyword">switch</span> response := evt.Type.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *pb.DeliverResponse_Status:</span><br><span class="line">		ed.handleDeliverResponseStatus(response)</span><br><span class="line">	<span class="keyword">case</span> *pb.DeliverResponse_Block:</span><br><span class="line">		ed.HandleBlock(response.Block, delevent.SourceURL)</span><br><span class="line">	<span class="keyword">case</span> *pb.DeliverResponse_FilteredBlock:</span><br><span class="line">		ed.HandleFilteredBlock(response.FilteredBlock, delevent.SourceURL)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		logger.Errorf(<span class="string">&quot;handler not found for deliver response type %T&quot;</span>, response)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>HandleBlock</code>把Event封装是BlockEvent退给应用。可以看到BlockEvent也会发布FilteredBlockEvent。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleBlock handles a block event</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">HandleBlock</span><span class="params">(block *cb.Block, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">&quot;Handling block event - Block #%d&quot;</span>, block.Header.Number)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := ed.updateLastBlockNum(block.Header.Number); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Error(err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ed.updateLastBlockInfoOnly &#123;</span><br><span class="line">		ed.updateLastBlockInfoOnly = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Debug(<span class="string">&quot;Publishing block event...&quot;</span>)</span><br><span class="line">	ed.publishBlockEvents(block, sourceURL)</span><br><span class="line">	ed.publishFilteredBlockEvents(toFilteredBlock(block), sourceURL)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishBlockEvents</span><span class="params">(block *cb.Block, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, reg := <span class="keyword">range</span> ed.blockRegistrations &#123;</span><br><span class="line">		<span class="keyword">if</span> !reg.Filter(block) &#123;</span><br><span class="line">			logger.Debugf(<span class="string">&quot;Not sending block event for block #%d since it was filtered out.&quot;</span>, block.Header.Number)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reg.Eventch &lt;- NewBlockEvent(block, sourceURL):</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				logger.Warn(<span class="string">&quot;Unable to send to block event channel.&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">			reg.Eventch &lt;- NewBlockEvent(block, sourceURL)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reg.Eventch &lt;- NewBlockEvent(block, sourceURL):</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">				logger.Warn(<span class="string">&quot;Timed out sending block event.&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FilteredBlockEvent能解析出TransactionEvent和ChaincodeEvent：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishFilteredBlockEvents</span><span class="params">(fblock *pb.FilteredBlock, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fblock == <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Warn(<span class="string">&quot;Filtered block is nil. Event will not be published&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Debugf(<span class="string">&quot;Publishing filtered block event: %#v&quot;</span>, fblock)</span><br><span class="line"></span><br><span class="line">	checkFilteredBlockRegistrations(ed, fblock, sourceURL)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> fblock.FilteredTransactions &#123;</span><br><span class="line">		<span class="comment">// 发布交易订阅</span></span><br><span class="line">		ed.publishTxStatusEvents(tx, fblock.Number, sourceURL)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only send a chaincode event if the transaction has committed</span></span><br><span class="line">		<span class="keyword">if</span> tx.TxValidationCode == pb.TxValidationCode_VALID &#123;</span><br><span class="line">			txActions := tx.GetTransactionActions()</span><br><span class="line">			<span class="keyword">if</span> txActions == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(txActions.ChaincodeActions) == <span class="number">0</span> &#123;</span><br><span class="line">				logger.Debugf(<span class="string">&quot;No chaincode action found for TxID[%s], block[%d], source URL[%s]&quot;</span>, tx.Txid, fblock.Number, sourceURL)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, action := <span class="keyword">range</span> txActions.ChaincodeActions &#123;</span><br><span class="line">				<span class="keyword">if</span> action.ChaincodeEvent != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="comment">// 发布chaincode event订阅</span></span><br><span class="line">					ed.publishCCEvents(action.ChaincodeEvent, fblock.Number, sourceURL)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			logger.Debugf(<span class="string">&quot;Cannot publish CCEvents for block[%d] and source URL[%s] since Tx Validation Code[%d] is not valid&quot;</span>, fblock.Number, sourceURL, tx.TxValidationCode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishTxStatusEvents</span><span class="params">(tx *pb.FilteredTransaction, blockNum <span class="keyword">uint64</span>, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	logger.Debugf(<span class="string">&quot;Publishing Tx Status event for TxID [%s]...&quot;</span>, tx.Txid)</span><br><span class="line">	<span class="keyword">if</span> reg, ok := ed.txRegistrations[tx.Txid]; ok &#123;</span><br><span class="line">		logger.Debugf(<span class="string">&quot;Sending Tx Status event for TxID [%s] to registrant...&quot;</span>, tx.Txid)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL):</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				logger.Warn(<span class="string">&quot;Unable to send to Tx Status event channel.&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">			reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> reg.Eventch &lt;- NewTxStatusEvent(tx.Txid, tx.TxValidationCode, blockNum, sourceURL):</span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">				logger.Warn(<span class="string">&quot;Timed out sending Tx Status event.&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ed *Dispatcher)</span> <span class="title">publishCCEvents</span><span class="params">(ccEvent *pb.ChaincodeEvent, blockNum <span class="keyword">uint64</span>, sourceURL <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, reg := <span class="keyword">range</span> ed.ccRegistrations &#123;</span><br><span class="line">		logger.Debugf(<span class="string">&quot;Matching CCEvent[%s,%s] against Reg[%s,%s] ...&quot;</span>, ccEvent.ChaincodeId, ccEvent.EventName, reg.ChaincodeID, reg.EventFilter)</span><br><span class="line">		<span class="keyword">if</span> reg.ChaincodeID == ccEvent.ChaincodeId &amp;&amp; reg.EventRegExp.MatchString(ccEvent.EventName) &#123;</span><br><span class="line">			logger.Debugf(<span class="string">&quot;... matched CCEvent[%s,%s] against Reg[%s,%s]&quot;</span>, ccEvent.ChaincodeId, ccEvent.EventName, reg.ChaincodeID, reg.EventFilter)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ed.eventConsumerTimeout &lt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL):</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					logger.Warn(<span class="string">&quot;Unable to send to CC event channel.&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ed.eventConsumerTimeout == <span class="number">0</span> &#123;</span><br><span class="line">				reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> reg.Eventch &lt;- NewChaincodeEvent(ccEvent.ChaincodeId, ccEvent.EventName, ccEvent.TxId, ccEvent.Payload, blockNum, sourceURL):</span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(ed.eventConsumerTimeout):</span><br><span class="line">					logger.Warn(<span class="string">&quot;Timed out sending CC event.&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了：</p>
<ol>
<li>Peer支持的2类Even，</li>
<li>Peer是如何支持事件订阅，和发送事件的，</li>
<li>SDK支持的4类Event，这4类Event和Peer的2类Event的关系</li>
<li>SDK和Peer之间的gRPC通信</li>
</ol>
<p>更多SDK事件的使用，请参考<a target="_blank" rel="noopener" href="https://godoc.org/github.com/hyperledger/fabric-sdk-go/pkg/client/event#New">文档</a>。</p>
<p>Fabric事件介绍的[官方文档(<a target="_blank" rel="noopener" href="https://stone-fabric.readthedocs.io/zh/latest/peer_event_services.html)%E3%80%82">https://stone-fabric.readthedocs.io/zh/latest/peer_event_services.html)。</a></p>
<p>Fabric在examples中还提供了一个<a target="_blank" rel="noopener" href="https://github.com/hyperledger/fabric/tree/release-1.4/examples/events/eventsclient">eventclient</a>样例，看这个样例更有助于理解Fabric event的原理，以及是如何交互的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/11/fabric-deploy-scc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/11/fabric-deploy-scc/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 2：系统链码SCC是如何部署的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-11 11:37:27" itemprop="dateCreated datePublished" datetime="2019-09-11T11:37:27+08:00">2019-09-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一份Peer节点启动的INFO级别日志如下，可以发现：</p>
<ol>
<li>先注册了scc目录下的lscc, cscc, qscc，未注册chaincode目录下的lifecycle</li>
<li>然后又依次部署了上述scc。</li>
</ol>
<p>本文的目的就是梳理出，系统链码的部署流程，这是peer节点提供背书、链码管理、配置、查询等功能的基础。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.409 UTC [gossip.gossip] start -&gt; INFO 013 Gossip instance peer1.org1.example.com:8051 started</span><br><span class="line">2019-09-09 07:52:09.418 UTC [sccapi] deploySysCC -&gt; INFO 014 system chaincode lscc&#x2F;(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;lscc) deployed</span><br><span class="line">2019-09-09 07:52:09.420 UTC [cscc] Init -&gt; INFO 015 Init CSCC</span><br><span class="line">2019-09-09 07:52:09.422 UTC [sccapi] deploySysCC -&gt; INFO 016 system chaincode cscc&#x2F;(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;cscc) deployed</span><br><span class="line">2019-09-09 07:52:09.424 UTC [qscc] Init -&gt; INFO 017 Init QSCC</span><br><span class="line">2019-09-09 07:52:09.424 UTC [sccapi] deploySysCC -&gt; INFO 018 system chaincode qscc&#x2F;(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;qscc) deployed</span><br><span class="line">2019-09-09 07:52:09.425 UTC [sccapi] deploySysCC -&gt; INFO 019 system chaincode (+lifecycle,github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;chaincode&#x2F;lifecycle) disabled</span><br><span class="line">...</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 031 system chaincode lscc&#x2F;mychannel(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;lscc) deployed</span><br><span class="line">2019-09-09 07:52:14.386 UTC [cscc] Init -&gt; INFO 032 Init CSCC</span><br><span class="line">2019-09-09 07:52:14.386 UTC [sccapi] deploySysCC -&gt; INFO 033 system chaincode cscc&#x2F;mychannel(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;cscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [qscc] Init -&gt; INFO 034 Init QSCC</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 035 system chaincode qscc&#x2F;mychannel(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;qscc) deployed</span><br><span class="line">2019-09-09 07:52:14.387 UTC [sccapi] deploySysCC -&gt; INFO 036 system chaincode (+lifecycle,github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;chaincode&#x2F;lifecycle) disabled</span><br></pre></td></tr></table></figure>

<h2 id="宏观流程"><a href="#宏观流程" class="headerlink" title="宏观流程"></a>宏观流程</h2><blockquote>
<p>提醒，本文使用<strong>SCC代指系统链码</strong>，使用scc代指core.scc模块。</p>
</blockquote>
<p>在介绍源码之前，先给出总体流程，以便看源码的时候不会迷失。</p>
<p>部署SCC会涉及到4个模块：</p>
<ol>
<li>peer.node，它是peer的主程序，可以调用core.scc进行注册和部署SCC</li>
<li>core.scc，它包含了lscc、qscc、cscc这3个scc，以及SCC的注册和部署</li>
<li>core.chaincode，它是链码管理，普通链码和SCC都会走该模块，去部署和调用链码，和链码容器交互，并且它还提供了1个链码容器的工具shim</li>
<li>core.container，它是实现链码容器，有2种链码容器，SCC使用的InprocVM，和普通链码使用的DockerVM</li>
</ol>
<p>注册和部署的简要流程如下：</p>
<p><img src="https://lessisbetter.site/images/2019-09-deploy-scc-flow.png"></p>
<ol>
<li>peer运行启动程序</li>
<li>注册scc<ol>
<li>peer.node创建好lscc、cscc、qscc等scc实例，以及从配置文件读取的scc</li>
<li>peer.node调用core.scc依次注册每一个scc实例</li>
<li>core.scc调用core.container把scc实例信息注册到container</li>
</ol>
</li>
<li>部署scc<ol>
<li>peer.node调用core.scc依次部署每一个注册的scc</li>
<li>core.scc部署scc的流程复用普通链码部署流程，调用core.chaincode</li>
<li>core.chaincode执行启动链码容器，scc也有链码容器是Inproc类型，不是Docker类型</li>
<li>core.chaincode会调用core.container建立scc的Inproc容器实例</li>
<li>core.container调用core.chaincode.shim启动容器内的程序，并负责和peer通信</li>
<li>启动完成后，core.chaincode向容器发送Init消息，让容器初始化，容器初始化完成会发送响应消息给core.chaincode，core.chaincode部署scc完成</li>
</ol>
</li>
</ol>
<h2 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h2><blockquote>
<p>列出源码的过程，会省略大量不相关代码，用<code>...</code>代替。</p>
</blockquote>
<p>peer启动过程中，会调用<code>node.serve</code>，其中包含了为系统链码注册SCC和部署SCC。之后，还会为应用通道部署SCC，说明每个通道有各自的SCC，这里省略掉这部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取support，会注册SCC</span></span><br><span class="line">    <span class="comment">// Initialize chaincode service</span></span><br><span class="line">    chaincodeSupport, ccp, sccp, packageProvider := startChaincodeServer(peerHost, aclProvider, pr, opsSystem)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">    <span class="comment">// deploy system chaincodes</span></span><br><span class="line">	sccp.DeploySysCCs(<span class="string">&quot;&quot;</span>, ccp)</span><br><span class="line">	logger.Infof(<span class="string">&quot;Deployed system chaincodes&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册SCC"><a href="#注册SCC" class="headerlink" title="注册SCC"></a>注册SCC</h2><p>注册SCC的流程：</p>
<p>peer.node -&gt; core.scc -&gt; core.container</p>
<h3 id="peer-node"><a href="#peer-node" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startChaincodeServer will finish chaincode related initialization, including:</span></span><br><span class="line"><span class="comment">// 1) setup local chaincode install path</span></span><br><span class="line"><span class="comment">// 2) create chaincode specific tls CA</span></span><br><span class="line"><span class="comment">// 3) start the chaincode specific gRPC listening service</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startChaincodeServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	peerHost <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider, *persistence.PackageProvider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 会注册SCC</span></span><br><span class="line">	chaincodeSupport, ccp, sccp := registerChaincodeSupport(</span><br><span class="line">		ccSrv,</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		ca,</span><br><span class="line">		packageProvider,</span><br><span class="line">		aclProvider,</span><br><span class="line">		pr,</span><br><span class="line">		lifecycleSCC,</span><br><span class="line">		ops,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">go</span> ccSrv.Start()</span><br><span class="line">	<span class="keyword">return</span> chaincodeSupport, ccp, sccp, packageProvider</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">	packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// SCC的VM provider</span></span><br><span class="line">	ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建SCC provider</span></span><br><span class="line">	sccp := scc.NewProvider(peer.Default, peer.DefaultSupport, ipRegistry)</span><br><span class="line">	<span class="comment">// 创建lscc实例</span></span><br><span class="line">    lsccInst := lscc.New(sccp, aclProvider, pr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">	dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">		viper.GetString(<span class="string">&quot;peer.id&quot;</span>),</span><br><span class="line">		viper.GetString(<span class="string">&quot;peer.networkId&quot;</span>),</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">	dockerVM := dockercontroller.NewDockerVM(</span><br><span class="line">		dockerProvider.PeerID,</span><br><span class="line">		dockerProvider.NetworkID,</span><br><span class="line">		dockerProvider.BuildMetrics,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">		chaincode.GlobalConfig(),</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		userRunsCC,</span><br><span class="line">		ca.CertBytes(),</span><br><span class="line">		authenticator,</span><br><span class="line">		packageProvider,</span><br><span class="line">		lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">		aclProvider,</span><br><span class="line">		container.NewVMController(</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">				dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">				inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">		sccp,</span><br><span class="line">		pr,</span><br><span class="line">		peer.DefaultSupport,</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">	ipRegistry.ChaincodeSupport = chaincodeSupport</span><br><span class="line">	<span class="comment">// chaincode provider，可以用来创建cscc</span></span><br><span class="line">	ccp := chaincode.NewProvider(chaincodeSupport)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建cscc、qscc</span></span><br><span class="line">	csccInst := cscc.New(ccp, sccp, aclProvider)</span><br><span class="line">	qsccInst := qscc.New(aclProvider)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Now that chaincode is initialized, register all system chaincodes.</span></span><br><span class="line">	sccs := scc.CreatePluginSysCCs(sccp)</span><br><span class="line">	<span class="comment">// 加入lscc、cscc、qscc</span></span><br><span class="line">	<span class="comment">// lifecycleSCC在1.4中disable了</span></span><br><span class="line">	<span class="comment">// sccs是用户自定义的系统链码</span></span><br><span class="line">	<span class="keyword">for</span> _, cc := <span class="keyword">range</span> <span class="built_in">append</span>([]scc.SelfDescribingSysCC&#123;lsccInst, csccInst, qsccInst, lifecycleSCC&#125;, sccs...) &#123;</span><br><span class="line">		<span class="comment">// 注册每一个SCC</span></span><br><span class="line">		sccp.RegisterSysCC(cc)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> chaincodeSupport, ccp, sccp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-scc"><a href="#core-scc" class="headerlink" title="core.scc"></a>core.scc</h3><p>注册某1个系统合约。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provider implements sysccprovider.SystemChaincodeProvider</span></span><br><span class="line"><span class="keyword">type</span> Provider <span class="keyword">struct</span> &#123;</span><br><span class="line">	Peer        peer.Operations</span><br><span class="line">	PeerSupport peer.Support</span><br><span class="line">	Registrar   Registrar             <span class="comment">// 注册</span></span><br><span class="line">	SysCCs      []SelfDescribingSysCC <span class="comment">// 注册的scc，包含失败的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterSysCC registers a system chaincode with the syscc provider.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">RegisterSysCC</span><span class="params">(scc SelfDescribingSysCC)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 收集/注册scc到scc provider</span></span><br><span class="line">	p.SysCCs = <span class="built_in">append</span>(p.SysCCs, scc)</span><br><span class="line">	_, err := p.registerSysCC(scc)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		sysccLogger.Panicf(<span class="string">&quot;Could not register system chaincode: %s&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// registerSysCC registers the given system chaincode with the peer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">registerSysCC</span><span class="params">(syscc SelfDescribingSysCC)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 检测该scc是否开启或不在白名单</span></span><br><span class="line">	<span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">		sysccLogger.Info(fmt.Sprintf(<span class="string">&quot;system chaincode (%s,%s,%t) disabled&quot;</span>, syscc.Name(), syscc.Path(), syscc.Enabled()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">	version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cc的描述信息</span></span><br><span class="line">	ccid := &amp;ccintf.CCID&#123;</span><br><span class="line">		Name:    syscc.Name(),</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册scc的chaincode</span></span><br><span class="line">	err := p.Registrar.Register(ccid, syscc.Chaincode())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//if the type is registered, the instance may not be... keep going</span></span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(inproccontroller.SysCCRegisteredErr); !ok &#123;</span><br><span class="line">			errStr := fmt.Sprintf(<span class="string">&quot;could not register (%s,%v): %s&quot;</span>, syscc.Path(), syscc, err)</span><br><span class="line">			sysccLogger.Error(errStr)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, fmt.Errorf(errStr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sysccLogger.Infof(<span class="string">&quot;system chaincode %s(%s) registered&quot;</span>, syscc.Name(), syscc.Path())</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Registrar provides a way for system chaincodes to be registered</span></span><br><span class="line"><span class="keyword">type</span> Registrar <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Register registers a system chaincode</span></span><br><span class="line">	Register(ccid *ccintf.CCID, cc shim.Chaincode) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-container"><a href="#core-container" class="headerlink" title="core.container"></a>core.container</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Register registers system chaincode with given path. The deploy should be called to initialize</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Registry)</span> <span class="title">Register</span><span class="params">(ccid *ccintf.CCID, cc shim.Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	r.mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册系统链码</span></span><br><span class="line">	name := ccid.GetName()</span><br><span class="line">	inprocLogger.Debugf(<span class="string">&quot;Registering chaincode instance: %s&quot;</span>, name)</span><br><span class="line">	tmp := r.typeRegistry[name]</span><br><span class="line">	<span class="keyword">if</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> SysCCRegisteredErr(name)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.typeRegistry[name] = &amp;inprocContainer&#123;chaincode: cc&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Registry stores registered system chaincodes.</span></span><br><span class="line"><span class="comment">// It implements container.VMProvider and scc.Registrar</span></span><br><span class="line"><span class="keyword">type</span> Registry <span class="keyword">struct</span> &#123;</span><br><span class="line">	mutex        sync.Mutex</span><br><span class="line">	typeRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 已注册链码映射</span></span><br><span class="line">	instRegistry <span class="keyword">map</span>[<span class="keyword">string</span>]*inprocContainer <span class="comment">// 链码示例映射</span></span><br><span class="line"></span><br><span class="line">	ChaincodeSupport ccintf.CCSupport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="部署SCC"><a href="#部署SCC" class="headerlink" title="部署SCC"></a>部署SCC</h2><p>部署SCC的流程：</p>
<p>peer.node -&gt; core.scc -&gt; core.chaincode -&gt; core.container</p>
<h3 id="peer-node-1"><a href="#peer-node-1" class="headerlink" title="peer.node"></a>peer.node</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 为系统通道部署已经注册的SCC</span></span><br><span class="line">	<span class="comment">// deploy system chaincodes</span></span><br><span class="line">	sccp.DeploySysCCs(<span class="string">&quot;&quot;</span>, ccp)</span><br><span class="line">    logger.Infof(<span class="string">&quot;Deployed system chaincodes&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-scc-1"><a href="#core-scc-1" class="headerlink" title="core.scc"></a>core.scc</h3><p><code>DeploySysCCs</code>会为chainID对应的channel，部署注册过程中收集的每一个SCC，它们在<code>p.SysCCs</code>中。</p>
<p>部署链码实际是一笔交易，为了复用普通链码的部署流程，core.scc使用<code>deploySysCC</code>封装部署链码需要的参数，链码是实际部署，走core.chaincode流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DeploySysCCs is the hook for system chaincodes where system chaincodes are registered with the fabric</span></span><br><span class="line"><span class="comment">//note the chaincode must still be deployed and launched like a user chaincode will be</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Provider)</span> <span class="title">DeploySysCCs</span><span class="params">(chainID <span class="keyword">string</span>, ccp ccprovider.ChaincodeProvider)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 部署每一个scc</span></span><br><span class="line">	<span class="keyword">for</span> _, sysCC := <span class="keyword">range</span> p.SysCCs &#123;</span><br><span class="line">		deploySysCC(chainID, ccp, sysCC)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deploySysCC deploys the given system chaincode on a chain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deploySysCC</span><span class="params">(chainID <span class="keyword">string</span>, ccprov ccprovider.ChaincodeProvider, syscc SelfDescribingSysCC)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// disable或不在白名单的scc不执行部署</span></span><br><span class="line">	<span class="keyword">if</span> !syscc.Enabled() || !isWhitelisted(syscc) &#123;</span><br><span class="line">		sysccLogger.Info(fmt.Sprintf(<span class="string">&quot;system chaincode (%s,%s) disabled&quot;</span>, syscc.Name(), syscc.Path()))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为scc生成txid，因为部署链码的过程需要txParams，与普通链码的流程相同</span></span><br><span class="line">	txid := util.GenerateUUID()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note, this structure is barely initialized,</span></span><br><span class="line">	<span class="comment">// we omit the history query executor, the proposal</span></span><br><span class="line">	<span class="comment">// and the signed proposal</span></span><br><span class="line">	txParams := &amp;ccprovider.TransactionParams&#123;</span><br><span class="line">		TxID:      txid,</span><br><span class="line">		ChannelID: chainID,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置交易执行模拟器，系统通道chainID为&quot;&quot;，所以系统通道的scc没有模拟器</span></span><br><span class="line">	<span class="keyword">if</span> chainID != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 获取链/通道的账本</span></span><br><span class="line">		lgr := peer.GetLedger(chainID)</span><br><span class="line">		<span class="keyword">if</span> lgr == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;syschain %s start up failure - unexpected nil ledger for channel %s&quot;</span>, syscc.Name(), chainID))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据交易id创建链码模拟器</span></span><br><span class="line">		txsim, err := lgr.NewTxSimulator(txid)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指定链码执行模拟器</span></span><br><span class="line">		txParams.TXSimulator = txsim</span><br><span class="line">		<span class="keyword">defer</span> txsim.Done()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Path: syscc.Path(), Name: syscc.Name()&#125;</span><br><span class="line">	spec := &amp;pb.ChaincodeSpec&#123;Type: pb.ChaincodeSpec_Type(pb.ChaincodeSpec_Type_value[<span class="string">&quot;GOLANG&quot;</span>]), ChaincodeId: chaincodeID, Input: &amp;pb.ChaincodeInput&#123;Args: syscc.InitArgs()&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ChaincodeDeploymentSpec_SYSTEM标明：部署SCC</span></span><br><span class="line">	chaincodeDeploymentSpec := &amp;pb.ChaincodeDeploymentSpec&#123;ExecEnv: pb.ChaincodeDeploymentSpec_SYSTEM, ChaincodeSpec: spec&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// XXX This is an ugly hack, version should be tied to the chaincode instance, not he peer binary</span></span><br><span class="line">	version := util.GetSysCCVersion()</span><br><span class="line"></span><br><span class="line">	cccid := &amp;ccprovider.CCContext&#123;</span><br><span class="line">		Name:    chaincodeDeploymentSpec.ChaincodeSpec.ChaincodeId.Name,</span><br><span class="line">		Version: version,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 部署SCC</span></span><br><span class="line">	resp, _, err := ccprov.ExecuteLegacyInit(txParams, cccid, chaincodeDeploymentSpec)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; resp.Status != shim.OK &#123;</span><br><span class="line">		err = errors.New(resp.Message)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sysccLogger.Infof(<span class="string">&quot;system chaincode %s/%s(%s) deployed&quot;</span>, syscc.Name(), chainID, syscc.Path())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeProvider provides an abstraction layer that is</span></span><br><span class="line"><span class="comment">// used for different packages to interact with code in the</span></span><br><span class="line"><span class="comment">// chaincode package without importing it; more methods</span></span><br><span class="line"><span class="comment">// should be added below if necessary</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeProvider <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Execute executes a standard chaincode invocation for a chaincode and an input</span></span><br><span class="line">	Execute(txParams *TransactionParams, cccid *CCContext, input *pb.ChaincodeInput) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line">	<span class="comment">// ExecuteLegacyInit is a special case for executing chaincode deployment specs,</span></span><br><span class="line">	<span class="comment">// which are not already in the LSCC, needed for old lifecycle</span></span><br><span class="line">	ExecuteLegacyInit(txParams *TransactionParams, cccid *CCContext, spec *pb.ChaincodeDeploymentSpec) (*pb.Response, *pb.ChaincodeEvent, error)</span><br><span class="line">	<span class="comment">// Stop stops the chaincode give</span></span><br><span class="line">	Stop(ccci *ChaincodeContainerInfo) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-chaincode"><a href="#core-chaincode" class="headerlink" title="core.chaincode"></a>core.chaincode</h3><p><code>CCProviderImpl</code>实现了<code>ChaincodeProvider</code>接口，可以用来部署链码，<code>ExecuteLegacyInit</code>会执行2项：</p>
<ol>
<li>启动链码容器</li>
<li>执行链码Init函数，链码容器启动后，peer和链码容器通过消息通信，<code>ChaincodeMessage_INIT</code>是执行链码容器的Init函数</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecuteLegacyInit executes a chaincode which is not in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CCProviderImpl)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.cs.ExecuteLegacyInit(txParams, cccid, spec)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ExecuteLegacyInit is a temporary method which should be removed once the old style lifecycle</span></span><br><span class="line"><span class="comment">// is entirely deprecated.  Ideally one release after the introduction of the new lifecycle.</span></span><br><span class="line"><span class="comment">// It does not attempt to start the chaincode based on the information from lifecycle, but instead</span></span><br><span class="line"><span class="comment">// accepts the container information directly in the form of a ChaincodeDeploymentSpec.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">ExecuteLegacyInit</span><span class="params">(txParams *ccprovider.TransactionParams, cccid *ccprovider.CCContext, spec *pb.ChaincodeDeploymentSpec)</span> <span class="params">(*pb.Response, *pb.ChaincodeEvent, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 部署链码需要的信息</span></span><br><span class="line">    ccci := ccprovider.DeploymentSpecToChaincodeContainerInfo(spec)</span><br><span class="line">	ccci.Version = cccid.Version</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动容器</span></span><br><span class="line">	err := cs.LaunchInit(ccci)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cname := ccci.Name + <span class="string">&quot;:&quot;</span> + ccci.Version</span><br><span class="line">	h := cs.HandlerRegistry.Handler(cname)</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">&quot;[channel %s] claimed to start chaincode container for %s but could not find handler&quot;</span>, txParams.ChannelID, cname)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用链码Init</span></span><br><span class="line">	resp, err := cs.execute(pb.ChaincodeMessage_INIT, txParams, cccid, spec.GetChaincodeSpec().Input, h)</span><br><span class="line">	<span class="keyword">return</span> processChaincodeExecutionResult(txParams.TxID, cccid.Name, resp, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LaunchInit</code>是启动容器的一层检查，实际启动由<code>Launcher.Launch</code>完成。启动链码容器是异步的，会创建单独的goroutine去执行。</p>
<p>core.chaincode使用<code>Runtime</code>接口操控链码容器的启停。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaunchInit bypasses getting the chaincode spec from the LSCC table</span></span><br><span class="line"><span class="comment">// as in the case of v1.0-v1.2 lifecycle, the chaincode will not yet be</span></span><br><span class="line"><span class="comment">// defined in the LSCC table</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *ChaincodeSupport)</span> <span class="title">LaunchInit</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cname := ccci.Name + <span class="string">&quot;:&quot;</span> + ccci.Version</span><br><span class="line">	<span class="comment">// 已经有handler，即容器已经启动。调用链码的时候，也会获取handler</span></span><br><span class="line">	<span class="keyword">if</span> cs.HandlerRegistry.Handler(cname) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 否则启动容器，设置handler</span></span><br><span class="line">	<span class="keyword">return</span> cs.Launcher.Launch(ccci)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RuntimeLauncher)</span> <span class="title">Launch</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> startFailCh <span class="keyword">chan</span> error</span><br><span class="line">	<span class="keyword">var</span> timeoutCh &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"></span><br><span class="line">	startTime := time.Now()</span><br><span class="line">	cname := ccci.Name + <span class="string">&quot;:&quot;</span> + ccci.Version</span><br><span class="line">	launchState, alreadyStarted := r.Registry.Launching(cname)</span><br><span class="line">	<span class="comment">// 链码容器未启动，启动容器</span></span><br><span class="line">	<span class="keyword">if</span> !alreadyStarted &#123;</span><br><span class="line">		startFailCh = <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">		timeoutCh = time.NewTimer(r.StartupTimeout).C</span><br><span class="line"></span><br><span class="line">		codePackage, err := r.getCodePackage(ccci)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 启动容器</span></span><br><span class="line">			<span class="keyword">if</span> err := r.Runtime.Start(ccci, codePackage); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				startFailCh &lt;- errors.WithMessage(err, <span class="string">&quot;error starting container&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			exitCode, err := r.Runtime.Wait(ccci)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				launchState.Notify(errors.Wrap(err, <span class="string">&quot;failed to wait on container exit&quot;</span>))</span><br><span class="line">			&#125;</span><br><span class="line">			launchState.Notify(errors.Errorf(<span class="string">&quot;container exited with %d&quot;</span>, exitCode))</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runtime is used to manage chaincode runtime instances.</span></span><br><span class="line"><span class="keyword">type</span> Runtime <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>) error</span><br><span class="line">	Stop(ccci *ccprovider.ChaincodeContainerInfo) error</span><br><span class="line">	Wait(ccci *ccprovider.ChaincodeContainerInfo) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>ContainerRuntime</code>是core.chaincode封装出来和core.container交互的，在这里它会创建启动链码请求，交给container。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start launches chaincode in a runtime environment.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ContainerRuntime)</span> <span class="title">Start</span><span class="params">(ccci *ccprovider.ChaincodeContainerInfo, codePackage []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cname := ccci.Name + <span class="string">&quot;:&quot;</span> + ccci.Version</span><br><span class="line"></span><br><span class="line">	lc, err := c.LaunchConfig(cname, ccci.Type)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;start container: %s&quot;</span>, cname)</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;start container with args: %s&quot;</span>, strings.Join(lc.Args, <span class="string">&quot; &quot;</span>))</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;start container with env:\n\t%s&quot;</span>, strings.Join(lc.Envs, <span class="string">&quot;\n\t&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动链码的请求</span></span><br><span class="line">	scr := container.StartContainerReq&#123;</span><br><span class="line">		Builder: &amp;container.PlatformBuilder&#123;</span><br><span class="line">			Type:             ccci.Type,</span><br><span class="line">			Name:             ccci.Name,</span><br><span class="line">			Version:          ccci.Version,</span><br><span class="line">			Path:             ccci.Path,</span><br><span class="line">			CodePackage:      codePackage,</span><br><span class="line">			PlatformRegistry: c.PlatformRegistry,</span><br><span class="line">		&#125;,</span><br><span class="line">		Args:          lc.Args,</span><br><span class="line">		Env:           lc.Envs,</span><br><span class="line">		FilesToUpload: lc.Files,</span><br><span class="line">		CCID: ccintf.CCID&#123;</span><br><span class="line">			Name:    ccci.Name,</span><br><span class="line">			Version: ccci.Version,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理容器操作请求</span></span><br><span class="line">	<span class="keyword">if</span> err := c.Processor.Process(ccci.ContainerType, scr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;error starting container&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor processes vm and container requests.</span></span><br><span class="line"><span class="keyword">type</span> Processor <span class="keyword">interface</span> &#123;</span><br><span class="line">	Process(vmtype <span class="keyword">string</span>, req container.VMCReq) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core-container-1"><a href="#core-container-1" class="headerlink" title="core.container"></a>core.container</h3><p><code>VMController</code>实现了Processor，它会按指定的类型建立虚拟机，明明就是容器，为啥内部又叫VM，VM有2种：</p>
<ol>
<li>InprocVM，意思是运行在单独进程中的虚拟机，但不是指操作系统的进程，而是指一个隔离的环境，SCC是这类。</li>
<li>DockerVM，指利用Docker启动的容器，普通链码就是这类。</li>
</ol>
<p>类型是存在<code>ccci.ContainerType</code>中的，<code>ccci</code>包含了部署链码所需要的信息，这个信息在core.chaincode很早就获取到了，可以往前翻。</p>
<p><code>Process</code>就是创建VM，然后利用VM处理请求的过程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据请求对VM进行某种操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">Process</span><span class="params">(vmtype <span class="keyword">string</span>, req VMCReq)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建vm</span></span><br><span class="line">	v := vmc.newVM(vmtype)</span><br><span class="line">	ccid := req.GetCCID()</span><br><span class="line">	id := ccid.GetName()</span><br><span class="line"></span><br><span class="line">	vmc.lockContainer(id)</span><br><span class="line">	<span class="keyword">defer</span> vmc.unlockContainer(id)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把vm传递给请求，即用该vm执行请求内容</span></span><br><span class="line">	<span class="keyword">return</span> req.Do(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟机创建"><a href="#虚拟机创建" class="headerlink" title="虚拟机创建"></a>虚拟机创建</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用指定类型的vm provider创建vm</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vmc *VMController)</span> <span class="title">newVM</span><span class="params">(typ <span class="keyword">string</span>)</span> <span class="title">VM</span></span> &#123;</span><br><span class="line">	v, ok := vmc.vmProviders[typ]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		vmLogger.Panicf(<span class="string">&quot;Programming error: unsupported VM type: %s&quot;</span>, typ)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v.NewVM()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewVMController creates a new instance of VMController</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewVMController</span><span class="params">(vmProviders <span class="keyword">map</span>[<span class="keyword">string</span>]VMProvider)</span> *<span class="title">VMController</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;VMController&#123;</span><br><span class="line">		containerLocks: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*refCountedLock),</span><br><span class="line">		vmProviders:    vmProviders,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建VM需要使用<code>NewVMController</code>，回过去找它的创建地方。</p>
<p>在注册SCC的过程中，调用<code>registerChaincodeSupport</code>创建了<code>chaincodeSupport</code>，其中一个字段为创建<code>NewVMController</code>，就包含了2类Vm provider：</p>
<ol>
<li>ipRegistry，SCC的</li>
<li>dockerProvider，普通链码的</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerChaincodeSupport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	grpcServer *comm.GRPCServer,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccEndpoint <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	ca tlsgen.CA,</span></span></span><br><span class="line"><span class="function"><span class="params">	packageProvider *persistence.PackageProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	aclProvider aclmgmt.ACLProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">	pr *platforms.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">	lifecycleSCC *lifecycle.SCC,</span></span></span><br><span class="line"><span class="function"><span class="params">	ops *operations.System,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*chaincode.ChaincodeSupport, ccprovider.ChaincodeProvider, *scc.Provider)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// SCC的VM provider</span></span><br><span class="line">	ipRegistry := inproccontroller.NewRegistry()</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 普通链码，docker容器类型的VM provider</span></span><br><span class="line">	dockerProvider := dockercontroller.NewProvider(</span><br><span class="line">		viper.GetString(<span class="string">&quot;peer.id&quot;</span>),</span><br><span class="line">		viper.GetString(<span class="string">&quot;peer.networkId&quot;</span>),</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">    ...</span><br><span class="line">    chaincodeSupport := chaincode.NewChaincodeSupport(</span><br><span class="line">		chaincode.GlobalConfig(),</span><br><span class="line">		ccEndpoint,</span><br><span class="line">		userRunsCC,</span><br><span class="line">		ca.CertBytes(),</span><br><span class="line">		authenticator,</span><br><span class="line">		packageProvider,</span><br><span class="line">		lsccInst, <span class="comment">// chaincodeSupport的声明周期管理使用了lscc，而不是lifecycle</span></span><br><span class="line">		aclProvider,</span><br><span class="line">        <span class="comment">// 创建了VM controller，controller提供了inproc和docker 2中子controller，</span></span><br><span class="line">		<span class="comment">// 即2中链码运行方式</span></span><br><span class="line">		container.NewVMController(</span><br><span class="line">			<span class="keyword">map</span>[<span class="keyword">string</span>]container.VMProvider&#123;</span><br><span class="line">				dockercontroller.ContainerType: dockerProvider,</span><br><span class="line">				inproccontroller.ContainerType: ipRegistry,</span><br><span class="line">			&#125;,</span><br><span class="line">		),</span><br><span class="line">		sccp,</span><br><span class="line">		pr,</span><br><span class="line">		peer.DefaultSupport,</span><br><span class="line">		ops.Provider,</span><br><span class="line">	)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VM处理操作虚拟机的请求"><a href="#VM处理操作虚拟机的请求" class="headerlink" title="VM处理操作虚拟机的请求"></a>VM处理操作虚拟机的请求</h4><p>core.container的请求，都实现了<code>VMCReq</code>接口，StartContainerReq、StopContainerReq、WaitContainerReq是实现VMCReq的3类请求。</p>
<p>启动实际是启动虚拟机接口，处理请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VMCReq - all requests should implement this interface.</span></span><br><span class="line"><span class="comment">//The context should be passed and tested at each layer till we stop</span></span><br><span class="line"><span class="comment">//note that we&#x27;d stop on the first method on the stack that does not</span></span><br><span class="line"><span class="comment">//take context</span></span><br><span class="line"><span class="keyword">type</span> VMCReq <span class="keyword">interface</span> &#123;</span><br><span class="line">	Do(v VM) error</span><br><span class="line">	GetCCID() ccintf.CCID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动容器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(si StartContainerReq)</span> <span class="title">Do</span><span class="params">(v VM)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> v.Start(si.CCID, si.Args, si.Env, si.FilesToUpload, si.Builder)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//VM is an abstract virtual image for supporting arbitrary virual machines</span></span><br><span class="line"><span class="keyword">type</span> VM <span class="keyword">interface</span> &#123;</span><br><span class="line">	Start(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder Builder) error</span><br><span class="line">	Stop(ccid ccintf.CCID, timeout <span class="keyword">uint</span>, dontkill <span class="keyword">bool</span>, dontremove <span class="keyword">bool</span>) error</span><br><span class="line">	Wait(ccid ccintf.CCID) (<span class="keyword">int</span>, error)</span><br><span class="line">	HealthCheck(context.Context) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DockerVM和InprocVM都实现了VM接口，本文只关注InprocVM类型，即SCC的。</p>
<p>InprocVM会得到一个容器实例ipc，用它来运行SCC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Start starts a previously registered system codechain</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vm *InprocVM)</span> <span class="title">Start</span><span class="params">(ccid ccintf.CCID, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>, filesToUpload <span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">byte</span>, builder container.Builder)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	path := ccid.GetName()</span><br><span class="line"></span><br><span class="line">	ipctemplate := vm.registry.getType(path)</span><br><span class="line">	<span class="keyword">if</span> ipctemplate == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">&quot;%s not registered&quot;</span>, path))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 即ccid.Name</span></span><br><span class="line">	instName := vm.GetVMName(ccid)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取容器实例</span></span><br><span class="line">	ipc, err := vm.getInstance(ipctemplate, instName, args, env)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">&quot;could not create instance for %s&quot;</span>, instName))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 已经在运行了，还部署个啥！</span></span><br><span class="line">	<span class="keyword">if</span> ipc.running &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(fmt.Sprintf(<span class="string">&quot;chaincode running %s&quot;</span>, path))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc.running = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">				inprocLogger.Criticalf(<span class="string">&quot;caught panic from chaincode  %s&quot;</span>, instName)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">// 启动进程级容器</span></span><br><span class="line">		ipc.launchInProc(instName, args, env)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inprocContainer</code>开启2个goroutine：</p>
<ol>
<li>第一个调用<code>shimStartInProc</code>，即利用core.chaincode.shim启动InProc类型的容器。</li>
<li>第二个调用<code>HandleChaincodeStream</code>，处理peer和Inproc容器间的通信数据，此处的stream是peer端的。</li>
</ol>
<p>这里可以看到创建了2个通道<code>peerRcvCCSend</code>和<code>ccRcvPeerSend</code>，它们表明了peer和scc的链码容器是通过通道直接通信的。peer和docker链码容器之间是走gRPC通信的，这个到普通链码的时候再介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从进程启动链码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ipc *inprocContainer)</span> <span class="title">launchInProc</span><span class="params">(id <span class="keyword">string</span>, args []<span class="keyword">string</span>, env []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ipc.ChaincodeSupport == <span class="literal">nil</span> &#123;</span><br><span class="line">		inprocLogger.Panicf(<span class="string">&quot;Chaincode support is nil, most likely you forgot to set it immediately after calling inproccontroller.NewRegsitry()&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 和调用链码的上层通信的2个通道</span></span><br><span class="line">	peerRcvCCSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">	ccRcvPeerSend := <span class="built_in">make</span>(<span class="keyword">chan</span> *pb.ChaincodeMessage)</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	ccchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	ccsupportchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">	shimStartInProc := _shimStartInProc <span class="comment">// shadow to avoid race in test</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ccchan)</span><br><span class="line">		<span class="comment">// 启动链码</span></span><br><span class="line">		inprocLogger.Debugf(<span class="string">&quot;chaincode started for %s&quot;</span>, id)</span><br><span class="line">		<span class="keyword">if</span> args == <span class="literal">nil</span> &#123;</span><br><span class="line">			args = ipc.args</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> env == <span class="literal">nil</span> &#123;</span><br><span class="line">			env = ipc.env</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 利用shim启动</span></span><br><span class="line">		err := shimStartInProc(env, args, ipc.chaincode, ccRcvPeerSend, peerRcvCCSend)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;chaincode-support ended with err: %s&quot;</span>, err)</span><br><span class="line">			_inprocLoggerErrorf(<span class="string">&quot;%s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		inprocLogger.Debugf(<span class="string">&quot;chaincode ended for %s with err: %s&quot;</span>, id, err)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// shadow function to avoid data race</span></span><br><span class="line">	inprocLoggerErrorf := _inprocLoggerErrorf</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(ccsupportchan)</span><br><span class="line">		<span class="comment">// 处理scc和外部通信的消息流</span></span><br><span class="line">		inprocStream := newInProcStream(peerRcvCCSend, ccRcvPeerSend)</span><br><span class="line">		inprocLogger.Debugf(<span class="string">&quot;chaincode-support started for  %s&quot;</span>, id)</span><br><span class="line">		err := ipc.ChaincodeSupport.HandleChaincodeStream(inprocStream)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;chaincode ended with err: %s&quot;</span>, err)</span><br><span class="line">			inprocLoggerErrorf(<span class="string">&quot;%s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		inprocLogger.Debugf(<span class="string">&quot;chaincode-support ended for %s with err: %s&quot;</span>, id, err)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用shim启动Inproc链码容器中的程序"><a href="#利用shim启动Inproc链码容器中的程序" class="headerlink" title="利用shim启动Inproc链码容器中的程序"></a>利用shim启动Inproc链码容器中的程序</h4><p>shim是chaincode提供给容器，运行链码的工具，它运行在容器里。</p>
<p>利用shim启动InprocVM使用的函数是<code>StartInProc</code>，提取一些<strong>运行链码</strong>需要的数据，比如又一个stream，此处的stream是容器端的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动SCC的入口</span></span><br><span class="line"><span class="comment">// StartInProc is an entry point for system chaincodes bootstrap. It is not an</span></span><br><span class="line"><span class="comment">// API for chaincodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartInProc</span><span class="params">(env []<span class="keyword">string</span>, args []<span class="keyword">string</span>, cc Chaincode, recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 有点奇怪，这些日志都没有看到，因为已经在shim，不属于peer日志了</span></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;in proc %v&quot;</span>, args)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从环境变量获取cc name</span></span><br><span class="line">	<span class="keyword">var</span> chaincodename <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> env &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Index(v, <span class="string">&quot;CORE_CHAINCODE_ID_NAME=&quot;</span>) == <span class="number">0</span> &#123;</span><br><span class="line">			p := strings.SplitAfter(v, <span class="string">&quot;CORE_CHAINCODE_ID_NAME=&quot;</span>)</span><br><span class="line">			chaincodename = p[<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> chaincodename == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;error chaincode id not provided&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建peer和chaincode通信的通道</span></span><br><span class="line">	stream := newInProcStream(recv, send)</span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;starting chat with peer using name=%s&quot;</span>, chaincodename)</span><br><span class="line">	<span class="comment">// 与peer进行通信</span></span><br><span class="line">	err := chatWithPeer(chaincodename, stream, cc)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>chatWithPeer</code>是通用的，普通的链码也调用这个程序。它创建了一个handler，用来处理消息（发送和接收），以及操作（调用）链码。</p>
<p>这个过程，它会向peer发送REGISTER消息，和peer先“握手”，也会从peer读消息，消息的处理函数就是里面的for循环，这样链码容器就运行起来了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用，SCC和CC都使用这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chatWithPeer</span><span class="params">(chaincodename <span class="keyword">string</span>, stream PeerChaincodeStream, cc Chaincode)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 把stream和cc交给handler，handler可以发送和接收数据，即读写通道</span></span><br><span class="line">	<span class="comment">// Create the shim handler responsible for all control logic</span></span><br><span class="line">	handler := newChaincodeHandler(stream, cc)</span><br><span class="line">	<span class="keyword">defer</span> stream.CloseSend()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the ChaincodeID during register.</span></span><br><span class="line">	chaincodeID := &amp;pb.ChaincodeID&#123;Name: chaincodename&#125;</span><br><span class="line">	payload, err := proto.Marshal(chaincodeID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Wrap(err, <span class="string">&quot;error marshalling chaincodeID during chaincode registration&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在stream上向peer发送注册消息</span></span><br><span class="line">	<span class="comment">// Register on the stream</span></span><br><span class="line">	chaincodeLogger.Debugf(<span class="string">&quot;Registering.. sending %s&quot;</span>, pb.ChaincodeMessage_REGISTER)</span><br><span class="line">	<span class="keyword">if</span> err = handler.serialSend(&amp;pb.ChaincodeMessage&#123;Type: pb.ChaincodeMessage_REGISTER, Payload: payload&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.WithMessage(err, <span class="string">&quot;error sending chaincode REGISTER&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// holds return values from gRPC Recv below</span></span><br><span class="line">	<span class="keyword">type</span> recvMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">		msg *pb.ChaincodeMessage</span><br><span class="line">		err error</span><br><span class="line">	&#125;</span><br><span class="line">	msgAvail := <span class="built_in">make</span>(<span class="keyword">chan</span> *recvMsg, <span class="number">1</span>)</span><br><span class="line">	errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line">	receiveMessage := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		in, err := stream.Recv()</span><br><span class="line">		msgAvail &lt;- &amp;recvMsg&#123;in, err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 异步读取1个消息</span></span><br><span class="line">	<span class="keyword">go</span> receiveMessage()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环处理peer发送的消息</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> rmsg := &lt;-msgAvail:</span><br><span class="line">			<span class="keyword">switch</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> rmsg.err == io.EOF:</span><br><span class="line">				err = errors.Wrapf(rmsg.err, <span class="string">&quot;received EOF, ending chaincode stream&quot;</span>)</span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">&quot;%+v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">case</span> rmsg.err != <span class="literal">nil</span>:</span><br><span class="line">				err := errors.Wrap(rmsg.err, <span class="string">&quot;receive failed&quot;</span>)</span><br><span class="line">				chaincodeLogger.Errorf(<span class="string">&quot;Received error from server, ending chaincode stream: %+v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">case</span> rmsg.msg == <span class="literal">nil</span>:</span><br><span class="line">				err := errors.New(<span class="string">&quot;received nil message, ending chaincode stream&quot;</span>)</span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">&quot;%+v&quot;</span>, err)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 处理消息</span></span><br><span class="line">				chaincodeLogger.Debugf(<span class="string">&quot;[%s]Received message %s from peer&quot;</span>, shorttxid(rmsg.msg.Txid), rmsg.msg.Type)</span><br><span class="line">				err := handler.handleMessage(rmsg.msg, errc)</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					err = errors.WithMessage(err, <span class="string">&quot;error handling message&quot;</span>)</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 读取下一个消息</span></span><br><span class="line">				<span class="keyword">go</span> receiveMessage()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> sendErr := &lt;-errc:</span><br><span class="line">			<span class="keyword">if</span> sendErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				err := errors.Wrap(sendErr, <span class="string">&quot;error sending&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的消息处理函数，先跳过，回过头来，关注scc容器和peer的通信。</p>
<h4 id="SCC和Peer的通信通道"><a href="#SCC和Peer的通信通道" class="headerlink" title="SCC和Peer的通信通道"></a>SCC和Peer的通信通道</h4><p>链码容器和Peer之间使用Stream进行通信，Stream有2种实现：</p>
<ol>
<li>使用channel封装的Stream</li>
<li>gRPC的Stream</li>
</ol>
<p><img src="https://lessisbetter.site/images/2019-09-peer-cc-communication.png"></p>
<p>链码容器和Peer通信的接口是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> PeerChaincodeStream <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*pb.ChaincodeMessage) error</span><br><span class="line">	Recv() (*pb.ChaincodeMessage, error)</span><br><span class="line">	CloseSend() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通链码使用gRPC：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> chaincodeSupportRegisterClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统链码直接使用通道通信，发送和接收消息都在下面了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peer和chaincode之间通信的通道</span></span><br><span class="line"><span class="comment">// PeerChaincodeStream interface for stream between Peer and chaincode instance.</span></span><br><span class="line"><span class="keyword">type</span> inProcStream <span class="keyword">struct</span> &#123;</span><br><span class="line">	recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage</span><br><span class="line">	send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newInProcStream</span><span class="params">(recv &lt;-<span class="keyword">chan</span> *pb.ChaincodeMessage, send <span class="keyword">chan</span>&lt;- *pb.ChaincodeMessage)</span> *<span class="title">inProcStream</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;inProcStream&#123;recv, send&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送其实就是向send写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Send</span><span class="params">(msg *pb.ChaincodeMessage)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	err = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//send may happen on a closed channel when the system is</span></span><br><span class="line">	<span class="comment">//shutting down. Just catch the exception and return error</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = SendPanicFailure(fmt.Sprintf(<span class="string">&quot;%s&quot;</span>, r))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	s.send &lt;- msg</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收是从recv读数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">Recv</span><span class="params">()</span> <span class="params">(*pb.ChaincodeMessage, error)</span></span> &#123;</span><br><span class="line">	msg, ok := &lt;-s.recv</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;channel is closed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *inProcStream)</span> <span class="title">CloseSend</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 实际啥也没做</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Peer和链码容器的交互，完成链码容器启动"><a href="#Peer和链码容器的交互，完成链码容器启动" class="headerlink" title="Peer和链码容器的交互，完成链码容器启动"></a>Peer和链码容器的交互，完成链码容器启动</h3><p>部署链码需要Peer和链码容器交互，不然Peer怎么知道链码容器已经启动。以下是一份peer的DEBUG日志，在下面标注了启动容器和链码Init过程中的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] LaunchConfig -&gt; DEBU 098 launchConfig: executable:&quot;chaincode&quot;,Args:[chaincode,-peer.address&#x3D;peer0.org1.example.com:7052],Envs:[CORE_CHAINCODE_LOGGING_LEVEL&#x3D;info,CORE_CHAINCODE_LOGGING_SHIM&#x3D;warning,CORE_CHAINCODE_LOGGING_FORMAT&#x3D;%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;,CORE_CHAINCODE_ID_NAME&#x3D;lscc:1.4.3,CORE_PEER_TLS_ENABLED&#x3D;true,CORE_TLS_CLIENT_KEY_PATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.key,CORE_TLS_CLIENT_CERT_PATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.crt,CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;peer.crt],Files:[&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.crt &#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.key &#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;peer.crt]</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 099 start container: lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09a start container with args: chaincode -peer.address&#x3D;peer0.org1.example.com:7052</span><br><span class="line">2019-09-09 07:52:09.915 UTC [chaincode] Start -&gt; DEBU 09b start container with env:</span><br><span class="line">	CORE_CHAINCODE_LOGGING_LEVEL&#x3D;info</span><br><span class="line">	CORE_CHAINCODE_LOGGING_SHIM&#x3D;warning</span><br><span class="line">	CORE_CHAINCODE_LOGGING_FORMAT&#x3D;%&#123;color&#125;%&#123;time:2006-01-02 15:04:05.000 MST&#125; [%&#123;module&#125;] %&#123;shortfunc&#125; -&gt; %&#123;level:.4s&#125; %&#123;id:03x&#125;%&#123;color:reset&#125; %&#123;message&#125;</span><br><span class="line">	CORE_CHAINCODE_ID_NAME&#x3D;lscc:1.4.3</span><br><span class="line">	CORE_PEER_TLS_ENABLED&#x3D;true</span><br><span class="line">	CORE_TLS_CLIENT_KEY_PATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.key</span><br><span class="line">	CORE_TLS_CLIENT_CERT_PATH&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;client.crt</span><br><span class="line">	CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;etc&#x2F;hyperledger&#x2F;fabric&#x2F;peer.crt</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09c waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 09d got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] getInstance -&gt; DEBU 09e chaincode instance created for lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 09f container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a0 waiting for container(lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] lockContainer -&gt; DEBU 0a1 got container (lscc-1.4.3) lock</span><br><span class="line">2019-09-09 07:52:09.915 UTC [container] unlockContainer -&gt; DEBU 0a2 container lock deleted(lscc-1.4.3)</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func2 -&gt; DEBU 0a3 chaincode-support started for  lscc-1.4.3</span><br><span class="line">2019-09-09 07:52:09.915 UTC [inproccontroller] func1 -&gt; DEBU 0a4 chaincode started for lscc-1.4.3</span><br><span class="line">&#x2F;&#x2F; 以上日志对应的代码流程在上文都讲到了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下是交互过程peer日志</span><br><span class="line">&#x2F;&#x2F; peer收到容器的注册消息</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] handleMessage -&gt; DEBU 0a5 [] Fabric side handling ChaincodeMessage of type: REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a6 Received REGISTER in state created</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] Register -&gt; DEBU 0a7 registered handler complete for chaincode lscc:1.4.3</span><br><span class="line">2019-09-09 07:52:09.916 UTC [chaincode] HandleRegister -&gt; DEBU 0a8 Got REGISTER for chaincodeID &#x3D; name:&quot;lscc:1.4.3&quot; , sending back REGISTERED</span><br><span class="line">2019-09-09 07:52:09.920 UTC [grpc] HandleSubConnStateChange -&gt; DEBU 0a9 pickfirstBalancer: HandleSubConnStateChange: 0xc0026318c0, READY</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] HandleRegister -&gt; DEBU 0aa Changed state to established for name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; peer发送ready消息</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ab sending READY for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] sendReady -&gt; DEBU 0ac Changed to state ready for chaincode name:&quot;lscc:1.4.3&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 已经完成启动容器</span><br><span class="line">2019-09-09 07:52:09.923 UTC [chaincode] Launch -&gt; DEBU 0ad launch complete</span><br><span class="line">2019-09-09 07:52:09.924 UTC [chaincode] Execute -&gt; DEBU 0ae Entry</span><br><span class="line">&#x2F;&#x2F; 收到容器COMPLETED消息</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] handleMessage -&gt; DEBU 0af [01b03aae] Fabric side handling ChaincodeMessage of type: COMPLETED in state ready</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通知scc，部署已经完成</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Notify -&gt; DEBU 0b0 [01b03aae] notifying Txid:01b03aae-17a6-4b63-874e-dc20d6f5df0c, channelID:</span><br><span class="line">2019-09-09 07:52:09.925 UTC [chaincode] Execute -&gt; DEBU 0b1 Exit</span><br><span class="line">2019-09-09 07:52:09.925 UTC [sccapi] deploySysCC -&gt; INFO 0b2 system chaincode lscc&#x2F;(github.com&#x2F;hyperledger&#x2F;fabric&#x2F;core&#x2F;scc&#x2F;lscc) deployed</span><br></pre></td></tr></table></figure>

<p>可以到REGISTER、READY、COMPLETED等消息，以及状态的改变：created、ready。</p>
<p>但前面还没有介绍Peer和链码容器之间的通信，所以不展示代码了，展示一下Peer和链码容器的消息交互图：</p>
<p><img src="https://lessisbetter.site/images/2019-09-deploycc-msg.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2019/09/06/fabric-source-endorser-policy-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://lessisbetter.site/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/06/fabric-source-endorser-policy-flow/" class="post-title-link" itemprop="url">Fabric 1.4源码解读 1：背书策略是怎么使用的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-06 16:39:45" itemprop="dateCreated datePublished" datetime="2019-09-06T16:39:45+08:00">2019-09-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:44:06" itemprop="dateModified" datetime="2020-12-13T16:44:06+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://lessisbetter.site/images/2019-09-endorser-policy.png" alt="endorser policy"></p>
<p>背书策略是Fabric中的一个重要一环，想梳理一下背书策略的上链和使用流程。</p>
<p>背书策略是部署和升级链码时使用的，需要发送配置交易，所以尝试了从背书节点收到交易，然后处理交易的流程入手，找到背书策略的入口，结果毫无头绪。</p>
<p>换一种思路，从使用入手，向上追溯，这种就非常顺利了。</p>
<h2 id="从背书策略的使用入手"><a href="#从背书策略的使用入手" class="headerlink" title="从背书策略的使用入手"></a>从背书策略的使用入手</h2><p>VSCC会利用背书策略，并且背书策略不满足时会返回一个：背书策略不满足的错误，每一个上链的交易详细中都有这么一个Validation字段，为0代表有效交易，否则是无效交易，并用数字表示原因，背书策略不满足的序号就是10。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxValidationCode <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	...</span><br><span class="line">	TxValidationCode_ENDORSEMENT_POLICY_FAILURE   TxValidationCode = <span class="number">10</span></span><br><span class="line">	...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>TxValidationCode_ENDORSEMENT_POLICY_FAILURE</code>被<code>VSCCValidateTx</code>使用，系统链码和普通链码都有背书策略需要满足，下面代码片是普通链码部分，可以发现调用<code>VSCCValidateTxForCC</code>验证交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VSCCValidateTx executes vscc validation for transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">      <span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个chaincode都会提供escc和vscc，现在都是默认的，也就是说escc和vscc都可以是具备可插拔的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode list -C mychannel --instantiated</span><br><span class="line">Get instantiated chaincodes on channel mychannel:</span><br><span class="line">Name: mycc, Version: 1.1, Path: github.com&#x2F;chaincode&#x2F;chaincode_example02&#x2F;go&#x2F;, Escc: escc, Vscc: vscc</span><br></pre></td></tr></table></figure>

<p><code>VSCCValidateTxForCC</code>会从交易的context中获取验证插件，然后利用插件验证交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTxForCC</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	logger.Debug(<span class="string">&quot;Validating&quot;</span>, ctx, <span class="string">&quot;with plugin&quot;</span>)</span><br><span class="line">  <span class="comment">// 使用插件验证交易</span></span><br><span class="line">	err := v.pluginValidator.ValidateWithPlugin(ctx)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If the error is a pluggable validation execution error, cast it to the common errors ExecutionFailureError.</span></span><br><span class="line">	<span class="keyword">if</span> e, isExecutionError := err.(*validation.ExecutionFailureError); isExecutionError &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;commonerrors.VSCCExecutionFailureError&#123;Err: e&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Else, treat it as an endorsement error.</span></span><br><span class="line">	<span class="keyword">return</span> &amp;commonerrors.VSCCEndorsementPolicyError&#123;Err: err&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pv *PluginValidator)</span> <span class="title">ValidateWithPlugin</span><span class="params">(ctx *Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取vscc插件</span></span><br><span class="line">	plugin, err := pv.getOrCreatePlugin(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;validation.ExecutionFailureError&#123;</span><br><span class="line">			Reason: fmt.Sprintf(<span class="string">&quot;plugin with name %s couldn&#x27;t be used: %v&quot;</span>, ctx.VSCCName, err),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 利用插件验证</span></span><br><span class="line">	err = plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, <span class="number">0</span>, SerializedPolicy(ctx.Policy))</span><br><span class="line">	validityStatus := <span class="string">&quot;valid&quot;</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		validityStatus = fmt.Sprintf(<span class="string">&quot;invalid: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	logger.Debug(<span class="string">&quot;Transaction&quot;</span>, ctx.TxID, <span class="string">&quot;appears to be&quot;</span>, validityStatus)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Plugin validates transactions</span></span><br><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Validate returns nil if the action at the given position inside the transaction</span></span><br><span class="line">	<span class="comment">// at the given position in the given block is valid, or an error if not.</span></span><br><span class="line">	Validate(block *common.Block, namespace <span class="keyword">string</span>, txPosition <span class="keyword">int</span>, actionPosition <span class="keyword">int</span>, contextData ...ContextDatum) error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Init injects dependencies into the instance of the Plugin</span></span><br><span class="line">	Init(dependencies ...Dependency) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前验证插件有2种实现，<code>TxValidatorV1_2</code>和<code>V1_3Validation</code>,<code>Validate</code>还从context取出了序列化的背书策略，vscc会调用PolicyEvalutor交易的背书是否满足背书策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *DefaultValidation)</span> <span class="title">Validate</span><span class="params">(block *common.Block, namespace <span class="keyword">string</span>, txPosition <span class="keyword">int</span>, actionPosition <span class="keyword">int</span>, contextData ...validation.ContextDatum)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(contextData) == <span class="number">0</span> &#123;</span><br><span class="line">		logger.Panicf(<span class="string">&quot;Expected to receive policy bytes in context data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拿到序列化后的policy</span></span><br><span class="line">	serializedPolicy, isSerializedPolicy := contextData[<span class="number">0</span>].(SerializedPolicy)</span><br><span class="line">	<span class="keyword">if</span> !isSerializedPolicy &#123;</span><br><span class="line">		logger.Panicf(<span class="string">&quot;Expected to receive a serialized policy in the first context data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> block == <span class="literal">nil</span> || block.Data == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;empty block&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> txPosition &gt;= <span class="built_in">len</span>(block.Data.Data) &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;block has only %d transactions, but requested tx at position %d&quot;</span>, <span class="built_in">len</span>(block.Data.Data), txPosition)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> block.Header == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.Errorf(<span class="string">&quot;no block header&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用不同版本的validator进行验证</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> v.Capabilities.V1_3Validation():</span><br><span class="line">		err = v.TxValidatorV1_3.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> v.Capabilities.V1_2Validation():</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		err = v.TxValidatorV1_2.Validate(block, namespace, txPosition, actionPosition, serializedPolicy.Bytes())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger.Debugf(<span class="string">&quot;block %d, namespace: %s, tx %d validation results is: %v&quot;</span>, block.Header.Number, namespace, txPosition, err)</span><br><span class="line">	<span class="keyword">return</span> convertErrorTypeOrPanic(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证代码使用v2/validation_logic.go中的实现</span></span><br><span class="line"><span class="comment">// Validate validates the given envelope corresponding to a transaction with an endorsement</span></span><br><span class="line"><span class="comment">// policy as given in its serialized form</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(vscc *Validator)</span> <span class="title">Validate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	block *common.Block,</span></span></span><br><span class="line"><span class="function"><span class="params">	namespace <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	txPosition <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	actionPosition <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	policyBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">commonerrors</span>.<span class="title">TxValidationError</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// evaluate the signature set against the policy</span></span><br><span class="line">  err = vscc.policyEvaluator.Evaluate(policyBytes, signatureSet)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Warningf(<span class="string">&quot;Endorsement policy failure for transaction txid=%s, err: %s&quot;</span>, chdr.GetTxId(), err.Error())</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(signatureSet) &lt; <span class="built_in">len</span>(<span class="built_in">cap</span>.Action.Endorsements) &#123;</span><br><span class="line">      <span class="comment">// Warning: duplicated identities exist, endorsement failure might be cause by this reason</span></span><br><span class="line">      <span class="keyword">return</span> policyErr(errors.New(DUPLICATED_IDENTITY_ERROR))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> policyErr(fmt.Errorf(<span class="string">&quot;VSCC error: endorsement policy failure, err: %s&quot;</span>, err))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PolicyEvaluator evaluates policies</span></span><br><span class="line"><span class="keyword">type</span> PolicyEvaluator <span class="keyword">interface</span> &#123;</span><br><span class="line">	validation.Dependency</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies</span></span><br><span class="line">	<span class="comment">// the policy with the given bytes</span></span><br><span class="line">	Evaluate(policyBytes []<span class="keyword">byte</span>, signatureSet []*common.SignedData) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Evaluate</code>会创建背书策略实例，然后利用背书策略验证背书签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">func (id *PolicyEvaluator) Evaluate(policyBytes []byte, signatureSet []*common.SignedData) error &#123;</span><br><span class="line">	pp :&#x3D; cauthdsl.NewPolicyProvider(id.IdentityDeserializer)</span><br><span class="line">	policy, _, err :&#x3D; pp.NewPolicy(policyBytes)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return policy.Evaluate(signatureSet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Policy is used to determine if a signature is valid</span><br><span class="line">type Policy interface &#123;</span><br><span class="line">	&#x2F;&#x2F; Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">	Evaluate(signatureSet []*cb.SignedData) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Evaluate takes a set of SignedData and evaluates whether this set of signatures satisfies the policy</span><br><span class="line">func (p *policy) Evaluate(signatureSet []*cb.SignedData) error &#123;</span><br><span class="line">	if p &#x3D;&#x3D; nil &#123;</span><br><span class="line">		return fmt.Errorf(&quot;No such policy&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	idAndS :&#x3D; make([]IdentityAndSignature, len(signatureSet))</span><br><span class="line">	for i, sd :&#x3D; range signatureSet &#123;</span><br><span class="line">		idAndS[i] &#x3D; &amp;deserializeAndVerify&#123;</span><br><span class="line">			signedData:   sd,</span><br><span class="line">			deserializer: p.deserializer,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ok :&#x3D; p.evaluator(deduplicate(idAndS), make([]bool, len(signatureSet)))</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		return errors.New(&quot;signature set did not satisfy policy&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体背书验证签名的实现，当下就先不关心了。<strong>回过头来想一下，VSCC从哪拿到了背书策略？</strong></p>
<h2 id="VSCC的背书策略哪来的？"><a href="#VSCC的背书策略哪来的？" class="headerlink" title="VSCC的背书策略哪来的？"></a>VSCC的背书策略哪来的？</h2><p>回到上文第一次出现背书策略的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func (pv *PluginValidator) ValidateWithPlugin(ctx *Context) error &#123;</span><br><span class="line">  err &#x3D; plugin.Validate(ctx.Block, ctx.Namespace, ctx.Seq, 0, SerializedPolicy(ctx.Policy))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Context defines information about a transaction</span><br><span class="line">&#x2F;&#x2F; that is being validated</span><br><span class="line">type Context struct &#123;</span><br><span class="line">	Seq       int</span><br><span class="line">	Envelope  []byte</span><br><span class="line">	TxID      string</span><br><span class="line">	Channel   string</span><br><span class="line">	VSCCName  string</span><br><span class="line">	Policy    []byte &#x2F;&#x2F; 背书策略</span><br><span class="line">	Namespace string</span><br><span class="line">	Block     *common.Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>VSCCValidateTx</code>函数会创建Context，填写policy字段，其中policy是调用<code>GetInfoForValidate</code>获取的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">VSCCValidateTx</span><span class="params">(seq <span class="keyword">int</span>, payload *common.Payload, envBytes []<span class="keyword">byte</span>, block *common.Block)</span> <span class="params">(error, peer.TxValidationCode)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 普通链码</span></span><br><span class="line">  <span class="keyword">if</span> !v.sccprovider.IsSysCC(ccID) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取policy、vscc等</span></span><br><span class="line">    <span class="comment">// Get latest chaincode version, vscc and validate policy</span></span><br><span class="line">    txcc, vscc, policy, err := v.GetInfoForValidate(chdr, ns)</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// do VSCC validation</span></span><br><span class="line">    ctx := &amp;Context&#123;</span><br><span class="line">      Seq:       seq,</span><br><span class="line">      Envelope:  envBytes,</span><br><span class="line">      Block:     block,</span><br><span class="line">      TxID:      chdr.TxId,</span><br><span class="line">      Channel:   chdr.ChannelId,</span><br><span class="line">      Namespace: ns,</span><br><span class="line">      Policy:    policy, <span class="comment">// Here</span></span><br><span class="line">      VSCCName:  vscc.ChaincodeName,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = v.VSCCValidateTxForCC(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> *commonerrors.VSCCEndorsementPolicyError:</span><br><span class="line">        <span class="keyword">return</span> err, peer.TxValidationCode_ENDORSEMENT_POLICY_FAILURE</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> err, peer.TxValidationCode_INVALID_OTHER_REASON</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// SCC</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GetInfoForValidate</code>先是获取了<code>ChaincodeDefinition</code>，它记录了peer对某个链码的proposal背书和验证的必要信息，然后利用<code>ChaincodeDefinition.Validation</code>获取了policy。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetInfoForValidate gets the ChaincodeInstance(with latest version) of tx, vscc and policy from lscc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VsccValidatorImpl)</span> <span class="title">GetInfoForValidate</span><span class="params">(chdr *common.ChannelHeader, ccID <span class="keyword">string</span>)</span> <span class="params">(*sysccprovider.ChaincodeInstance, *sysccprovider.ChaincodeInstance, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	cc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">		ChainID:          chdr.ChannelId,</span><br><span class="line">		ChaincodeName:    ccID,</span><br><span class="line">		ChaincodeVersion: coreUtil.GetSysCCVersion(),</span><br><span class="line">	&#125;</span><br><span class="line">	vscc := &amp;sysccprovider.ChaincodeInstance&#123;</span><br><span class="line">		ChainID:          chdr.ChannelId,</span><br><span class="line">		ChaincodeName:    <span class="string">&quot;vscc&quot;</span>,                     <span class="comment">// default vscc for system chaincodes</span></span><br><span class="line">		ChaincodeVersion: coreUtil.GetSysCCVersion(), <span class="comment">// Get vscc version</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> policy []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> !v.sccprovider.IsSysCC(ccID) &#123;</span><br><span class="line">		<span class="comment">// when we are validating a chaincode that is not a</span></span><br><span class="line">		<span class="comment">// system CC, we need to ask the CC to give us the name</span></span><br><span class="line">		<span class="comment">// of VSCC and of the policy that should be used</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// obtain name of the VSCC and the policy</span></span><br><span class="line">		<span class="comment">// 获取cc 定义</span></span><br><span class="line">		cd, err := v.getCDataForCC(chdr.ChannelId, ccID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			msg := fmt.Sprintf(<span class="string">&quot;Unable to get chaincode data from ledger for txid %s, due to %s&quot;</span>, chdr.TxId, err)</span><br><span class="line">			logger.Errorf(msg)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		cc.ChaincodeName = cd.CCName()</span><br><span class="line">		cc.ChaincodeVersion = cd.CCVersion()</span><br><span class="line">		<span class="comment">// 拿到policy</span></span><br><span class="line">		vscc.ChaincodeName, policy = cd.Validation()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// when we are validating a system CC, we use the default</span></span><br><span class="line">		<span class="comment">// VSCC and a default policy that requires one signature</span></span><br><span class="line">		<span class="comment">// from any of the members of the channel</span></span><br><span class="line">		p := cauthdsl.SignedByAnyMember(v.support.GetMSPIDs(chdr.ChannelId))</span><br><span class="line">		policy, err = utils.Marshal(p)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cc, vscc, policy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- ChaincodeDefinition - interface for ChaincodeData ------</span></span><br><span class="line"><span class="comment">// ChaincodeDefinition describes all of the necessary information for a peer to decide whether to endorse</span></span><br><span class="line"><span class="comment">// a proposal and whether to validate a transaction, for a particular chaincode.</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeDefinition <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// CCName returns the name of this chaincode (the name it was put in the ChaincodeRegistry with).</span></span><br><span class="line">	CCName() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hash returns the hash of the chaincode.</span></span><br><span class="line">	Hash() []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// CCVersion returns the version of the chaincode.</span></span><br><span class="line">	CCVersion() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Validation returns how to validate transactions for this chaincode.</span></span><br><span class="line">	<span class="comment">// The string returned is the name of the validation method (usually &#x27;vscc&#x27;)</span></span><br><span class="line">	<span class="comment">// and the bytes returned are the argument to the validation (in the case of</span></span><br><span class="line">	<span class="comment">// &#x27;vscc&#x27;, this is a marshaled pb.VSCCArgs message).</span></span><br><span class="line">	Validation() (<span class="keyword">string</span>, []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Endorsement returns how to endorse proposals for this chaincode.</span></span><br><span class="line">	<span class="comment">// The string returns is the name of the endorsement method (usually &#x27;escc&#x27;).</span></span><br><span class="line">	Endorsement() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ChaincodeData</code>实现了<code>ChaincodeDefinition</code>接口，<code>ChaincodeData</code>是LSCC保存的数据，它其中有1个字段就是Policy。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Validation returns how to validate transactions for this chaincode.</span></span><br><span class="line"><span class="comment">// The string returned is the name of the validation method (usually &#x27;vscc&#x27;)</span></span><br><span class="line"><span class="comment">// and the bytes returned are the argument to the validation (in the case of</span></span><br><span class="line"><span class="comment">// &#x27;vscc&#x27;, this is a marshaled pb.VSCCArgs message).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cd *ChaincodeData)</span> <span class="title">Validation</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> cd.Vscc, cd.Policy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- ChaincodeData is stored on the LSCC -------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ChaincodeData defines the datastructure for chaincodes to be serialized by proto</span></span><br><span class="line"><span class="comment">// Type provides an additional check by directing to use a specific package after instantiation</span></span><br><span class="line"><span class="comment">// Data is Type specifc (see CDSPackage and SignedCDSPackage)</span></span><br><span class="line"><span class="keyword">type</span> ChaincodeData <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Name of the chaincode</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=name&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Version of the chaincode</span></span><br><span class="line">	Version <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,2,opt,name=version&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Escc for the chaincode instance</span></span><br><span class="line">	Escc <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,3,opt,name=escc&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Vscc for the chaincode instance</span></span><br><span class="line">	Vscc <span class="keyword">string</span> <span class="string">`protobuf:&quot;bytes,4,opt,name=vscc&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 背书策略</span></span><br><span class="line">	<span class="comment">// Policy endorsement policy for the chaincode instance</span></span><br><span class="line">	Policy []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,5,opt,name=policy,proto3&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Data data specific to the package</span></span><br><span class="line">	Data []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,6,opt,name=data,proto3&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Id of the chaincode that&#x27;s the unique fingerprint for the CC This is not</span></span><br><span class="line">	<span class="comment">// currently used anywhere but serves as a good eyecatcher</span></span><br><span class="line">	Id []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,7,opt,name=id,proto3&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// InstantiationPolicy for the chaincode</span></span><br><span class="line">	InstantiationPolicy []<span class="keyword">byte</span> <span class="string">`protobuf:&quot;bytes,8,opt,name=instantiation_policy,proto3&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LSCC的Policy哪来的？"><a href="#LSCC的Policy哪来的？" class="headerlink" title="LSCC的Policy哪来的？"></a>LSCC的Policy哪来的？</h2><blockquote>
<p>提醒：链码实例化在代码里使用<strong>Deploy</strong>，而不是Instantiate，这样可以让代码更简洁，所以链码实例化也常称为链码部署。</p>
</blockquote>
<p><code>executeDeploy</code>为部署链码，也就是在部署链码的时候会保存背书策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeDeploy implements the &quot;instantiate&quot; Invoke transaction</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">executeDeploy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">	chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">	policy []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	escc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	vscc []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cdfs *ccprovider.ChaincodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">	ccpackfs ccprovider.CCPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">	collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">//just test for existence of the chaincode in the LSCC</span></span><br><span class="line">	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">	_, err := lscc.getCCInstance(stub, chaincodeName)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ExistsErr(chaincodeName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//retain chaincode specific data and fill channel specific ones</span></span><br><span class="line">	cdfs.Escc = <span class="keyword">string</span>(escc)</span><br><span class="line">	cdfs.Vscc = <span class="keyword">string</span>(vscc)</span><br><span class="line">	<span class="comment">// 保存背书策略</span></span><br><span class="line">	cdfs.Policy = policy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>executeDeployOrUpgrade</code>是执行链码实例化和升级时调用，它会传递Policy，在链码部署和升级时都会保存背书策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// executeDeployOrUpgrade routes the code path either to executeDeploy or executeUpgrade</span></span><br><span class="line"><span class="comment">// depending on its function argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">executeDeployOrUpgrade</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	stub shim.ChaincodeStubInterface,</span></span></span><br><span class="line"><span class="function"><span class="params">	chainname <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	cds *pb.ChaincodeDeploymentSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">	policy, escc, vscc, collectionConfigBytes []<span class="keyword">byte</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	function <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(*ccprovider.ChaincodeData, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	chaincodeName := cds.ChaincodeSpec.ChaincodeId.Name</span><br><span class="line">	chaincodeVersion := cds.ChaincodeSpec.ChaincodeId.Version</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := lscc.isValidChaincodeName(chaincodeName); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := lscc.isValidChaincodeVersion(chaincodeName, chaincodeVersion); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ccpack, err := lscc.Support.GetChaincodeFromLocalStorage(chaincodeName, chaincodeVersion)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		retErrMsg := fmt.Sprintf(<span class="string">&quot;cannot get package for chaincode (%s:%s)&quot;</span>, chaincodeName, chaincodeVersion)</span><br><span class="line">		logger.Errorf(<span class="string">&quot;%s-err:%s&quot;</span>, retErrMsg, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%s&quot;</span>, retErrMsg)</span><br><span class="line">	&#125;</span><br><span class="line">	cd := ccpack.GetChaincodeData()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> function &#123;</span><br><span class="line">	<span class="keyword">case</span> DEPLOY:</span><br><span class="line">		<span class="keyword">return</span> lscc.executeDeploy(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)</span><br><span class="line">	<span class="keyword">case</span> UPGRADE:</span><br><span class="line">		<span class="keyword">return</span> lscc.executeUpgrade(stub, chainname, cds, policy, escc, vscc, cd, ccpack, collectionConfigBytes)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		logger.Panicf(<span class="string">&quot;Programming error, unexpected function &#x27;%s&#x27;&quot;</span>, function)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// unreachable code</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LSCC也实现了ChainCode接口，与普通链码的实现并没有区别，只不过LSCC并不运行在容器中。<code>LifeCycleSysCC.Invoke</code>会根据参数调用不同的函数，而部署和升级时，会调用<code>executeDeployOrUpgrade</code>部署链码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke implements lifecycle functions &quot;deploy&quot;, &quot;start&quot;, &quot;stop&quot;, &quot;upgrade&quot;.</span></span><br><span class="line"><span class="comment">// Deploy&#x27;s arguments -  &#123;[]byte(&quot;deploy&quot;), []byte(&lt;chainname&gt;), &lt;unmarshalled pb.ChaincodeDeploymentSpec&gt;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Invoke also implements some query-like functions</span></span><br><span class="line"><span class="comment">// Get chaincode arguments -  &#123;[]byte(&quot;getid&quot;), []byte(&lt;chainname&gt;), []byte(&lt;chaincodename&gt;)&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lscc *LifeCycleSysCC)</span> <span class="title">Invoke</span><span class="params">(stub shim.ChaincodeStubInterface)</span> <span class="title">pb</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> function &#123;</span><br><span class="line">    <span class="keyword">case</span> INSTALL:</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> DEPLOY, UPGRADE:</span><br><span class="line">      <span class="comment">// 提取背书策略</span></span><br><span class="line">      <span class="comment">// optional arguments here (they can each be nil and may or may not be present)</span></span><br><span class="line">      <span class="comment">// args[3] is a marshalled SignaturePolicyEnvelope representing the endorsement policy</span></span><br><span class="line">      <span class="comment">// args[4] is the name of escc</span></span><br><span class="line">      <span class="comment">// args[5] is the name of vscc</span></span><br><span class="line">      <span class="comment">// args[6] is a marshalled CollectionConfigPackage struct</span></span><br><span class="line">      <span class="keyword">var</span> EP []<span class="keyword">byte</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">3</span> &amp;&amp; <span class="built_in">len</span>(args[<span class="number">3</span>]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        EP = args[<span class="number">3</span>]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p := cauthdsl.SignedByAnyMember(peer.GetMSPIDs(channel))</span><br><span class="line">        EP, err = utils.Marshal(p)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> shim.Error(err.Error())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      cd, err := lscc.executeDeployOrUpgrade(stub, channel, cds, EP, escc, vscc, collectionsConfig, function)</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">case</span> ...:</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们终于知道Policy是哪来的，又是如何被使用的了。管理和查看链码信息，本质是创建一个调用LSCC的Proposal或者交易，链码的信息会保存在LSCC，当VSCC验证链码的交易时，会从LSCC获取信息，包括背书策略、vscc插件等，以验证交易。</p>
<p>最后，ESCC、VSCC也是进行了可插拔设计的。</p>
<p><img src="https://lessisbetter.site/images/2019-09-endorser-policy.png" alt="endorser policy"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP备18051706号 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大彬</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  

<script src="//cdn.jsdelivr.net/npm/algoliasearch@4.8.2/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4.8.7/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>







</body>
</html>
